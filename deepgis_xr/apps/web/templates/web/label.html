{% extends "base.html" %}
{% load static %}

{% block extra_head %}
<!-- Mobile viewport meta tag -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
{% endblock %}

{% block content %}

<style>
	/* Updated styles for better layout */
	.wrapper {
		display: flex;
		flex-direction: column;
		height: calc(100vh - 56px); /* Account for navbar */
		overflow: hidden;
	}

	.main-content {
		display: flex;
		flex: 1;
		overflow: hidden;
		position: relative; /* For absolute positioning of sidebar toggle */
	}

	.control-sidebar {
		width: 300px;
		padding: 15px;
		background-color: #f8f9fa;
		border-left: 1px solid #e9ecef;
		overflow-y: auto;
		display: flex;
		flex-direction: column;
		transition: transform 0.3s ease;
		z-index: 100;
	}
	
	/* Mobile sidebar styles */
	@media (max-width: 768px) {
		.control-sidebar {
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			width: 85%;
			max-width: 320px;
			transform: translateX(100%);
			box-shadow: -2px 0 10px rgba(0, 0, 0, 0.2);
		}
		
		.control-sidebar.expanded {
			transform: translateX(0);
		}
		
		.tool-buttons button {
			padding: 10px; /* Larger touch targets */
			margin-bottom: 8px;
		}
		
		#categories_coll li {
			padding: 12px 10px; /* Larger touch targets for categories */
		}
	}

	#canvasContainer {
		flex: 1;
		display: flex;
		align-items: center;
		justify-content: center;
		background-color: #e9ecef;
		position: relative;
		overflow: hidden;
	}

	#canvasDiv {
		position: relative;
		box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
	}

	#canvas {
		display: block;
	}

	.footer-bar {
		padding: 10px 15px;
		background-color: #f8f9fa;
		border-top: 1px solid #e9ecef;
		display: flex;
		justify-content: space-between;
		align-items: center;
		height: 60px;
	}
	
	/* Mobile Bottom Toolbar */
	.mobile-toolbar {
		display: none;
		position: fixed;
		bottom: 60px;
		left: 0;
		right: 0;
		background-color: rgba(33, 37, 41, 0.9);
		padding: 10px;
		justify-content: space-around;
		z-index: 1000;
		box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
	}
	
	.mobile-toolbar button {
		background-color: transparent;
		border: none;
		color: white;
		font-size: 24px;
		width: 50px;
		height: 50px;
		border-radius: 50%;
		display: flex;
		align-items: center;
		justify-content: center;
	}
	
	.mobile-toolbar button.active {
		background-color: rgba(255, 255, 255, 0.2);
	}
	
	@media (max-width: 768px) {
		.mobile-toolbar {
			display: flex;
		}
	}
	
	/* Sidebar toggle button */
	#sidebar-toggle {
		position: absolute;
		top: 10px;
		right: 10px;
		z-index: 101;
		width: 40px;
		height: 40px;
		background: rgba(0,0,0,0.5);
		color: white;
		border: none;
		border-radius: 50%;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 20px;
		cursor: pointer;
		box-shadow: 0 2px 5px rgba(0,0,0,0.2);
		display: none; /* Hide by default on desktop */
	}
	
	@media (max-width: 768px) {
		#sidebar-toggle {
			display: flex; /* Show on mobile */
		}
	}

	.tool-buttons {
		display: flex;
		flex-wrap: wrap;
		gap: 8px;
		margin-bottom: 15px;
	}

	.tool-buttons button {
		flex: 1 0 auto;
		min-width: 95px;
	}
	
	/* Mobile-friendly responsive adjustments */
	@media (max-width: 768px) {
		.footer-bar {
			height: auto;
			padding: 5px 10px;
			font-size: 12px;
		}
		
		.coordinate-display {
			font-size: 10px;
		}
		
		#full-image-url {
			max-width: 90vw;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
			display: inline-block;
		}
	}

	#categories_coll {
		list-style: none;
		padding: 0;
		margin: 0 0 15px 0;
		overflow-y: auto;
	}

	#categories_coll li {
		padding: 8px 10px;
		margin-bottom: 5px;
		background-color: #fff;
		border-radius: 4px;
		border: 1px solid #ddd;
		display: flex;
		align-items: center;
	}

	#categories_coll .circle {
		width: 15px;
		height: 15px;
		border-radius: 50%;
		margin-left: auto;
	}

	.coordinate-display {
		font-size: 12px;
		color: #555;
	}

	.nav-buttons {
		display: flex;
		gap: 10px;
	}

	/* Measurement tools - Updated for architectural blueprint style */
	.measurement-info {
		position: absolute;
		z-index: 100;
		background: rgba(240, 248, 255, 0.9);
		border: 1px solid #1E54A7;
		padding: 5px 10px;
		border-radius: 0;
		font-size: 12px;
		display: none;
		color: #1E54A7;
		font-family: 'Arial', sans-serif;
		box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
	}

	.measurement-label {
		background: rgba(240, 248, 255, 0.9);
		border: 1px solid #1E54A7;
		border-radius: 0;
		padding: 4px 8px;
		font-family: 'Courier New', monospace;
		font-size: 12px;
		color: #1E54A7;
		font-weight: 600;
		letter-spacing: 0.5px;
		pointer-events: none;
		box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	}

	/* Add CSS for loading indicator */
	.overlay {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		display: flex;
		justify-content: center;
		align-items: center;
		background-color: rgba(0, 0, 0, 0.5);
		z-index: 9999;
	}
	
	.loading-spinner {
		width: 50px;
		height: 50px;
		border: 5px solid rgba(255, 255, 255, 0.3);
		border-radius: 50%;
		border-top-color: #fff;
		animation: spin 1s ease-in-out infinite;
	}
	
	@keyframes spin {
		to { transform: rotate(360deg); }
	}
	
	.toast-container {
		position: fixed;
		top: 20px;
		right: 20px;
		z-index: 10000;
	}
	
	.toast {
		background-color: #f8d7da;
		color: #721c24;
		padding: 15px 25px;
		border-radius: 4px;
		margin-bottom: 10px;
		box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
		display: flex;
		justify-content: space-between;
		max-width: 350px;
	}
	
	.toast-close {
		background: none;
		border: none;
		color: #721c24;
		font-size: 20px;
		cursor: pointer;
	}

	/* Loader overlay and spinner CSS */
	#loading-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background-color: rgba(0, 0, 0, 0.5);
		display: flex;
		justify-content: center;
		align-items: center;
		z-index: 9999;
	}

	#canvasDiv.loading {
		position: relative;
	}

	.loading-spinner {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		z-index: 1000;
	}

	@keyframes spin {
		0% { transform: rotate(0deg); }
		100% { transform: rotate(360deg); }
	}

	.spinner-border {
		display: inline-block;
		width: 3rem;
		height: 3rem;
		vertical-align: text-bottom;
		border: 0.25em solid rgba(255, 255, 255, 0.5);
		border-right-color: #fff;
		border-radius: 50%;
		animation: spin .75s linear infinite;
	}

	.sr-only {
		position: absolute;
		width: 1px;
		height: 1px;
		padding: 0;
		margin: -1px;
		overflow: hidden;
		clip: rect(0, 0, 0, 0);
		white-space: nowrap;
		border: 0;
	}

	/* Notification styling */
	#notification-container {
		position: fixed;
		top: 20px;
		right: 20px;
		z-index: 9999;
		max-width: 350px;
	}

	.notification {
		padding: 15px;
		margin-bottom: 10px;
		border-radius: 4px;
		box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
		animation: slide-in 0.5s ease-out;
		color: white;
	}

	.notification.error {
		background-color: #dc3545;
	}

	.notification.success {
		background-color: #28a745;
	}

	.notification.warning {
		background-color: #ffc107;
		color: #212529;
	}

	.notification .close-btn {
		float: right;
		font-weight: bold;
		font-size: 20px;
		line-height: 20px;
		cursor: pointer;
		transition: 0.3s;
	}

	.notification .close-btn:hover {
		color: black;
	}

	/* Zoom display */
	#zoom-level {
		font-size: 14px;
		font-weight: bold;
		color: #495057;
	}

	@keyframes slide-in {
		from { transform: translateX(100%); opacity: 0; }
		to { transform: translateX(0); opacity: 1; }
	}

	@keyframes fade-out {
		from { opacity: 1; }
		to { opacity: 0; }
	}
	
	/* Debug console styles */
	#debug-console {
		width: 100%;
		height: 150px;
		background-color: #1e1e1e;
		color: #39ff14; /* Bright green */
		font-family: 'Consolas', 'Monaco', monospace;
		font-size: 12px;
		padding: 8px;
		border-top: 1px solid #444;
		overflow-y: auto;
		display: none;
	}
	
	#debug-console.expanded {
		display: block;
	}
	
	#debug-console .log {
		margin: 2px 0;
		line-height: 1.2;
	}
	
	#debug-console .error {
		color: #ff4136;
	}
	
	#debug-console .warning {
		color: #ffdc00;
	}
	
	#debug-console .success {
		color: #39ff14;
	}
	
	#debug-console .info {
		color: #7fdbff;
	}
	
	#console-toggle {
		position: fixed;
		bottom: 25px;
		right: 20px;
		background-color: #444;
		color: white;
		border: none;
		border-radius: 4px;
		padding: 5px 10px;
		font-size: 12px;
		cursor: pointer;
		z-index: 1000;
	}
</style>

<div class="wrapper">
	<div class="main-content">
		<!-- Canvas Container -->
		<div id="canvasContainer">
			<div id="canvasDiv">
				<canvas id="canvas" resize></canvas>
				<div id="measurementInfo" class="measurement-info"></div>
			</div>
		</div>

		<!-- Sidebar Toggle Button for Mobile -->
		<button id="sidebar-toggle" aria-label="Toggle Sidebar">
			<i>≡</i>
		</button>

		<!-- Right Sidebar -->
		<div class="control-sidebar">
			<h5>Image Information</h5>
			<div class="card mb-3">
				<div class="card-body p-2">
					<p id="image_info_name" class="mb-1 small">Image: </p>
					<p id="image_info_dimensions" class="mb-1 small">Dimensions: </p>
					<p id="imageMetadata" class="mb-0 small">No image loaded</p>
				</div>
			</div>

			<h5>Tools</h5>
			<div class="tool-buttons">
				<button class="btn btn-sm btn-outline-primary" id="pen_button">Pen</button>
				<button class="btn btn-sm btn-outline-primary" id="polygon_button">Polygon</button>
				<button class="btn btn-sm btn-outline-primary" id="rectangle_button">Rectangle</button>
				<button class="btn btn-sm btn-outline-primary" id="circle_button">Circle</button>
				<button class="btn btn-sm btn-outline-primary" id="measure_button">Measure</button>
				<button class="btn btn-sm btn-outline-danger" id="remove_button">Remove</button>
				<button class="btn btn-sm btn-outline-secondary" id="undo_button">Undo</button>
			</div>

			<h5>Categories</h5>
			<ul id="categories_coll"></ul>

			<h5>Actions</h5>
			<div class="tool-buttons mb-3">
				<!-- Main action buttons in a 2x2 grid -->
				<div class="d-flex mb-2">
					<button class="btn btn-sm btn-success flex-fill me-1" id="save_button">Save</button>
					<button class="btn btn-sm btn-primary flex-fill" id="screenshot_button">Screenshot</button>
				</div>
				<div class="d-flex mb-2">
					<button class="btn btn-sm btn-info flex-fill me-1" id="pdf_button">Save as PDF</button>
					<button class="btn btn-sm btn-danger flex-fill" id="clear_button">Clear</button>
				</div>

				<!-- Navigation buttons -->
				<div class="d-flex mt-2">
					<button class="btn btn-sm btn-outline-secondary flex-fill me-1" id="prev_button">Previous</button>
					<button class="btn btn-sm btn-primary flex-fill" id="next_button">Next</button>
				</div>
				
				<!-- Zoom controls -->
				<h6 class="mt-3 mb-2">Zoom</h6>
				<div class="d-flex align-items-center mb-2">
					<button class="btn btn-outline-secondary me-2" id="zoom-in" title="Zoom In" style="min-height:40px; width:40px; font-size:18px;">+</button>
					<div class="flex-fill text-center" id="zoom-level">100%</div>
					<button class="btn btn-outline-secondary ms-2" id="zoom-out" title="Zoom Out" style="min-height:40px; width:40px; font-size:18px;">-</button>
				</div>
				<div class="d-flex">
					<button class="btn btn-outline-secondary flex-fill me-1" id="zoom-fit" title="Fit to Screen" style="min-height:40px; font-size:16px;">⤢</button>
					<button class="btn btn-outline-secondary flex-fill" id="zoom-reset" title="Reset Zoom (100%)" style="min-height:40px; font-size:16px;">⟲</button>
				</div>
				<!-- Mobile zoom hint -->
				<div class="d-flex mt-2 d-none d-md-block">
					<small class="text-muted">Hint: Pinch to zoom on mobile</small>
				</div>
			</div>

			<div class="mt-auto">
				<!-- Buttons removed as requested -->
			</div>
		</div>
	</div>

	<!-- Footer -->
	<div class="footer-bar">
		<div class="coordinate-display w-100">
			<span id="gps-coords">GPS: </span> | 
			<span id="pixel-coords">Pixels: </span> | 
			<span id="measure-distance">Distance: </span>
		</div>
	</div>
	
	<!-- Debug Console -->
	<div id="debug-console"></div>
	<button id="console-toggle">Show Debug Console</button>
	
	<!-- Mobile Bottom Toolbar -->
	<div class="mobile-toolbar">
		<button id="mobile-pen" title="Pen Tool"><i>✏️</i></button>
		<button id="mobile-shape" title="Shape Tools"><i>◻</i></button>
		<button id="mobile-measure" title="Measure"><i>📏</i></button>
		<button id="mobile-zoom-in" title="Zoom In"><i>🔍+</i></button>
		<button id="mobile-zoom-out" title="Zoom Out"><i>🔍-</i></button>
		<button id="mobile-save" title="Save"><i>💾</i></button>
		<button id="mobile-tools" title="More Tools"><i>⚙️</i></button>
	</div>
</div>

<!-- Add full image URL display at the bottom -->
<div style="position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; font-size: 12px; z-index: 1000;">
    <span id="full-image-url">Image URL: </span>
</div>

<!-- Images List Modal removed as requested -->

<!-- JavaScript for the app -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="https://deepgis.org/static/scripts/paperjs/dist/paper-full.min.js"></script>
<!-- Add Hammer.js for touch gestures -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
<!-- Use multiple CDN sources for redundancy -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script>
    // Ensure jsPDF is properly set up as a global
    window.addEventListener('load', function() {
        if (typeof window.jspdf === 'undefined' || typeof window.jspdf !== 'object') {
            console.warn('jsPDF not found in window.jspdf, checking alternative locations');
            // Try to find jsPDF in other common locations
            if (typeof jspdf !== 'undefined') {
                window.jspdf = jspdf;
                console.log('Found jsPDF in global scope, assigned to window.jspdf');
            } else if (typeof window.jsPDF !== 'undefined') {
                window.jspdf = { jsPDF: window.jsPDF };
                console.log('Found jsPDF in window.jsPDF, assigned to window.jspdf.jsPDF');
            } else {
                // Last resort - dynamically load jsPDF
                console.warn('jsPDF not found, attempting dynamic load');
                var script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                script.onload = function() {
                    if (typeof jspdf !== 'undefined') {
                        window.jspdf = jspdf;
                    } else if (typeof window.jsPDF !== 'undefined') {
                        window.jspdf = { jsPDF: window.jsPDF };
                    }
                    console.log('jsPDF dynamically loaded');
                };
                document.head.appendChild(script);
            }
        }
    });
</script>
<script type="text/javascript">
	// Define updateZoomDisplay as a global function
	window.updateZoomDisplay = function() {
		if (window.globals && typeof window.globals.zoomFactor !== 'undefined') {
			const percentage = Math.round(window.globals.zoomFactor * 100);
			$('#zoom-level').text(`${percentage}%`);
		}
	};

	// Setup PaperJS
	paper.install(window);
	
	// Global variables for PaperJS tools
	const globals = {
		path: null,                  // Current drawing path
		startPoint: null,            // Starting point for shapes
		centerPoint: null,           // Center point for circles
		tempGroup: null,             // Temporary group for current operation
		raster: null,                // The image raster
		undos: [],                   // Stack of operations for undo
		redos: [],                   // Stack of operations for redo
		imageLoaded: false,          // Flag to track image loading
		zoomFactor: 1,               // Current zoom level
		currentTool: null,           // Current active tool
		isMeasuring: false,          // Flag for measurement mode
		measureStartPoint: null,     // Start point for measurement
		measurementPath: null,       // Current measurement path
		measurementText: null,       // Text for current measurement
		savedMeasurements: [],       // Array of saved measurements
		gridMetrics: null,           // Grid metrics for measurement calculations
		sessionStartTime: new Date().getTime(), // Track session start time for metrics
		
		// Blueprint styling options
		blueprintStyle: {
			shapes: {
				fillColor: new paper.Color(1, 1, 0, 0.2) // Light yellow semi-transparent
			},
			measureLine: {
				color: new paper.Color(0, 0.5, 1),
				width: 1.5,
				dashArray: [5, 5]
			},
			measureText: {
				fontSize: 12,
				fontFamily: 'monospace',
				color: new paper.Color(0, 0, 0.8),
				backgroundColor: new paper.Color(1, 1, 1, 0.8)
			},
			dimension: {
				lineColor: new paper.Color(0, 0, 0.7),
				endpointRadius: 4,
				arrowSize: 8
			}
		}
	};

	// Variable declarations
	let currentImage = null;
	let currentCategory = null;
	let currentColor = "#ff0000";
	let isDrawing = false;
	let currentPath = [];
	let allPaths = [];
	let currentTool = null;
	let imageCache = {};

	// Move loading overlay functions to global scope
	// Function to show loading overlay
	function showLoadingOverlay(message = "Loading...") {
		// Create loading overlay if it doesn't exist
		if ($('#loading-overlay').length === 0) {
			$('body').append(`
				<div id="loading-overlay">
					<div class="spinner-border" role="status">
						<span class="sr-only">Loading...</span>
					</div>
					<div class="loading-text mt-2">${message}</div>
				</div>
			`);
		} else {
			// Update message and show existing overlay
			$('#loading-overlay .loading-text').text(message);
			$('#loading-overlay').show();
		}
	}
	
	// Function to hide loading overlay
	function hideLoadingOverlay() {
		$('#loading-overlay').hide();
	}

	// Function to clear the canvas
	function clearCanvas() {
		// Clear the PaperJS project
		paper.project.activeLayer.removeChildren();
		
		// Clear any active drawing states
		isDrawing = false;
		currentPath = [];
		allPaths = [];
		globals.path = null;
		globals.undos = [];
		globals.redos = [];
		
		// Reset any active tools
		currentTool = null;
		$(".tool-buttons button").removeClass("active");
	}

	// Add measurement tool functionality
	function initializeMeasurementTool() {
		const measureTool = new paper.Tool();
		
		measureTool.onMouseDown = function(event) {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			
			if (!globals.isMeasuring) {
				// Start measuring
				globals.isMeasuring = true;
				globals.measureStartPoint = event.point;
				
				// Create measurement line with blueprint style
				globals.measurementPath = new paper.Path.Line(event.point, event.point);
				globals.measurementPath.strokeColor = globals.blueprintStyle.measureLine.color;
				globals.measurementPath.strokeWidth = globals.blueprintStyle.measureLine.width;
				globals.measurementPath.dashArray = globals.blueprintStyle.measureLine.dashArray;
				
				// Add a dot at the start point
				const startDot = createEndpointMarker(event.point, globals.blueprintStyle.dimension.endpointStyle);
				
				// Create measurement text with blueprint style
				globals.measurementText = new paper.PointText({
					point: event.point.add(new paper.Point(10, 10)),
					content: "0px",
					fillColor: globals.blueprintStyle.measureText.color,
					fontSize: globals.blueprintStyle.measureText.fontSize,
					fontFamily: globals.blueprintStyle.measureText.fontFamily,
					fontWeight: globals.blueprintStyle.measureText.fontWeight
				});
				
				// Create background rectangle for the text
				const textBackground = new paper.Path.Rectangle({
					rectangle: globals.measurementText.bounds.expand(5),
					fillColor: globals.blueprintStyle.measureText.backgroundColor,
					strokeColor: globals.blueprintStyle.measureLine.color,
					strokeWidth: 1
				});
				
				// Ensure background is behind text
				textBackground.sendToBack();
				
				// Group the text and background for easier manipulation
				globals.tempGroup = new paper.Group([textBackground, globals.measurementText, startDot]);
				
				// Show measurement info
				$('#measurementInfo').show().css({
					left: event.point.x + 10,
					top: event.point.y + 10
				});
			} else {
				// Finish measuring and save the measurement
				globals.isMeasuring = false;
				
				// Convert final measurement to a permanent object
				if (globals.measurementPath && globals.tempGroup) {
					// Get the measurement path data for storage
					const startPoint = globals.measurementPath.segments[0].point;
					const endPoint = globals.measurementPath.segments[1].point;
					
					// Calculate distance
					const dx = endPoint.x - startPoint.x;
					const dy = endPoint.y - startPoint.y;
					const pixelDistance = Math.sqrt(dx * dx + dy * dy);
					
					// Get the real-world distances if grid metrics exist
					let metricDistance = null;
					let imperialDistance = null;
					
					if (globals.gridMetrics && globals.gridMetrics.realWorldScale) {
						// Get pixels per meter from grid metrics
						const pixelsPerMeter = globals.gridMetrics.cellWidth / globals.gridMetrics.realWorldScale.width;
						
						// Convert pixel distance to meters
						metricDistance = pixelDistance / pixelsPerMeter;
						
						// Convert meters to imperial (feet and inches)
						imperialDistance = metricDistance * 3.28084; // 1 meter = 3.28084 feet
					}
					
					// Format measurements in a more professional way
					let labelText = formatMeasurementText(pixelDistance, metricDistance, imperialDistance);
					
					// Create dimension line with arrows for architectural style
					const dimensionGroup = createArchitecturalDimension(startPoint, endPoint, labelText);
					
					// Add metadata for undo functionality
					dimensionGroup.data = {
						type: 'measurement',
						pixelDistance: pixelDistance,
						metricDistance: metricDistance,
						imperialDistance: imperialDistance,
						startPoint: startPoint,
						endPoint: endPoint,
						createdAt: new Date().getTime()
					};
					
					// Add to undo stack
					addToUndoStack(dimensionGroup);
					
					// Add to saved measurements array
					globals.savedMeasurements.push(dimensionGroup);
					
					// Show success message
					showSuccessMessage("Measurement saved");
				}
				
				// Clean up temporary elements
				if (globals.measurementPath) {
					globals.measurementPath.remove();
					globals.measurementPath = null;
				}
				
				if (globals.tempGroup) {
					globals.tempGroup.remove();
					globals.tempGroup = null;
				}
				
				$('#measurementInfo').hide();
				$('#measure-distance').text('Distance: 0px');
			}
		};
		
		measureTool.onMouseMove = function(event) {
			// Update pixel coordinates display
			const x = Math.round(event.point.x);
			const y = Math.round(event.point.y);
			$('#pixel-coords').text(`Pixels: ${x},${y}`);
			
			// Update measurement if measuring
			if (globals.isMeasuring && globals.measureStartPoint) {
				// Update line
				globals.measurementPath.segments[1].point = event.point;
				
				// Calculate distance
				const dx = event.point.x - globals.measureStartPoint.x;
				const dy = event.point.y - globals.measureStartPoint.y;
				const pixelDistance = Math.sqrt(dx * dx + dy * dy);
				const rounded = Math.round(pixelDistance * 100) / 100;
				
				// Get the real-world distances if grid metrics exist
				let metricDistance = null;
				let imperialDistance = null;
				
				if (globals.gridMetrics && globals.gridMetrics.realWorldScale) {
					// Get pixels per meter from grid metrics
					const pixelsPerMeter = globals.gridMetrics.cellWidth / globals.gridMetrics.realWorldScale.width;
					
					// Convert pixel distance to meters
					metricDistance = pixelDistance / pixelsPerMeter;
					
					// Convert meters to imperial (feet and inches)
					imperialDistance = metricDistance * 3.28084; // 1 meter = 3.28084 feet
					
					// Format for display in status bar
					const metricText = formatMetricText(metricDistance);
					const imperialText = formatImperialText(imperialDistance);
					
					// Update footer display
					$('#measure-distance').text(`Distance: ${rounded}px | ${metricText} | ${imperialText}`);
					
					// Update the display text for the measurement label
					if (globals.measurementText) {
						globals.measurementText.content = formatMeasurementText(rounded, metricDistance, imperialDistance);
						
						// Update the background rectangle
						if (globals.tempGroup && globals.tempGroup.children.length > 1) {
							const background = globals.tempGroup.children[0];
							background.remove();
							
							// Create new background
							const newBackground = new paper.Path.Rectangle({
								rectangle: globals.measurementText.bounds.expand(5),
								fillColor: globals.blueprintStyle.measureText.backgroundColor,
								strokeColor: globals.blueprintStyle.measureLine.color,
								strokeWidth: 1
							});
							
							// Add back to group and send to back
							globals.tempGroup.insertChild(0, newBackground);
						}
						
						// Position the text at the midpoint of the line
						const midpoint = globals.measureStartPoint.add(event.point).divide(2);
						globals.tempGroup.position = midpoint.add(new paper.Point(0, -15));
					}
					
					// Update measurement info tooltip
					let infoText = `Start: ${Math.round(globals.measureStartPoint.x)},${Math.round(globals.measureStartPoint.y)} | End: ${x},${y} | ${metricText} | ${imperialText}`;
					
					$('#measurementInfo').text(infoText);
				} else {
					// Just show pixels if no grid metrics
					$('#measure-distance').text(`Distance: ${rounded}px`);
					
					if (globals.measurementText) {
						globals.measurementText.content = `${rounded}px`;
						
						// Update the background rectangle
						if (globals.tempGroup && globals.tempGroup.children.length > 1) {
							const background = globals.tempGroup.children[0];
							background.remove();
							
							// Create new background
							const newBackground = new paper.Path.Rectangle({
								rectangle: globals.measurementText.bounds.expand(5),
								fillColor: globals.blueprintStyle.measureText.backgroundColor, 
								strokeColor: globals.blueprintStyle.measureLine.color,
								strokeWidth: 1
							});
							
							// Add back to group and send to back
							globals.tempGroup.insertChild(0, newBackground);
						}
						
						// Position the text at the midpoint of the line
						const midpoint = globals.measureStartPoint.add(event.point).divide(2);
						globals.tempGroup.position = midpoint.add(new paper.Point(0, -15));
					}
					
					// Update measurement info tooltip
					$('#measurementInfo').text(`Start: ${Math.round(globals.measureStartPoint.x)},${Math.round(globals.measureStartPoint.y)} | End: ${x},${y} | Distance: ${rounded}px`);
				}
				
				// Position the info box
				$('#measurementInfo').css({
					left: event.point.x + 10,
					top: event.point.y + 10
				});
			}
		};
		
		measureTool.onKeyDown = function(event) {
			// Cancel measurement on Escape key
			if (event.key === 'escape' && globals.isMeasuring) {
				globals.isMeasuring = false;
				
				// Clean up temporary elements
				if (globals.measurementPath) {
					globals.measurementPath.remove();
					globals.measurementPath = null;
				}
				
				if (globals.tempGroup) {
					globals.tempGroup.remove();
					globals.tempGroup = null;
				}
				
				$('#measurementInfo').hide();
				$('#measure-distance').text('Distance: 0px');
			}
		};
		
		return measureTool;
	}

	// Helper function to format metric text
	function formatMetricText(metricDistance) {
		if (metricDistance === null) return "";
		
		if (metricDistance < 0.01) {
			// Show in mm if very small
			return `${Math.round(metricDistance * 1000)}mm`;
		} else if (metricDistance < 1) {
			// Show in cm if less than 1 meter
			return `${Math.round(metricDistance * 100)}cm`;
		} else {
			// Show in meters with appropriate precision
			return `${metricDistance.toFixed(2)}m`;
		}
	}

	// Helper function to format imperial text with feet and inches
	function formatImperialText(feet) {
		if (feet === null) return "";
		
		const wholeFeet = Math.floor(feet);
		const inches = Math.round((feet - wholeFeet) * 12);
		
		if (inches === 12) {
			// Handle case where inches rounds up to 12
			return `${wholeFeet + 1}'0"`;
		} else if (wholeFeet === 0) {
			// Just show inches if less than a foot
			return `${inches}"`;
		} else {
			return `${wholeFeet}'${inches}"`;
		}
	}
	
	// Helper function to format the complete measurement text
	function formatMeasurementText(pixelDistance, metricDistance, imperialDistance) {
		let text = "";
		
		// Always include pixel measurement
		text += `${Math.round(pixelDistance)}px`;
		
		// Add metric and imperial if available
		if (metricDistance !== null) {
			text += ` | ${formatMetricText(metricDistance)}`;
		}
		
		if (imperialDistance !== null) {
			text += ` | ${formatImperialText(imperialDistance)}`;
		}
		
		return text;
	}
	
	// Function to create architectural dimension with arrows and extension lines
	function createArchitecturalDimension(startPoint, endPoint, labelText) {
		const dimensionGroup = new paper.Group();
		
		// Calculate vector properties
		const vector = endPoint.subtract(startPoint);
		const length = vector.length;
		const direction = vector.normalize();
		const perpendicular = new paper.Point(-direction.y, direction.x);
		
		// Create offset for extension lines (perpendicular to measurement line)
		const extensionOffset = perpendicular.multiply(10);
		const textOffset = perpendicular.multiply(18);
		
		// Calculate extension line endpoints
		const extensionStart1 = startPoint.subtract(extensionOffset.multiply(0.5));
		const extensionEnd1 = startPoint.add(extensionOffset);
		
		const extensionStart2 = endPoint.subtract(extensionOffset.multiply(0.5));
		const extensionEnd2 = endPoint.add(extensionOffset);
		
		// Create extension lines
		const extensionLine1 = new paper.Path.Line(extensionStart1, extensionEnd1);
		const extensionLine2 = new paper.Path.Line(extensionStart2, extensionEnd2);
		
		extensionLine1.strokeColor = globals.blueprintStyle.dimension.lineColor;
		extensionLine1.strokeWidth = 1;
		
		extensionLine2.strokeColor = globals.blueprintStyle.dimension.lineColor;
		extensionLine2.strokeWidth = 1;
		
		// Create dimension line with arrow heads
		const arrowSize = globals.blueprintStyle.dimension.arrowSize;
		
		// Calculate dimension line offset
		const dimensionStart = startPoint.add(extensionOffset);
		const dimensionEnd = endPoint.add(extensionOffset);
		
		// Create main dimension line
		const dimensionLine = new paper.Path.Line(dimensionStart, dimensionEnd);
		dimensionLine.strokeColor = globals.blueprintStyle.dimension.lineColor;
		dimensionLine.strokeWidth = globals.blueprintStyle.measureLine.width;
		dimensionLine.dashArray = globals.blueprintStyle.measureLine.dashArray;
		
		// Create arrow heads
		const arrowHead1 = createArrowHead(dimensionStart, direction, arrowSize);
		const arrowHead2 = createArrowHead(dimensionEnd, direction.multiply(-1), arrowSize);
		
		arrowHead1.fillColor = globals.blueprintStyle.dimension.lineColor;
		arrowHead2.fillColor = globals.blueprintStyle.dimension.lineColor;
		
		// Add endpoint markers to the actual measured points (not the dimension line)
		const startMarker = createEndpointMarker(startPoint, globals.blueprintStyle.dimension.endpointStyle);
		const endMarker = createEndpointMarker(endPoint, globals.blueprintStyle.dimension.endpointStyle);
		
		// Create text for measurement
		const textPoint = startPoint.add(vector.divide(2)).add(textOffset);
		
		const dimensionText = new paper.PointText({
			point: textPoint,
			content: labelText,
			fillColor: globals.blueprintStyle.dimension.textColor,
			fontSize: globals.blueprintStyle.measureText.fontSize,
			fontFamily: globals.blueprintStyle.measureText.fontFamily,
			fontWeight: globals.blueprintStyle.measureText.fontWeight,
			justification: 'center'
		});
		
		// Add background for text
		const textBackground = new paper.Path.Rectangle({
			rectangle: dimensionText.bounds.expand(5),
			fillColor: globals.blueprintStyle.measureText.backgroundColor,
			strokeColor: globals.blueprintStyle.dimension.lineColor,
			strokeWidth: 1
		});
		
		textBackground.sendToBack();
		
		// Create direct measure line (actual measured distance)
		const directLine = new paper.Path.Line(startPoint, endPoint);
		directLine.strokeColor = globals.blueprintStyle.dimension.lineColor;
		directLine.strokeWidth = globals.blueprintStyle.measureLine.width * 0.7;
		directLine.dashArray = globals.blueprintStyle.measureLine.dashArray;
		directLine.opacity = 0.6;
		
		// Add all elements to the group
		dimensionGroup.addChild(directLine);
		dimensionGroup.addChild(extensionLine1);
		dimensionGroup.addChild(extensionLine2);
		dimensionGroup.addChild(dimensionLine);
		dimensionGroup.addChild(arrowHead1);
		dimensionGroup.addChild(arrowHead2);
		dimensionGroup.addChild(startMarker);
		dimensionGroup.addChild(endMarker);
		dimensionGroup.addChild(textBackground);
		dimensionGroup.addChild(dimensionText);
		
		return dimensionGroup;
	}
	
	// Helper function to create endpoint markers (crosshairs or dots)
	function createEndpointMarker(point, style) {
		const radius = globals.blueprintStyle.dimension.endpointRadius;
		const color = globals.blueprintStyle.dimension.lineColor;
		
		if (style === 'dot') {
			// Create a dot
			const dot = new paper.Path.Circle({
				center: point,
				radius: radius,
				fillColor: color
			});
			return dot;
		} else {
			// Create a crosshair
			const crosshair = new paper.Group();
			
			// Horizontal line
			const hLine = new paper.Path.Line(
				point.subtract(new paper.Point(radius, 0)),
				point.add(new paper.Point(radius, 0))
			);
			hLine.strokeColor = color;
			hLine.strokeWidth = 1.5;
			
			// Vertical line
			const vLine = new paper.Path.Line(
				point.subtract(new paper.Point(0, radius)),
				point.add(new paper.Point(0, radius))
			);
			vLine.strokeColor = color;
			vLine.strokeWidth = 1.5;
			
			// Add a small circle in the center
			const centerDot = new paper.Path.Circle({
				center: point,
				radius: radius / 3,
				fillColor: color
			});
			
			crosshair.addChild(hLine);
			crosshair.addChild(vLine);
			crosshair.addChild(centerDot);
			
			return crosshair;
		}
	}
	
	// Helper function to create arrow head
	function createArrowHead(point, direction, size) {
		const perpendicular = new paper.Point(-direction.y, direction.x);
		
		const tip = point.add(direction.multiply(size));
		const side1 = point.add(perpendicular.multiply(size/2));
		const side2 = point.subtract(perpendicular.multiply(size/2));
		
		const arrowHead = new paper.Path({
			segments: [tip, side1, side2],
			closed: true
		});
		
		return arrowHead;
	}

	// Function to add a shape to the undo history
	function addToUndoStack(path) {
		if (path) {
			// Store the drawn item in the undo stack
			globals.undos.push(path);
			
			// Clear redos when a new action is performed
			globals.redos = [];
		}
	}

	// Function to implement undo
	function undoLastOperation() {
		if (globals.undos.length > 0) {
			// Get the last drawn item
			const lastItem = globals.undos.pop();
			
			// Add to redos stack before removing
			if (lastItem) {
				// Clone the item if you want to implement redo
				globals.redos.push(lastItem);
				
				// Remove from canvas
				lastItem.remove();
			}
			
			// Redraw to ensure canvas is updated
			paper.view.update();
		}
	}

	// Function to finalize a shape with proper styling based on category
	function finalizeShape(path) {
		if (!path) return null;
		
		// Apply the current category color
		path.strokeColor = currentColor;
		path.strokeWidth = 2;
		
		// Apply a light yellow semi-transparent fill regardless of stroke color
		path.fillColor = globals.blueprintStyle.shapes.fillColor;
		
		// Add metadata to the path for category
		path.data = {
			category: currentCategory,
			color: currentColor,
			createdAt: new Date().getTime()
		};
		
		// Add to undo stack
		addToUndoStack(path);
		
		// Return the finalized path
		return path;
	}

	// Utility function to convert screen coordinates to paper coordinates
	function getAdjustedPoint(event) {
		// Get the canvas element
		const canvas = document.getElementById('canvas');
		
		// Get the canvas rect relative to the viewport
		const rect = canvas.getBoundingClientRect();
		
		// Calculate the scale factor between actual canvas size and its display size
		const scaleX = canvas.width / rect.width;
		const scaleY = canvas.height / rect.height;
		
		// Get the mouse position relative to the canvas element
		const clientX = event.clientX || (event.originalEvent && event.originalEvent.clientX) || 0;
		const clientY = event.clientY || (event.originalEvent && event.originalEvent.clientY) || 0;
		
		// Calculate position within the element
		const x = (clientX - rect.left) * scaleX;
		const y = (clientY - rect.top) * scaleY;
		
		// Convert to paper points
		return paper.view.viewToProject(new paper.Point(x, y));
	}

	// Improved cleanup function to properly handle active paths and states
	function cleanupActivePath() {
		// Cancel any active drawing
		if (globals.path) {
			globals.path.remove();
			globals.path = null;
		}
		
		// Reset drawing flags
		globals.isDrawing = false;
		globals.startPoint = null;
		globals.centerPoint = null;
		globals.isMeasuring = false;
		globals.measureStartPoint = null;
		
		// Remove any temporary drawing elements
		if (globals.tempGroup) {
			globals.tempGroup.remove();
			globals.tempGroup = null;
		}
		
		// Update the view to ensure changes are reflected
		paper.view.update();
	}

	// Add event listeners for UI
	$(document).ready(function() {
		// Initialize PaperJS
		paper.setup('canvas');
		
		// Initialize view center and zoom
		globals.initialCenter = paper.view.center.clone();

		// Enable mousewheel zooming and drag panning
		initializeViewControls();
		
		// Global variable to track image load status
		let imageLoadAttempted = false;

		// Initialize tools
		const penTool = new paper.Tool();
		penTool.onMouseDown = function(event) {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			// Check if we have a selected category
			if (!currentCategory) {
				showWarningMessage("Please select a category first");
				return;
			}
			
			globals.path = new paper.Path();
			globals.path.strokeColor = currentColor;
			globals.path.strokeWidth = 2;
			// Use the actual point from the event
			globals.path.add(event.point);
		};
		penTool.onMouseDrag = function(event) {
			if (globals.path) {
				// Use the actual point from the event
				globals.path.add(event.point);
			}
		};
		penTool.onMouseUp = function(event) {
			if (globals.path) {
				// Close the path for a clean shape
					globals.path.simplify(10);
					
					// Finalize the shape
					finalizeShape(globals.path);
					
					// Reset the path
					globals.path = null;
			}
		};
		
		const polygonTool = new paper.Tool();
		polygonTool.onMouseDown = function(event) {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			// Check if we have a selected category
			if (!currentCategory) {
				showWarningMessage("Please select a category first");
				return;
			}
			
			// On first click, create a new path
			if (!globals.path) {
				globals.path = new paper.Path();
				globals.path.strokeColor = currentColor;
				globals.path.strokeWidth = 2;
				globals.path.add(event.point);
				
				// Add helper text
				showWarningMessage("Click to add points, press ESC to complete shape", 3000);
			} else {
				// On subsequent clicks, add points to the path
				globals.path.add(event.point);
			}
		};
		polygonTool.onKeyDown = function(event) {
			if (event.key === 'escape' && globals.path) {
				// Close the path to create a polygon
				if (globals.path.segments.length >= 3) {
					globals.path.closed = true;
					
					// Finalize the shape
					finalizeShape(globals.path);
					
					// Reset the path
					globals.path = null;
				} else {
					// Need at least 3 points for a polygon
					showWarningMessage("Need at least 3 points for a polygon");
				}
			}
		};
		
		const rectangleTool = new paper.Tool();
		rectangleTool.onMouseDown = function(event) {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			// Check if we have a selected category
			if (!currentCategory) {
				showWarningMessage("Please select a category first");
				return;
			}
			
			// Store the start point for rectangle creation
			globals.startPoint = event.point.clone();
			
			// Create initial rectangle
			globals.path = new paper.Path.Rectangle({
				from: globals.startPoint,
				to: event.point,
				strokeColor: currentColor,
				strokeWidth: 2
			});
		};
		rectangleTool.onMouseDrag = function(event) {
			if (globals.path && globals.startPoint) {
				// Instead of removing and recreating, just adjust the existing rectangle
				try {
					// Remove the existing path
					globals.path.remove();
					
					// Create a new rectangle from the stored start point
					globals.path = new paper.Path.Rectangle({
						from: globals.startPoint,
						to: event.point,
						strokeColor: currentColor,
						strokeWidth: 2
					});
				} catch (e) {
					console.error('Error updating rectangle:', e);
					// If there was an error, create a new rectangle
					globals.path = new paper.Path.Rectangle({
						from: globals.startPoint,
						to: event.point,
						strokeColor: currentColor,
						strokeWidth: 2
					});
				}
				
				// Ensure the view is updated
				paper.view.update();
			}
		};
		rectangleTool.onMouseUp = function(event) {
			if (globals.path) {
				// Ensure the rectangle has a minimum size
				if (Math.abs(event.point.x - globals.startPoint.x) < 5 &&
					Math.abs(event.point.y - globals.startPoint.y) < 5) {
					// Rectangle is too small, make it a minimum size
					globals.path.remove();
					globals.path = new paper.Path.Rectangle({
						from: globals.startPoint,
						to: new paper.Point(
							globals.startPoint.x + 10, 
							globals.startPoint.y + 10
						),
						strokeColor: currentColor,
						strokeWidth: 2
					});
				}
				
				// Finalize the shape
				finalizeShape(globals.path);
				
				// Reset the path and start point
				globals.path = null;
				globals.startPoint = null;
			}
		};
		
		const circleTool = new paper.Tool();
		circleTool.onMouseDown = function(event) {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			// Check if we have a selected category
			if (!currentCategory) {
				showWarningMessage("Please select a category first");
				return;
			}
			
			// Store the center point for circle creation
			globals.centerPoint = event.point.clone();
			
			// Create initial circle
			globals.path = new paper.Path.Circle({
				center: globals.centerPoint,
				radius: 1,
				strokeColor: currentColor,
				strokeWidth: 2
			});
		};
		circleTool.onMouseDrag = function(event) {
			if (globals.path && globals.centerPoint) {
				// Calculate radius based on distance from center
				const radius = event.point.getDistance(globals.centerPoint);
				
				try {
					// Remove the existing path
					globals.path.remove();
					
					// Create a new circle with updated radius
					globals.path = new paper.Path.Circle({
						center: globals.centerPoint,
						radius: radius,
						strokeColor: currentColor,
						strokeWidth: 2
					});
				} catch (e) {
					console.error('Error updating circle:', e);
					// If there was an error, create a new circle
					globals.path = new paper.Path.Circle({
						center: globals.centerPoint,
						radius: radius,
						strokeColor: currentColor,
						strokeWidth: 2
					});
				}
				
				// Ensure the view is updated
				paper.view.update();
			}
		};
		circleTool.onMouseUp = function(event) {
			if (globals.path) {
				// Ensure the circle has a minimum size
				const radius = event.point.getDistance(globals.centerPoint);
				if (radius < 5) {
					// Circle is too small, make it a minimum size
					globals.path.remove();
					globals.path = new paper.Path.Circle({
						center: globals.centerPoint,
						radius: 5,
						strokeColor: currentColor,
						strokeWidth: 2
					});
				}
				
				// Finalize the shape
				finalizeShape(globals.path);
				
				// Reset the path and center point
				globals.path = null;
				globals.centerPoint = null;
			}
		};
		
		const measureTool = initializeMeasurementTool();
		
		const removeTool = new paper.Tool();
		removeTool.onMouseDown = function(event) {
			const hitResult = paper.project.hitTest(event.point);
			if (hitResult && hitResult.item) {
				// Store the removed item in undo stack before removing
				addToUndoStack(hitResult.item);
				
				// Remove the item
				hitResult.item.remove();
			}
		};
		
		// Tool button listeners
		$('#pen_button').click(function() {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			cleanupActivePath();
			penTool.activate();
			updateActiveToolButton(this);
			globals.currentTool = 'pen';
		});
		
		$('#polygon_button').click(function() {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			cleanupActivePath();
			polygonTool.activate();
			updateActiveToolButton(this);
			globals.currentTool = 'polygon';
		});
		
		$('#rectangle_button').click(function() {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			cleanupActivePath();
			rectangleTool.activate();
			updateActiveToolButton(this);
			globals.currentTool = 'rectangle';
		});
		
		$('#circle_button').click(function() {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			cleanupActivePath();
			circleTool.activate();
			updateActiveToolButton(this);
			globals.currentTool = 'circle';
		});
		
		$('#measure_button').click(function() {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			cleanupActivePath();
			measureTool.activate();
			updateActiveToolButton(this);
			globals.currentTool = 'measure';
		});
		
		$('#remove_button').click(function() {
			if (!globals.imageLoaded) {
				showWarningMessage("Please wait for image to fully load before using tools");
				return;
			}
			cleanupActivePath();
			removeTool.activate();
			updateActiveToolButton(this);
			globals.currentTool = 'remove';
		});
		
		// Add pan tool button
		$('#zoom-in, #zoom-out, #zoom-fit, #zoom-reset').click(function() {
			// Activate the view tool for panning
			if (globals.viewTool) {
				globals.viewTool.activate();
				updateActiveToolButton(null);  // Deselect all tool buttons
				globals.currentTool = 'view';
			}
		});
		
		// Add key handler for tool switching
		$(document).keydown(function(e) {
			// Spacebar for pan tool
			if (e.keyCode === 32) { // Spacebar
				if (globals.viewTool) {
					globals.viewTool.activate();
					updateActiveToolButton(null);
					globals.currentTool = 'view';
					$('#canvas').css('cursor', 'grab');
					e.preventDefault();
				}
			}
		});
		
		$(document).keyup(function(e) {
			// Return to previous tool when spacebar is released
			if (e.keyCode === 32) { // Spacebar
				$('#canvas').css('cursor', 'default');
				// If we know what the previous tool was, return to it
				if (globals.previousTool) {
					globals.currentTool = globals.previousTool;
					if (globals.currentTool === 'pen') {
						penTool.activate();
						updateActiveToolButton($('#pen_button')[0]);
					} else if (globals.currentTool === 'polygon') {
						polygonTool.activate();
						updateActiveToolButton($('#polygon_button')[0]);
					} else if (globals.currentTool === 'rectangle') {
						rectangleTool.activate();
						updateActiveToolButton($('#rectangle_button')[0]);
					} else if (globals.currentTool === 'circle') {
						circleTool.activate();
						updateActiveToolButton($('#circle_button')[0]);
					} else if (globals.currentTool === 'measure') {
						measureTool.activate();
						updateActiveToolButton($('#measure_button')[0]);
					} else if (globals.currentTool === 'remove') {
						removeTool.activate();
						updateActiveToolButton($('#remove_button')[0]);
					}
				}
			}
		});
		
		// Add undo button functionality
		$('#undo_button').click(function() {
			undoLastOperation();
		});
		
		// Navigation buttons
		$('#prev_button').click(function() {
			loadImage('prev');
		});
		
		$('#next_button').click(function() {
			loadImage('next');
		});
		
		// Screenshot button click handler
		$('#screenshot_button').click(function() {
			takeScreenshot();
		});
		
		// Function to take a screenshot
		function takeScreenshot() {
			try {
				// Create a temporary canvas to draw the scene
				const tempCanvas = document.createElement('canvas');
				tempCanvas.width = paper.view.viewSize.width;
				tempCanvas.height = paper.view.viewSize.height;
				const tempCtx = tempCanvas.getContext('2d');
				
				// Draw background (white)
				tempCtx.fillStyle = 'white';
				tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
				
				// Get the canvas element that PaperJS is using
				const canvas = document.getElementById('canvas');
				
				// Draw the PaperJS canvas to our temporary canvas
				tempCtx.drawImage(canvas, 0, 0);
				
				// Create image 
				const dataUrl = tempCanvas.toDataURL('image/png');
				
				// Create a link and trigger download
				const link = document.createElement('a');
				link.download = `${currentImage ? currentImage.name : 'screenshot'}_${new Date().getTime()}.png`;
				link.href = dataUrl;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				
				showSuccessMessage('Screenshot saved');
			} catch (e) {
				console.error('Error taking screenshot:', e);
				showErrorMessage('Error taking screenshot: ' + e.message);
			}
		}
		
		// Function to save labels
		function saveLabels() {
			try {
				// Check if there are any objects to save
				let hasPathsToSave = false;
				paper.project.activeLayer.children.forEach(function(child) {
					if (child !== globals.raster && child !== globals.measurementPath) {
						if (child.data && child.data.category) {
							hasPathsToSave = true;
						}
					}
				});
				
				if (!hasPathsToSave) {
					showWarningMessage("No annotations to save. Create some annotations first.");
					return;
				}
				
				// Collect all drawn shapes into a GeoJSON-like structure
				const features = [];
				const measurements = [];
				
				paper.project.activeLayer.children.forEach(function(child) {
					// Skip the image and measurement path that's currently being drawn
					if (child === globals.raster || child === globals.measurementPath) {
						return;
					}
					
					// Handle measurements
					if (child.data && child.data.type === 'measurement') {
						// Create a measurement feature
						const measurement = {
							type: 'measurement',
							pixelDistance: child.data.pixelDistance,
							metricDistance: child.data.metricDistance,
							imperialDistance: child.data.imperialDistance,
							startPoint: [child.data.startPoint.x, child.data.startPoint.y],
							endPoint: [child.data.endPoint.x, child.data.endPoint.y],
							createdAt: child.data.createdAt
						};
						
						measurements.push(measurement);
						return;
					}
					
					// Skip items without category data
					if (!child.data || !child.data.category) {
						return;
					}
					
					try {
						// Create a feature for the path
						const feature = {
							type: 'Feature',
							geometry: {
								type: getGeometryType(child),
								coordinates: getCoordinates(child)
							},
							properties: {
								category: child.data.category,
								color: child.data.color,
								createdAt: child.data.createdAt || new Date().getTime()
							}
						};
						
						features.push(feature);
					} catch (e) {
						console.error("Error processing shape:", e, child);
						showWarningMessage("Some shapes couldn't be saved due to errors. See console for details.");
					}
				});
				
				// Create a GeoJSON structure
				const geojson = {
					type: 'FeatureCollection',
					features: features,
					measurements: measurements,
					metadata: {
						image: currentImage ? currentImage.name : null,
						imageWidth: paper.view.viewSize.width,
						imageHeight: paper.view.viewSize.height,
						timestamp: new Date().toISOString(),
						timeTaken: Math.round((new Date().getTime() - globals.sessionStartTime) / 1000)
					}
				};
				
				// Include grid metrics if available
				if (globals.gridMetrics) {
					geojson.metadata.gridMetrics = globals.gridMetrics;
				}
				
				// Show loading overlay
				showLoadingOverlay();
				
				// Send to server
				$.ajax({
					url: "{% url 'save_labels' %}",
					type: "POST",
					contentType: 'application/json',
					data: JSON.stringify(geojson),
					success: function(response) {
						hideLoadingOverlay();
						showSuccessMessage("Labels saved successfully");
					},
					error: function(xhr, status, error) {
						hideLoadingOverlay();
						showErrorMessage("Error saving labels: " + error);
						console.error("Save error details:", xhr.responseText);
					}
				});
			} catch (e) {
				hideLoadingOverlay();
				console.error("Error preparing labels:", e);
				showErrorMessage("Error preparing labels: " + e.message);
			}
		}
		
		// Helper functions for GeoJSON conversion
		function getGeometryType(path) {
			if (path instanceof paper.Path.Circle) {
				return 'Point';
			} else if (path.closed) {
				return 'Polygon';
			} else {
				return 'LineString';
			}
		}
		
		function getCoordinates(path) {
			try {
				if (path instanceof paper.Path.Circle) {
					// For circles, use center and radius
					return [path.position.x, path.position.y, path.bounds.width / 2];
				} else if (path instanceof paper.Path.Rectangle) {
					// For rectangles, get the four corners
					const topLeft = [path.bounds.topLeft.x, path.bounds.topLeft.y];
					const topRight = [path.bounds.topRight.x, path.bounds.topRight.y];
					const bottomRight = [path.bounds.bottomRight.x, path.bounds.bottomRight.y];
					const bottomLeft = [path.bounds.bottomLeft.x, path.bounds.bottomLeft.y];
					return [[topLeft, topRight, bottomRight, bottomLeft, topLeft]]; // Close the polygon
				} else if (path.closed && path.segments) {
					// For polygons, return array of point arrays including closure
					const coords = [];
					path.segments.forEach(function(segment) {
						coords.push([segment.point.x, segment.point.y]);
					});
					// Close the ring by adding the first point again
					if (coords.length > 0) {
						coords.push([path.segments[0].point.x, path.segments[0].point.y]);
					}
					return [coords]; // GeoJSON polygons require an extra array level
				} else if (path.segments) {
					// For lines, return array of point arrays
					const coords = [];
					path.segments.forEach(function(segment) {
						coords.push([segment.point.x, segment.point.y]);
					});
					return coords;
				} else if (path.children) {
					// For groups (like compound paths), get the first child's coordinates
					for (let i = 0; i < path.children.length; i++) {
						const child = path.children[i];
						if (child.segments) {
							return getCoordinates(child);
						}
					}
					// If no valid children with segments, fall back to bounds
					return getCoordinatesFromBounds(path);
				} else {
					// Fallback for other types - use bounding box
					return getCoordinatesFromBounds(path);
				}
			} catch (e) {
				console.error("Error getting coordinates:", e, path);
				// Provide a fallback
				return getCoordinatesFromBounds(path);
			}
		}
		
		// Fallback method to get coordinates from bounds
		function getCoordinatesFromBounds(path) {
			try {
				const bounds = path.bounds;
				const topLeft = [bounds.topLeft.x, bounds.topLeft.y];
				const topRight = [bounds.topRight.x, bounds.topRight.y];
				const bottomRight = [bounds.bottomRight.x, bounds.bottomRight.y];
				const bottomLeft = [bounds.bottomLeft.x, bounds.bottomLeft.y];
				return [[topLeft, topRight, bottomRight, bottomLeft, topLeft]]; // Close the polygon
			} catch (e) {
				console.error("Error getting bounds coordinates:", e);
				// Ultimate fallback - return empty array
				return [[0, 0]];
			}
		}
		
		// Helper function to update active button
		function updateActiveToolButton(button) {
			// Store the previous tool before switching
			if (globals.currentTool && globals.currentTool !== 'view') {
				globals.previousTool = globals.currentTool;
			}
			
			// Update the button states
			$('.tool-buttons button').removeClass('active');
			if (button) {
				$(button).addClass('active');
			}
		}
		
		// Function to load image from server
		function loadImage(direction) {
			showLoadingOverlay("Loading image...");
			
			$.ajax({
				url: "{% url 'get_new_image' %}",
				type: "GET",
				data: { direction: direction },
				success: function(data) {
					if (data.success) {
						displayImage(
							data.image_name,
							data.image_path,
							data.categories,
							data.shapes,
							data.colors,
							{ x: 0, y: 0 },
							data.width,
							data.height,
							0,
							data.existing_labels // Pass the existing labels to displayImage
						);
						
						// Update navigation button states
						updateNavigationButtons(data.navigation);
						
						// Update the full image URL display
						$("#full-image-url").text("Image URL: " + data.image_path);
						
						hideLoadingOverlay();
						showSuccessMessage("Image loaded successfully");
					} else {
						hideLoadingOverlay();
						// Show error message without falling back to sample images
						showErrorMessage(data.message || "No images available from server. Please add images to the database.");
						
						// Draw error message on canvas
						const canvas = document.getElementById('canvas');
						if (canvas) {
							const ctx = canvas.getContext('2d');
							canvas.width = 800;  // Default size
							canvas.height = 600;
							ctx.fillStyle = "#f8d7da";
							ctx.fillRect(0, 0, canvas.width, canvas.height);
							ctx.font = "16px Arial";
							ctx.fillStyle = "#721c24";
							ctx.textAlign = "center";
							ctx.fillText("No Images Available", canvas.width/2, canvas.height/2 - 20);
							ctx.font = "14px Arial";
							ctx.fillText("Please add images to the database", canvas.width/2, canvas.height/2 + 20);
						}
					}
				},
				error: function(xhr, status, error) {
					console.error("Error loading image:", error);
					hideLoadingOverlay();
					showErrorMessage("Server error: " + error);
					
					// Draw error message on canvas
					const canvas = document.getElementById('canvas');
					if (canvas) {
						const ctx = canvas.getContext('2d');
						canvas.width = 800;  // Default size
						canvas.height = 600;
						ctx.fillStyle = "#f8d7da";
						ctx.fillRect(0, 0, canvas.width, canvas.height);
						ctx.font = "16px Arial";
						ctx.fillStyle = "#721c24";
						ctx.textAlign = "center";
						ctx.fillText("Server Error", canvas.width/2, canvas.height/2 - 20);
						ctx.font = "14px Arial";
						ctx.fillText("Could not connect to server: " + error, canvas.width/2, canvas.height/2 + 20);
					}
				}
			});
		}
		
		// Function to update navigation button states
		function updateNavigationButtons(navigation) {
			if (navigation) {
				$("#prev_button").prop("disabled", !navigation.has_prev);
				$("#next_button").prop("disabled", !navigation.has_next);
				
				// Update image count if available
				if (navigation.current_index && navigation.total_images) {
					$("#imageMetadata").text(`Image ${navigation.current_index} of ${navigation.total_images}`);
				}
			}
		}
		
		// Function to display image
		function displayImage(imageName, imagePath, categories, shapes, colors, coordinates, width, height, rotation, existingLabels) {
			// Clear the canvas and existing shapes
			clearCanvas();
			
			// Reset image loaded state
			globals.imageLoaded = false;
			
			// Update the image information in the UI
			$("#image_info_name").text("Image: " + imageName);
			$("#image_info_dimensions").text("Dimensions: " + width + "x" + height);
			
			// Update the full image URL display
			$("#full-image-url").text("Image URL: " + imagePath);
			
			// Store the current image data
			currentImage = {
				name: imageName,
				path: imagePath,
				categories: categories,
				shapes: shapes,
				colors: colors,
				coordinates: coordinates,
				width: width,
				height: height,
				rotation: rotation,
				existingLabels: existingLabels // Store existing labels reference
			};
			
			// Update categories dropdown
			updateCategoriesDropdown(categories, colors);
			
			// Draw the image on the canvas
			drawImageOnCanvas(imagePath, width, height, rotation);
		}
		
		// Function to update the categories dropdown
		function updateCategoriesDropdown(categories, colors) {
			// Clear the existing categories
			const categoriesList = $("#categories_coll");
			categoriesList.empty();
			
			// Add categories to the list
			for (let i = 0; i < categories.length; i++) {
				const categoryName = categories[i];
				const categoryColor = colors[i];
				
				// Create list item
				const listItem = $("<li></li>")
					.attr("data-category", categoryName)
					.attr("data-color", categoryColor)
					.html(`
						<span class="category-name">${categoryName}</span>
						<div class="circle" style="background-color: ${categoryColor}"></div>
					`);
				
				// Add click handler to select this category
				listItem.on("click", function() {
					// Remove active class from all items
					categoriesList.find("li").removeClass("active");
					// Add active class to this item
					$(this).addClass("active");
					
					// Store previous values
					const previousCategory = currentCategory;
					const previousColor = currentColor;
					
					// Set current category and color
					currentCategory = categoryName;
					currentColor = categoryColor;
					
					// If color changed and we have an active path, update its color
					if (previousColor !== currentColor && globals.path) {
						try {
							globals.path.strokeColor = currentColor;
							
							// If the path has a fill color, update that too
							if (globals.path.fillColor) {
								globals.path.fillColor = new Color(currentColor);
								globals.path.fillColor.alpha = 0.3;
							}
							
							// Update the view
							paper.view.update();
						} catch (e) {
							console.error('Error updating path color:', e);
						}
					}
					
					// Show feedback to user
					showSuccessMessage(`Selected category: ${categoryName}`, 1000);
				});
				
				// Add to the list
				categoriesList.append(listItem);
			}
			
			// Set the first category as selected
			if (categories.length > 0) {
				categoriesList.find("li:first").addClass("active");
				currentCategory = categories[0];
				currentColor = colors[0];
			} else {
				// Handle no categories case
				showWarningMessage("No categories available. Please add categories first.");
				currentCategory = null;
				currentColor = "#ff0000";
			}
		}
		
		// Draw the image with proper error handling and state management
		function drawImageOnCanvas(imagePath, width, height, rotation) {
			// Set default canvas dimensions if they are not specified
			width = width || 800;
			height = height || 600;
			
			try {
				// Set up the view size and center
				paper.view.viewSize = new paper.Size(width, height);
				paper.view.center = new paper.Point(width / 2, height / 2);
				
				// Set the canvas element size to match the view size
				const canvas = document.getElementById('canvas');
				canvas.width = width;
				canvas.height = height;
				
				// Ensure the canvas container adapts to the canvas size
				const canvasDiv = document.getElementById('canvasDiv');
				canvasDiv.style.width = width + 'px';
				canvasDiv.style.height = height + 'px';
				
				// Store initial center for reset function
				globals.initialCenter = paper.view.center.clone();
				
				// Reset zoom factor
				globals.zoomFactor = 1;
				window.updateZoomDisplay();
				
				// Show loading overlay
				showLoadingOverlay();
				
				// Set a 15-second timeout to catch hanging loads
				const loadTimeout = setTimeout(() => {
					console.error("Image load timed out:", imagePath);
					hideLoadingOverlay();
					showErrorMessage(`Image load timed out. Check console for details.`);
					globals.imageLoaded = false;
				}, 15000);
				
				// Create a new raster
				const raster = new paper.Raster({
					source: imagePath,
					position: paper.view.center,
					crossOrigin: "anonymous" // Add crossOrigin directly to prevent CORS issues
				});
				
				// Store the raster in globals for later reference
				globals.raster = raster;
				
				// Handle successful load
				raster.onLoad = function() {
					// Clear the timeout as the image loaded successfully
					clearTimeout(loadTimeout);
					
					// Center the raster
					raster.position = paper.view.center;
					
					// Apply rotation if needed
					if (rotation !== 0) {
						raster.rotate(rotation);
					}
					
					// Set image as loaded
					globals.imageLoaded = true;
					
					// Hide loading overlay once image is loaded
					hideLoadingOverlay();
					console.log("Image loaded successfully:", imagePath);
					
					// Load at 100% zoom instead of fitting to screen
					globals.zoomFactor = 1;
					paper.view.zoom = 1;
					updateZoomDisplay();
					
					// Reset all tool states
					cleanupActivePath();
					
					// Load previous labels if available
					if (currentImage && currentImage.existingLabels && Object.keys(currentImage.existingLabels || {}).length > 0) {
						loadPreviousLabels(currentImage.existingLabels);
					}
					
					// Automatically detect grid after the image is loaded
					setTimeout(() => {
						// Call grid detection with the center of the image as the point
						const imageCenter = raster.position;
						startGridDetection(imageCenter);
					}, 1000); // Add a slight delay to ensure the image is fully visible
					
					// Make sure to update the view
					paper.view.update();
				};
				
				// Handle load errors
				raster.onError = function() {
					// Clear the timeout as the image failed to load
					clearTimeout(loadTimeout);
					
					console.error("Failed to load image:", imagePath);
					hideLoadingOverlay();
					
					// Try to provide a more detailed error message
					let errorDetail = "";
					if (imagePath.indexOf('://') === -1) {
						errorDetail = " URL may be missing protocol (http:// or https://).";
					} else if (imagePath.endsWith('/')) {
						errorDetail = " URL appears to be a directory, not a file.";
					} else if (!imagePath.match(/\.(jpg|jpeg|png|gif|bmp|webp|tiff)$/i)) {
						errorDetail = " URL might not point to an image file.";
					} else {
						errorDetail = " The server may be unreachable or the file may not exist.";
					}
					
					showErrorMessage(`Failed to load image.${errorDetail} Path: ${imagePath}`);
					
					// Draw error message on canvas using PaperJS
					paper.project.activeLayer.removeChildren();
					
					// Create a background
					const background = new paper.Path.Rectangle({
						point: [0, 0],
						size: [width, height],
						fillColor: '#f8d7da'
					});
					
					// Create error text
					const errorText = new paper.PointText({
						point: new paper.Point(paper.view.center.x, paper.view.center.y - 20),
						content: 'Image Failed to Load',
						fillColor: '#721c24',
						fontFamily: 'Arial',
						fontSize: 16,
						justification: 'center'
					});
					
					const pathText = new paper.PointText({
						point: new paper.Point(paper.view.center.x, paper.view.center.y + 20),
						content: imagePath,
						fillColor: '#721c24',
						fontFamily: 'Arial',
						fontSize: 12,
						justification: 'center'
					});
					
					const detailText = new paper.PointText({
						point: new paper.Point(paper.view.center.x, paper.view.center.y + 40),
						content: errorDetail,
						fillColor: '#721c24',
						fontFamily: 'Arial',
						fontSize: 12,
						justification: 'center'
					});
					
					// Update the view
					paper.view.update();
				};
				
				// Set the crossOrigin for the raster
				// Note: This can only be set for Image elements, not direct PaperJS rasters
				// We need to manually set this on the underlying image
				if (raster.image && !raster.image.complete) {
					raster.image.crossOrigin = "anonymous";
				}
				
				// Log the attempt to load the image
				console.log("Attempting to load image:", imagePath);
			} catch (e) {
				console.error("Error in drawImageOnCanvas:", e);
				hideLoadingOverlay();
				showErrorMessage("Error drawing image: " + e.message);
				globals.imageLoaded = false;
			}
		}
		
		// Start initial image loading
		console.log("Initiating first image load from database...");
		loadImage('next');

		// Save button click handler
		$('#save_button').click(function() {
			saveLabels();
		});
		
		// Clear button click handler
		$('#clear_button').click(function() {
			if (confirm('Are you sure you want to clear all annotations?')) {
				clearAnnotations();
			}
		});
		
		// Function to clear all annotations
		function clearAnnotations() {
			// Remove all paths except the image
			paper.project.activeLayer.children.forEach(function(child) {
				if (child !== globals.raster) {
					child.remove();
				}
			});
			
			// Clear undo/redo stacks
			globals.undos = [];
			globals.redos = [];
			
			// Clear saved measurements
			globals.savedMeasurements = [];
			
			// Update view
			paper.view.update();
			
			showSuccessMessage("All annotations cleared");
		}

		// Zoom control buttons
		$('#zoom-in').click(function() {
			if (globals.raster && globals.imageLoaded) {
				// Zoom in by 20% relative to the image center
				const newZoom = globals.zoomFactor * 1.2;
				if (newZoom <= 10) {  // Maintain max zoom limit of 1000%
					globals.zoomFactor = newZoom;
					paper.view.zoom = newZoom;
					paper.view.center = globals.raster.position;
					updateZoomDisplay();
				}
			} else {
				zoomView(1.2); // Use original zoom method if no image
			}
		});
		
		$('#zoom-out').click(function() {
			if (globals.raster && globals.imageLoaded) {
				// Zoom out by 20% relative to the image center
				const newZoom = globals.zoomFactor * 0.8;
				if (newZoom >= 0.1) {  // Maintain min zoom limit of 10%
					globals.zoomFactor = newZoom;
					paper.view.zoom = newZoom;
					paper.view.center = globals.raster.position;
					updateZoomDisplay();
				}
			} else {
				zoomView(0.8); // Use original zoom method if no image
			}
		});
		
		$('#zoom-fit').click(function() {
			fitImageToScreen();
		});
		
		$('#zoom-reset').click(function() {
			resetZoom();
		});
		
		// Initialize view controls for zooming and panning
		function initializeViewControls() {
			// Create a view tool for panning
			const viewTool = new paper.Tool();
			
			// Store this tool in globals so we can activate it later
			globals.viewTool = viewTool;
			
			// Add event handler for mouse wheel zooming
			$('#canvas').on('wheel', function(event) {
				event.preventDefault();
				
				// Determine zoom direction and factor
				const zoomFactor = event.originalEvent.deltaY < 0 ? 1.1 : 0.9;
				
				// Use centered zoom instead of zooming at mouse position
				zoomView(zoomFactor);
			});
			
			// Add event handlers for panning with mouse drag
			viewTool.onMouseDown = function(event) {
				// Only allow panning when view tool is active
				globals.isDragging = true;
				globals.lastPoint = event.point.clone();
				
				// Change cursor to indicate panning
				$('#canvas').css('cursor', 'grab');
			};
			
			viewTool.onMouseDrag = function(event) {
				if (globals.isDragging) {
					// Calculate the difference and apply to view center
					const delta = event.point.subtract(globals.lastPoint);
					paper.view.center = paper.view.center.subtract(delta);
					globals.lastPoint = event.point.clone();
					
					// Change cursor to indicate active panning
					$('#canvas').css('cursor', 'grabbing');
				}
			};
			
			viewTool.onMouseUp = function(event) {
				globals.isDragging = false;
				
				// Reset cursor
				$('#canvas').css('cursor', 'default');
			};
			
			// Add mobile touch gesture support with Hammer.js
			initializeTouchControls();
		}
		
		// Initialize touch controls for mobile devices
		function initializeTouchControls() {
			// Check if Hammer is available
			if (typeof Hammer === 'undefined') {
				console.warn('Hammer.js not loaded, touch gestures will not be available');
				logToDebugConsole('Hammer.js not loaded, touch gestures will not be available', 'warning');
				return;
			}
			
			// Log initialization
			logToDebugConsole('Initializing touch controls for mobile', 'info');
			
			try {
				// Get the canvas element
				const canvasElement = document.getElementById('canvas');
				const canvasManager = new Hammer.Manager(canvasElement);
				
				// Add recognizers
				const pinch = new Hammer.Pinch();
				const pan = new Hammer.Pan({ threshold: 10, direction: Hammer.DIRECTION_ALL });
				const tap = new Hammer.Tap({ taps: 2 }); // Double tap
				
				// Add the recognizers with proper priority
				canvasManager.add([pinch, pan, tap]);
				
				// Track initial scale factor and center for pinch gesture
				let initialScale = 1;
				let initialCenter = null;
				
				// Handle pinch (zoom) gesture
				canvasManager.on('pinchstart', function(event) {
					initialScale = globals.zoomFactor;
					
					// Get center point in paper coordinates
					const rect = canvasElement.getBoundingClientRect();
					const centerX = event.center.x - rect.left;
					const centerY = event.center.y - rect.top;
					
					// Store center for use during pinch move
					initialCenter = new paper.Point(centerX, centerY);
					
					// Prevent default touch actions
					event.preventDefault();
				});
				
				canvasManager.on('pinchmove', function(event) {
					if (!initialCenter) return;
					
					// Calculate new scale
					const newScale = initialScale * event.scale;
					
					// Limit zoom range (between 10% and 1000%)
					if (newScale >= 0.1 && newScale <= 10) {
						// Set the new zoom factor
						globals.zoomFactor = newScale;
						
						// Apply the zoom
						paper.view.zoom = newScale;
						
						// Center on pinch point
						if (globals.raster && globals.imageLoaded) {
							// Keep image centered on mobile for simplicity
							paper.view.center = globals.raster.position;
						}
						
						// Update the zoom display
						updateZoomDisplay();
						
						// Update the view
						paper.view.update();
					}
					
					// Prevent default touch actions
					event.preventDefault();
				});
				
				canvasManager.on('pinchend', function(event) {
					initialCenter = null;
					
					// Prevent default touch actions
					event.preventDefault();
				});
				
				// Track initial position for pan gesture
				let initialPanPos = null;
				
				// Handle pan gesture
				canvasManager.on('panstart', function(event) {
					// Only handle pan if we're not in drawing mode
					if (globals.currentTool === 'view' || globals.currentTool === null) {
						// Get initial position
						initialPanPos = paper.view.center.clone();
						
						// Prevent default touch actions
						event.preventDefault();
					}
				});
				
				canvasManager.on('panmove', function(event) {
					// Only handle pan if we're not in drawing mode and have initial position
					if ((globals.currentTool === 'view' || globals.currentTool === null) && initialPanPos) {
						// Calculate new position
						const deltaX = event.deltaX;
						const deltaY = event.deltaY;
						
						// Move view center with inverted delta to achieve proper panning
						paper.view.center = new paper.Point(
							initialPanPos.x - deltaX / paper.view.zoom,
							initialPanPos.y - deltaY / paper.view.zoom
						);
						
						// Update the view
						paper.view.update();
						
						// Prevent default touch actions
						event.preventDefault();
					}
				});
				
				canvasManager.on('panend', function(event) {
					initialPanPos = null;
					
					// Prevent default touch actions
					event.preventDefault();
				});
				
				// Handle double-tap gesture for quick zoom
				canvasManager.on('tap', function(event) {
					// Double tap to zoom in by 50%
					const rect = canvasElement.getBoundingClientRect();
					const centerX = event.center.x - rect.left;
					const centerY = event.center.y - rect.top;
					
					// Use centered zoom
					zoomView(1.5);
					
					// Prevent default touch actions
					event.preventDefault();
				});
				
				logToDebugConsole('Touch controls initialized successfully', 'success');
			} catch (e) {
				console.error('Error initializing touch controls:', e);
				logToDebugConsole('Error initializing touch controls: ' + e.message, 'error');
			}
		}
		
		// Function to zoom around a specific point
		function zoomAtPoint(point, factor) {
			// Check if we have a raster (image) loaded
			if (globals.raster && globals.imageLoaded) {
				// Always zoom with respect to the center of the image
				const imageCenter = globals.raster.position;
				
				// Update zoom factor
				globals.zoomFactor *= factor;
				
				// Limit zoom range (between 10% and 1000%)
				globals.zoomFactor = Math.max(0.1, Math.min(globals.zoomFactor, 10));
				
				// Update zoom display
				updateZoomDisplay();
				
				// Apply zoom
				paper.view.zoom *= factor;
				
				// Keep image centered
				paper.view.center = imageCenter;
				
				// Update the view
				paper.view.update();
			} else {
				// If no image is loaded, use the standard zoom behavior
				// Convert point from view space to project space
				const viewPoint = paper.view.viewToProject(point);
				
				// Update zoom factor
				globals.zoomFactor *= factor;
				
				// Limit zoom range (between 10% and 1000%)
				globals.zoomFactor = Math.max(0.1, Math.min(globals.zoomFactor, 10));
				
				// Update zoom display
				updateZoomDisplay();
				
				// Calculate new zoom center
				const beta = paper.view.zoom / (paper.view.zoom * factor);
				const pc = viewPoint.subtract(paper.view.center);
				const offset = viewPoint.subtract(pc.multiply(beta)).subtract(paper.view.center);
				
				// Apply zoom and pan
				paper.view.zoom *= factor;
				paper.view.center = paper.view.center.add(offset);
				
				// Update the view
				paper.view.update();
			}
		}
		
		// Function to zoom the view (centered)
		function zoomView(factor) {
			// Update zoom factor
			globals.zoomFactor *= factor;
			
			// Limit zoom range (between 10% and 1000%)
			globals.zoomFactor = Math.max(0.1, Math.min(globals.zoomFactor, 10));
			
			// Update zoom display
			updateZoomDisplay();
			
			// If image is loaded, zoom relative to image center
			if (globals.raster) {
				// Apply zoom
				paper.view.zoom *= factor;
				
				// Keep image centered
				paper.view.center = globals.raster.position;
			} else {
				// Apply zoom to current view center
				paper.view.zoom *= factor;
			}
			
			// Update the view
			paper.view.update();
		}
		
		// Function to update zoom level display
		function updateZoomDisplay() {
			const percentage = Math.round(globals.zoomFactor * 100);
			$('#zoom-level').text(`${percentage}%`);
		}
		
		// Function to reset zoom to 100%
		function resetZoom() {
			// Calculate the factor needed to return to 100%
			const factor = 1 / globals.zoomFactor;
			
			// Reset the zoom factor
			globals.zoomFactor = 1;
			
			// Update zoom display
			updateZoomDisplay();
			
			// Reset view center to initial center
			paper.view.center = globals.initialCenter.clone();
			
			// Apply zoom
			paper.view.zoom = 1;
			
			// Update the view
			paper.view.update();
		}
		
		// Function to fit image to screen
		function fitImageToScreen() {
			if (!globals.raster) return;
			
			// Get canvas container dimensions
			const containerWidth = $('#canvasContainer').width();
			const containerHeight = $('#canvasContainer').height();
			
			// Calculate the scale factors needed to fit the image
			const scaleX = containerWidth / globals.raster.width;
			const scaleY = containerHeight / globals.raster.height;
			
			// Use the smaller scale factor to ensure the entire image fits
			const scale = Math.min(scaleX, scaleY) * 0.9; // Add a 10% margin
			
			// Calculate the zoom factor relative to current zoom
			const zoomFactor = scale / paper.view.zoom;
			
			// Update the global zoom factor
			globals.zoomFactor = scale;
			
			// Update zoom display
			updateZoomDisplay();
			
			// Center the image
			paper.view.center = globals.raster.position;
			
			// Apply the zoom
			paper.view.zoom = scale;
			
			// Update the view
			paper.view.update();
		}

		// Move updateZoomDisplay function here to make it globally accessible
		function updateZoomDisplay() {
			const percentage = Math.round(globals.zoomFactor * 100);
			$('#zoom-level').text(`${percentage}%`);
		}

		// Add the grid detection function with better error handling and visual feedback
		function startGridDetection(point) {
			// Show loading overlay
				showLoadingOverlay("Detecting grid...");
				logToDebugConsole("Starting grid detection...", "info");
				
				// Get current image data
				const imageData = {
					name: currentImage ? currentImage.name : null,
					path: currentImage ? currentImage.path : null,
					point: {
						x: Math.round(point.x),
						y: Math.round(point.y)
					}
				};
				
				console.log('Starting grid detection at point:', point);
				logToDebugConsole(`Starting grid detection at point: (${point.x}, ${point.y})`, "info");
				
				// We no longer need the click indicator since it's automatic
				// Just call the backend directly
				
				// Call to backend for grid detection
				$.ajax({
					url: "{% url 'detect_grid' %}",
					type: "POST",
					contentType: 'application/json',
					data: JSON.stringify(imageData),
					success: function(response) {
						hideLoadingOverlay();
						
						if (response.success) {
							// Render the detected grid
							renderDetectedGrid(response.grid);
							// Log success to debug console
							const confidencePercent = Math.round(response.grid.metrics.confidence * 100);
							logToDebugConsole(`Grid detected automatically (Confidence: ${confidencePercent}%)`, "success");
							
							// Log detailed metrics for debugging
							console.log('Grid detection metrics:', response.grid.metrics);
							
							// Log additional details to debug console
							logToDebugConsole(`Cell Width: ${Math.round(response.grid.metrics.cellWidth)}px`, "info");
							logToDebugConsole(`Cell Height: ${Math.round(response.grid.metrics.cellHeight)}px`, "info");
							logToDebugConsole(`Rotation: ${response.grid.metrics.rotation.toFixed(1)}°`, "info");
							if (response.grid.metrics.realWorldScale) {
								const scale = (response.grid.metrics.realWorldScale.width / response.grid.metrics.cellWidth).toFixed(5);
								logToDebugConsole(`Scale: 1px = ${scale}m`, "info");
							}
						} else {
							// Show proper error message to user
							let errorMsg = response.message || "Automatic grid detection failed";
							logToDebugConsole(errorMsg, "error");
						}
					},
					error: function(xhr, status, error) {
						hideLoadingOverlay();
						
						// Show detailed error
						let errorMessage = "Error in automatic grid detection";
						try {
							const response = JSON.parse(xhr.responseText);
							if (response && response.message) {
								errorMessage = `Grid detection error: ${response.message}`;
							}
						} catch (e) {
							errorMessage = `Grid detection error: ${error || xhr.statusText}`;
						}
						
						logToDebugConsole(errorMessage, "error");
						console.error("Grid detection error details:", xhr.responseText);
					}
				});
			}

		// Improved function to render the detected grid with visual enhancements
		function renderDetectedGrid(gridData) {
			// Create a group for all grid elements
			const gridGroup = new paper.Group();
			
			// Set group data for identification and undo
			gridGroup.data = {
				type: 'grid',
				category: currentCategory,
				color: currentColor,
				createdAt: new Date().getTime()
			};
			
			// Draw grid lines with improved styling
			if (gridData.lines) {
				// Create separate groups for horizontal and vertical lines
				const hLinesGroup = new paper.Group();
				const vLinesGroup = new paper.Group();
				
				logToDebugConsole(`Rendering ${gridData.lines.length} grid lines`, "info");
				
				gridData.lines.forEach(line => {
					const start = new paper.Point(line.start.x, line.start.y);
					const end = new paper.Point(line.end.x, line.end.y);
					
					// Determine if line is horizontal or vertical
					const isHorizontal = Math.abs(end.y - start.y) < Math.abs(end.x - start.x);
					
					const gridLine = new paper.Path.Line(start, end);
					
					gridLine.strokeColor = currentColor;
					gridLine.strokeWidth = 1;
					gridLine.dashArray = [5, 5];
					
					// Add to appropriate group
					if (isHorizontal) {
						hLinesGroup.addChild(gridLine);
					} else {
						vLinesGroup.addChild(gridLine);
					}
				});
				
				// Add line groups to main grid group
				gridGroup.addChild(hLinesGroup);
				gridGroup.addChild(vLinesGroup);
			}
			
			// Draw grid intersections with improved styling
			if (gridData.intersections) {
				const intersectionsGroup = new paper.Group();
				
				logToDebugConsole(`Rendering ${gridData.intersections.length} grid intersections`, "info");
				
				gridData.intersections.forEach(point => {
					const intersection = new paper.Path.Circle({
						center: new paper.Point(point.x, point.y),
						radius: 3,
						fillColor: currentColor
					});
					
					intersectionsGroup.addChild(intersection);
				});
				
				// Add intersections to grid group
				gridGroup.addChild(intersectionsGroup);
			}
			
			// Store grid metrics in globals for measurement calculations
			if (gridData.metrics && gridData.metrics.realWorldScale) {
				globals.gridMetrics = gridData.metrics;
				console.log('Grid metrics stored for measurements:', globals.gridMetrics);
				logToDebugConsole("Grid metrics stored for measurements", "success");
			}
			
			// Add the entire grid group to undo stack
			addToUndoStack(gridGroup);
			
			// Update canvas
			paper.view.update();
			
			// Display grid metrics in debug console
			if (gridData.metrics) {
				// Format metrics message for debug console
				logToDebugConsole("Grid Metrics Summary:", "info");
				logToDebugConsole(`Cell Width: ${Math.round(gridData.metrics.cellWidth)}px`, "info");
				logToDebugConsole(`Cell Height: ${Math.round(gridData.metrics.cellHeight)}px`, "info");
				logToDebugConsole(`Rotation: ${gridData.metrics.rotation.toFixed(1)}°`, "info");
				logToDebugConsole(`Confidence: ${(gridData.metrics.confidence * 100).toFixed(0)}%`, "info");
				
				if (gridData.metrics.realWorldScale) {
					const scale = (gridData.metrics.realWorldScale.width / gridData.metrics.cellWidth).toFixed(5);
					logToDebugConsole(`Scale: 1px = ${scale}m`, "info");
				}
				
				if (gridData.metrics.algorithm) {
					logToDebugConsole(`Method: ${gridData.metrics.algorithm}`, "info");
				}
			}
		}

		// Add PDF button click handler
		$('#pdf_button').click(function() {
			saveToPDF();
		});

		// Function to load previous labels from existing GeoJSON data
		function loadPreviousLabels(existingLabels) {
			if (!existingLabels) {
				console.log("No existing labels to load");
				logToDebugConsole("No existing labels to load", "info");
				return;
			}
			
			try {
				showLoadingOverlay("Loading previous labels...");
				logToDebugConsole("Loading previous labels...", "info");
				
				let loadedShapes = 0;
				let loadedMeasurements = 0;
				let errorCount = 0;
				
				// Load features (shapes)
				if (existingLabels.features && existingLabels.features.length > 0) {
					logToDebugConsole(`Found ${existingLabels.features.length} shapes to load`, "info");
					
					existingLabels.features.forEach(feature => {
						try {
							// Validate feature
							if (!feature.geometry || !feature.properties) {
								console.warn("Invalid feature structure:", feature);
								logToDebugConsole("Invalid feature structure", "warning");
								errorCount++;
								return;
							}
							
							// Find the corresponding category color
							let categoryColor = "#ff0000"; // Default color
							let categoryName = feature.properties.category;
							
							if (!categoryName) {
								console.warn("Feature missing category:", feature);
								logToDebugConsole("Feature missing category, using 'Unknown'", "warning");
								categoryName = "Unknown";
							}
							
							// Find the category color from current categories
							if (currentImage && currentImage.categories) {
								const categoryIndex = currentImage.categories.findIndex(cat => cat === categoryName);
								if (categoryIndex !== -1 && currentImage.colors && currentImage.colors[categoryIndex]) {
									categoryColor = currentImage.colors[categoryIndex];
								}
							}
							
							// Use stored color if available
							if (feature.properties.color) {
								categoryColor = feature.properties.color;
							}
							
							// Create path based on geometry type
							let path = null;
							
							if (feature.geometry.type === 'Point') {
								// Point is represented as a circle
								const coords = feature.geometry.coordinates;
								if (!coords || coords.length < 2) {
									console.warn("Invalid Point coordinates:", coords);
									logToDebugConsole("Invalid Point coordinates", "warning");
									errorCount++;
									return;
								}
								
								const centerX = coords[0];
								const centerY = coords[1];
								const radius = coords[2] || 5; // Use radius if provided, or default to 5
								
								path = new paper.Path.Circle({
									center: new paper.Point(centerX, centerY),
									radius: radius,
									strokeColor: categoryColor,
									strokeWidth: 2,
									fillColor: globals.blueprintStyle.shapes.fillColor
								});
								
								logToDebugConsole(`Loaded Point at (${centerX}, ${centerY}) with radius ${radius}`, "success");
							}
							else if (feature.geometry.type === 'Polygon') {
								// Polygon is a closed path
								const rings = feature.geometry.coordinates;
								if (!rings || !rings.length || !rings[0] || rings[0].length < 3) {
									console.warn("Invalid Polygon coordinates:", rings);
									logToDebugConsole("Invalid Polygon coordinates", "warning");
									errorCount++;
									return;
								}
								
								const coords = rings[0]; // First (and typically only) ring
								
								path = new paper.Path();
								path.strokeColor = categoryColor;
								path.strokeWidth = 2;
								path.fillColor = globals.blueprintStyle.shapes.fillColor;
								
								// Add points to path
								coords.forEach(point => {
									if (Array.isArray(point) && point.length >= 2) {
										path.add(new paper.Point(point[0], point[1]));
									}
								});
								
								// Close the path
								path.closed = true;
								
								logToDebugConsole(`Loaded Polygon with ${coords.length} points in category ${categoryName}`, "success");
							}
							else if (feature.geometry.type === 'LineString') {
								// LineString is an open path
								const coords = feature.geometry.coordinates;
								if (!coords || !coords.length || coords.length < 2) {
									console.warn("Invalid LineString coordinates:", coords);
									logToDebugConsole("Invalid LineString coordinates", "warning");
									errorCount++;
									return;
								}
								
								path = new paper.Path();
								path.strokeColor = categoryColor;
								path.strokeWidth = 2;
								
								// Add points to path
								coords.forEach(point => {
									if (Array.isArray(point) && point.length >= 2) {
										path.add(new paper.Point(point[0], point[1]));
									}
								});
								
								logToDebugConsole(`Loaded LineString with ${coords.length} points`, "success");
							}
							else {
								console.warn("Unsupported geometry type:", feature.geometry.type);
								logToDebugConsole(`Unsupported geometry type: ${feature.geometry.type}`, "warning");
								errorCount++;
								return;
							}
							
							// Set metadata for the path
							if (path) {
								path.data = {
									category: categoryName,
									color: categoryColor,
									createdAt: feature.properties.createdAt || new Date().getTime()
								};
								
								// Add to undo stack
								addToUndoStack(path);
								loadedShapes++;
								
								// Highlight briefly with a blink
								const origStrokeWidth = path.strokeWidth;
								const origStrokeColor = path.strokeColor;
								const origFillColor = path.fillColor ? path.fillColor.clone() : null;
								
								// Quick blink effect
								path.strokeWidth = origStrokeWidth * 2;
								path.strokeColor = new paper.Color(1, 0.8, 0);
								if (path.fillColor) {
									path.fillColor = new paper.Color(1, 1, 0, 0.5);
								}
								
								// Revert to original style after a delay
								setTimeout(() => {
									if (path && !path.removed) {
										path.strokeWidth = origStrokeWidth;
										path.strokeColor = origStrokeColor;
										if (path.fillColor && origFillColor) {
											path.fillColor = origFillColor;
										}
										paper.view.update();
									}
								}, 300);
							}
						} catch (e) {
							console.error("Error creating path from feature:", e, feature);
							logToDebugConsole(`Error creating path: ${e.message}`, "error");
							errorCount++;
						}
					});
				}
				
				// Load measurements
				if (existingLabels.measurements && existingLabels.measurements.length > 0) {
					logToDebugConsole(`Found ${existingLabels.measurements.length} measurements to load`, "info");
					
					existingLabels.measurements.forEach(measurement => {
						try {
							// Validate measurement
							if (!measurement.startPoint || !measurement.endPoint) {
								console.warn("Invalid measurement structure:", measurement);
								logToDebugConsole("Invalid measurement structure", "warning");
								errorCount++;
								return;
							}
							
							// Create start and end points
							const startPoint = new paper.Point(measurement.startPoint[0], measurement.startPoint[1]);
							const endPoint = new paper.Point(measurement.endPoint[0], measurement.endPoint[1]);
							
							// Create measurement label
							const labelText = formatMeasurementText(
								measurement.pixelDistance,
								measurement.metricDistance,
								measurement.imperialDistance
							);
							
							// Create architectural dimension
							const dimensionGroup = createArchitecturalDimension(startPoint, endPoint, labelText);
							
							// Add metadata
							dimensionGroup.data = {
								type: 'measurement',
								pixelDistance: measurement.pixelDistance,
								metricDistance: measurement.metricDistance,
								imperialDistance: measurement.imperialDistance,
								startPoint: startPoint,
								endPoint: endPoint,
								createdAt: measurement.createdAt || new Date().getTime()
							};
							
							// Add to undo stack
							addToUndoStack(dimensionGroup);
							
							// Add to saved measurements array
							globals.savedMeasurements.push(dimensionGroup);
							loadedMeasurements++;
							
							logToDebugConsole(`Loaded measurement: ${labelText}`, "success");
							
							// Brief highlight effect
							const origStrokeColor = dimensionGroup.children[0].strokeColor;
							
							// Highlight effect - make all children glow briefly
							dimensionGroup.children.forEach(child => {
								if (child.strokeColor) {
									child.strokeColor = new paper.Color(1, 0.8, 0);
								}
							});
							
							// Revert to original style after a delay
							setTimeout(() => {
								if (dimensionGroup && !dimensionGroup.removed) {
									dimensionGroup.children.forEach(child => {
										if (child.strokeColor) {
											child.strokeColor = origStrokeColor;
										}
									});
									paper.view.update();
								}
							}, 300);
						} catch (e) {
							console.error("Error creating measurement:", e, measurement);
							logToDebugConsole(`Error creating measurement: ${e.message}`, "error");
							errorCount++;
						}
					});
				}
				
				// Load grid metrics if available
				if (existingLabels.metadata && existingLabels.metadata.gridMetrics) {
					globals.gridMetrics = existingLabels.metadata.gridMetrics;
					console.log("Loaded grid metrics from previous labels:", globals.gridMetrics);
					logToDebugConsole("Loaded grid metrics from previous labels", "info");
				}
				
				// Update the view
				paper.view.update();
				
				// Build detailed message about loaded items
				let summaryMessage = "";
				
				const totalLoaded = loadedShapes + loadedMeasurements;
				if (totalLoaded > 0) {
						summaryMessage = `Loaded ${totalLoaded} previous annotations `;
						
						const details = [];
						if (loadedShapes > 0) {
							details.push(`${loadedShapes} shapes`);
						}
						if (loadedMeasurements > 0) {
							details.push(`${loadedMeasurements} measurements`);
						}
						
						summaryMessage += `(${details.join(", ")})`;
						
						if (errorCount > 0) {
							summaryMessage += ` with ${errorCount} errors`;
						}
						
						logToDebugConsole(summaryMessage, "success");
					} else if (errorCount > 0) {
						summaryMessage = `No labels loaded. Found ${errorCount} errors in label data.`;
						logToDebugConsole(summaryMessage, "warning");
					} else {
						summaryMessage = "No previous labels found for this image.";
						logToDebugConsole(summaryMessage, "info");
					}
				
				hideLoadingOverlay();
				
				// Show summary message in console log
				console.log(summaryMessage);
			} catch (e) {
				hideLoadingOverlay();
				console.error("Error loading previous labels:", e);
				logToDebugConsole(`Error loading previous labels: ${e.message}`, "error");
			}
		}
	});

	// Function to show error, success, or warning messages to user
	function showNotification(message, type = 'error', duration = 5000) {
		// Log to debug console
		logToDebugConsole(message, type);
		
		// Also log to browser console for debugging
		console.log(`[${type.toUpperCase()}] ${message}`);
	}

	// Convenience functions for different notification types
	function showErrorMessage(message, duration = 5000) {
		showNotification(message, 'error', duration);
	}

	function showSuccessMessage(message, duration = 5000) {
		showNotification(message, 'success', duration);  
	}

	function showWarningMessage(message, duration = 5000) {
		showNotification(message, 'warning', duration);
	}
	
	// Function to log to debug console
	function logToDebugConsole(message, type = 'log') {
		// Get the debug console element
		const debugConsole = document.getElementById('debug-console');
		if (!debugConsole) return;
		
		// Create a new log entry
		const logEntry = document.createElement('div');
		logEntry.className = `log ${type}`;
		
		// Add timestamp
		const now = new Date();
		const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;
		
		// Set log content
		logEntry.innerHTML = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
		
		// Add to console
		debugConsole.appendChild(logEntry);
		
		// Auto-scroll to bottom
		debugConsole.scrollTop = debugConsole.scrollHeight;
	}
	
	// Initialize debug console and mobile sidebar
	$(document).ready(function() {
		// Handle toggle button for console
		$('#console-toggle').click(function() {
			const debugConsole = $('#debug-console');
			if (debugConsole.hasClass('expanded')) {
				debugConsole.removeClass('expanded');
				$(this).text('Show Debug Console');
			} else {
				debugConsole.addClass('expanded');
				$(this).text('Hide Debug Console');
			}
		});
		
		// Initialize mobile sidebar toggle
		$('#sidebar-toggle').click(function() {
			const sidebar = $('.control-sidebar');
			if (sidebar.hasClass('expanded')) {
				sidebar.removeClass('expanded');
				$(this).html('<i>≡</i>'); // Menu icon
			} else {
				sidebar.addClass('expanded');
				$(this).html('<i>×</i>'); // Close icon
			}
		});
		
		// Handle initial mobile setup and resize events
		function handleMobileLayout() {
			const isMobile = window.innerWidth <= 768;
			const sidebar = $('.control-sidebar');
			
			if (isMobile) {
				sidebar.removeClass('expanded');
				// Add overlay click handler for closing sidebar on mobile
				$('#canvasContainer').off('click.mobileSidebar').on('click.mobileSidebar', function() {
					if (sidebar.hasClass('expanded')) {
						sidebar.removeClass('expanded');
						$('#sidebar-toggle').html('<i>≡</i>');
					}
				});
			} else {
				// On desktop, sidebar is always expanded
				sidebar.addClass('expanded');
			}
		}
		
		// Run on load and window resize
		handleMobileLayout();
		$(window).resize(handleMobileLayout);
		
		// Add viewport meta tag for mobile responsiveness if not already present
		if (!$('meta[name="viewport"]').length) {
			$('head').append('<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">');
		}
		
		// Initialize mobile toolbar
		$('#mobile-pen').click(function() {
			cleanupActivePath();
			penTool.activate();
			updateActiveToolButton($('#pen_button')[0]);
			globals.currentTool = 'pen';
			updateMobileToolbarActiveState(this);
		});
		
		$('#mobile-shape').click(function() {
			// Toggle shape submenu or default to rectangle tool
			cleanupActivePath();
			rectangleTool.activate();
			updateActiveToolButton($('#rectangle_button')[0]);
			globals.currentTool = 'rectangle';
			updateMobileToolbarActiveState(this);
		});
		
		$('#mobile-measure').click(function() {
			cleanupActivePath();
			measureTool.activate();
			updateActiveToolButton($('#measure_button')[0]);
			globals.currentTool = 'measure';
			updateMobileToolbarActiveState(this);
		});
		
		$('#mobile-save').click(function() {
			saveLabels();
		});
		
		$('#mobile-tools').click(function() {
			// Toggle the sidebar for more tools
			$('#sidebar-toggle').click();
		});
		
		// Mobile zoom buttons
		$('#mobile-zoom-in').click(function() {
			// Zoom in by 20%
			zoomView(1.2);
			
			// Visual feedback for the zoom action
			$(this).addClass('active');
			setTimeout(() => $(this).removeClass('active'), 300);
			
			// Show zoom level in a toast message
			const percentage = Math.round(globals.zoomFactor * 100);
			showSuccessMessage(`Zoom: ${percentage}%`, 1000);
		});
		
		$('#mobile-zoom-out').click(function() {
			// Zoom out by 20%
			zoomView(0.8);
			
			// Visual feedback for the zoom action
			$(this).addClass('active');
			setTimeout(() => $(this).removeClass('active'), 300);
			
			// Show zoom level in a toast message
			const percentage = Math.round(globals.zoomFactor * 100);
			showSuccessMessage(`Zoom: ${percentage}%`, 1000);
		});
		
		// Function to update mobile toolbar active state
		function updateMobileToolbarActiveState(activeButton) {
			// Remove active class from buttons except zoom-in/out which handle their own state
			$('.mobile-toolbar button:not(#mobile-zoom-in):not(#mobile-zoom-out)').removeClass('active');
			if (activeButton) {
				$(activeButton).addClass('active');
			}
		}
		
		// Log initial message
		logToDebugConsole('Debug console initialized', 'info');
		logToDebugConsole('Mobile responsive layout initialized', 'info');
	});

	// Function to save the canvas as a PDF for printing on 44" wide paper
	function saveToPDF() {
		try {
			showLoadingOverlay("Generating PDF...");
			
			// Check if jsPDF is available
			if (typeof window.jspdf === 'undefined' || !window.jspdf.jsPDF) {
				// Try to find jsPDF in other common locations before failing
				if (typeof jspdf !== 'undefined' && jspdf.jsPDF) {
					window.jspdf = jspdf;
					console.log('Found jsPDF in global scope, using it');
				} else if (typeof window.jsPDF !== 'undefined') {
					window.jspdf = { jsPDF: window.jsPDF };
					console.log('Found jsPDF in window.jsPDF, using it');
				} else {
					console.error('jsPDF library not loaded properly');
					showErrorMessage('PDF generation library not loaded properly. Please check your internet connection and try again.');
					hideLoadingOverlay();
					return;
				}
			}
			
			// First, ensure zoom level is set to 100% before proceeding
			console.log('Setting zoom level to 100% before PDF export');
			// Save current zoom level to restore later if needed
			const originalZoomFactor = globals.zoomFactor;
			
			// Reset the zoom factor to 100%
			globals.zoomFactor = 1;
			
			// Update zoom display manually instead of calling updateZoomDisplay
			const percentage = Math.round(globals.zoomFactor * 100);
			$('#zoom-level').text(`${percentage}%`);
			
			// Apply zoom to the view
			paper.view.zoom = 1;
			
			
			// Reset view center to ensure image is properly positioned
			if (globals.raster) {
				paper.view.center = globals.raster.position;
			} else {
				paper.view.center = globals.initialCenter.clone();
			}
			
			// Update the view to ensure changes are applied
			paper.view.update();
			
			// Check if we have grid metrics for accurate scaling
			if (!globals.gridMetrics || !globals.gridMetrics.realWorldScale) {
				showWarningMessage("No grid metrics available. Scale may not be accurate in the PDF.");
			}
			
			// Get the canvas dimensions
			const canvas = document.getElementById('canvas');
			const width = canvas.width;
			const height = canvas.height;
			
			// Calculate the target paper width (44 inches in mm)
			const paperWidthInches = 44;
			const paperWidthMm = paperWidthInches * 25.4; // 44 inches in mm
			
			// Determine the real-world dimensions of the image at 100% scale
			let realWorldWidthMm = width;
			let realWorldHeightMm = height;
			let pixelsPerMeter = 1000; // Default fallback value (1 pixel = 1 mm)
			
			if (globals.gridMetrics && globals.gridMetrics.realWorldScale) {
				// Get the correct pixel-to-meter conversion from grid metrics
				const cellWidthPixels = globals.gridMetrics.cellWidth;
				const cellWidthMeters = globals.gridMetrics.realWorldScale.width;
				
				// Calculate pixels per meter correctly
				pixelsPerMeter = cellWidthPixels / cellWidthMeters;
				console.log(`Grid cell: ${cellWidthPixels}px = ${cellWidthMeters}m, Pixels per meter: ${pixelsPerMeter}`);
				
				// Calculate real-world dimensions in mm at 100% scale
				realWorldWidthMm = (width / pixelsPerMeter) * 1000; // Convert meters to mm
				realWorldHeightMm = (height / pixelsPerMeter) * 1000; // Convert meters to mm
				
				console.log(`Canvas dimensions: ${width}px × ${height}px`);
				console.log(`Real world dimensions at 100% scale: ${realWorldWidthMm.toFixed(1)}mm × ${realWorldHeightMm.toFixed(1)}mm`);
			} else {
				// Without grid metrics, make a best guess (1px = 1mm)
				pixelsPerMeter = 1000;
				realWorldWidthMm = width;
				realWorldHeightMm = height;
				showWarningMessage("Using estimated scale without grid metrics. The output may not be exactly 1:1.");
			}
			
			// Store original canvas items to restore later
			const originalItems = [];
			paper.project.activeLayer.children.forEach((item) => {
				originalItems.push({
					item: item,
					visible: item.visible
				});
			});
			
			// Add metric dimensions and scale bar to the canvas before saving
			const dimensionItems = addMetricDimensionsToCanvas(pixelsPerMeter, width, height, realWorldWidthMm, realWorldHeightMm);
			
			// Calculate padding needed to reach 44" width
			// This is the key change for the new feature - always use 100% scale
			let pdfWidthMm = realWorldWidthMm;
			let pdfHeightMm = realWorldHeightMm;
			
			// Calculate padding needed on each side to reach 44" width
			let paddingNeeded = 0;
			if (pdfWidthMm < paperWidthMm) {
				paddingNeeded = paperWidthMm - pdfWidthMm;
				console.log(`Adding padding of ${paddingNeeded.toFixed(1)}mm to reach 44" width`);
			}
			
			// Initialize jsPDF with orientation based on dimensions
			const orientation = pdfWidthMm > pdfHeightMm ? 'landscape' : 'portrait';
			
			// Create PDF using the global jsPDF variable
			const { jsPDF } = window.jspdf;
			
			// Create PDF with the full 44" width
			const pdf = new jsPDF({
				orientation: orientation,
				unit: 'mm',
				format: [Math.max(pdfWidthMm, paperWidthMm), pdfHeightMm],
				compress: true
			});
			
			// Get the canvas data as an image
			const imgData = canvas.toDataURL('image/png', 1.0);
			
			// Calculate left padding to center the image in the 44" width
			const leftPadding = paddingNeeded > 0 ? (paddingNeeded / 2) : 0;
			
			// Add image to PDF at 100% scale with padding to center it
			pdf.addImage(imgData, 'PNG', leftPadding, 0, pdfWidthMm, pdfHeightMm);
			
			// Add metadata about scaling
			let scaleInfo = "1:1 scale (100%)";
			if (globals.gridMetrics && globals.gridMetrics.realWorldScale) {
				scaleInfo = `1:1 scale (${realWorldWidthMm.toFixed(0)}mm × ${realWorldHeightMm.toFixed(0)}mm)`;
				if (paddingNeeded > 0) {
					scaleInfo += ` with ${paddingNeeded.toFixed(0)}mm padding to reach 44" width`;
				}
			} else {
				scaleInfo = "Best estimated 1:1 scale (may not be exactly accurate)";
			}
			
			// Add printing instructions
			pdf.setFontSize(10);
			
			pdf.setTextColor(0, 0, 0);
			pdf.text(`PRINTING INSTRUCTIONS: For accurate scale, print at 100% size (no scaling).`, 5, pdfHeightMm - 15);
			
			// Add a small footer with scale information
			pdf.setFontSize(8);
			pdf.setTextColor(100, 100, 100);
			pdf.text(`Scale: ${scaleInfo} | Generated: ${new Date().toLocaleString()}`, 5, pdfHeightMm - 5);
			
			// Generate PDF filename from image name or date
			const filename = currentImage && currentImage.name 
				? `${currentImage.name}_100pct_44in.pdf` 
				: `map_100pct_44in_${new Date().toISOString().replace(/[:.]/g, '-')}.pdf`;
			
			// Save PDF
			pdf.save(filename);
			
			// Remove the dimension items from the canvas
			dimensionItems.forEach(item => item.remove());
			
			// Restore original visibility
			originalItems.forEach(({item, visible}) => {
				if (item && !item.removed) {
					item.visible = visible;
				}
			});
			
			// Restore original zoom level if needed
			if (originalZoomFactor !== 1) {
				globals.zoomFactor = originalZoomFactor;
				paper.view.zoom = originalZoomFactor;
				
				// Update zoom display manually
				const restorePercentage = Math.round(globals.zoomFactor * 100);
				$('#zoom-level').text(`${restorePercentage}%`);
			}
			
			// Update the view
			paper.view.update();
			
			hideLoadingOverlay();
			showSuccessMessage("PDF generated successfully at 100% scale with 44-inch width and metric dimensions");
		} catch (e) {
			hideLoadingOverlay();
			console.error("Error generating PDF:", e);
			showErrorMessage("Error generating PDF: " + e.message);
		}
	}

	// Function to add metric dimensions and scale bar to the canvas
	function addMetricDimensionsToCanvas(pixelsPerMeter, canvasWidth, canvasHeight, widthMm, heightMm) {
		const dimensionItems = [];
		
		// Format metric dimensions
		let widthText = "";
		let heightText = "";
		
		if (widthMm > 1000) {
			widthText = `${(widthMm / 1000).toFixed(2)}m`;
		} else {
			widthText = `${Math.round(widthMm)}mm`;
		}
		
		if (heightMm > 1000) {
			heightText = `${(heightMm / 1000).toFixed(2)}m`;
		} else {
			heightText = `${Math.round(heightMm)}mm`;
		}
		
		// Improved blueprint styling for dimensions
		const blueprintFont = globals.blueprintStyle.measureText.fontFamily;
		const blueprintColor = globals.blueprintStyle.dimension.lineColor;
		const labelBgColor = globals.blueprintStyle.measureText.backgroundColor;
		
		// FIXED: Add detailed scale information at the top of canvas
		const scaleInfoText = new paper.PointText({
			point: new paper.Point(canvasWidth / 2, 15),
			content: `Scale: 1 pixel = ${(1000/pixelsPerMeter).toFixed(2)}mm`,
			fillColor: blueprintColor,
			fontSize: 12,
			fontFamily: blueprintFont,
			justification: 'center'
		});
		
		const scaleInfoBg = new paper.Path.Rectangle({
			rectangle: scaleInfoText.bounds.expand(5),
			fillColor: labelBgColor,
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		scaleInfoBg.sendToBack();
		const scaleInfoGroup = new paper.Group([scaleInfoBg, scaleInfoText]);
		dimensionItems.push(scaleInfoGroup);
		
		// Add the width dimension at the top
		const widthLabel = new paper.PointText({
			point: new paper.Point(canvasWidth / 2, 40),
			content: `Width: ${widthText}`,
			fillColor: blueprintColor,
			fontSize: 16,
			fontFamily: blueprintFont,
			fontWeight: 'bold',
			justification: 'center'
		});
		
		const widthBg = new paper.Path.Rectangle({
			rectangle: widthLabel.bounds.expand(5),
			fillColor: labelBgColor,
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		widthBg.sendToBack();
		const widthGroup = new paper.Group([widthBg, widthLabel]);
		dimensionItems.push(widthGroup);
		
		// Add the height dimension on the left
		const heightLabel = new paper.PointText({
			point: new paper.Point(30, canvasHeight / 2),
			content: `Height: ${heightText}`,
			fillColor: blueprintColor,
			fontSize: 16,
			fontFamily: blueprintFont,
			fontWeight: 'bold',
			justification: 'center'
		});
		
		// Rotate the height label
		heightLabel.rotate(-90);
		
		const heightBg = new paper.Path.Rectangle({
			rectangle: heightLabel.bounds.expand(5),
			fillColor: labelBgColor,
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		heightBg.sendToBack();
		const heightGroup = new paper.Group([heightBg, heightLabel]);
		dimensionItems.push(heightGroup);
		
		// Add a scale bar at the bottom right with improved styling
		const scaleBarWidthMm = 100; // 10cm scale bar
		const scaleBarWidthPixels = scaleBarWidthMm * pixelsPerMeter / 1000;
		
		// FIXED: Log scale bar size for debugging
		console.log(`Scale bar: ${scaleBarWidthMm}mm = ${scaleBarWidthPixels}px`);
		
		// Create a scale bar with alternating black and white segments
		const segments = 5; // 5 segments alternating black/white
		const segmentWidth = scaleBarWidthPixels / segments;
		const scaleBarHeight = 20;
		const scaleBarY = canvasHeight - 50;
		const scaleBarX = canvasWidth - scaleBarWidthPixels - 50;
		
		const scaleBarGroup = new paper.Group();
		
		for (let i = 0; i < segments; i++) {
			const segment = new paper.Path.Rectangle({
				point: [scaleBarX + i * segmentWidth, scaleBarY],
				size: [segmentWidth, scaleBarHeight],
				fillColor: i % 2 === 0 ? blueprintColor : 'white',
				strokeColor: blueprintColor,
				strokeWidth: 1
			});
			
			scaleBarGroup.addChild(segment);
		}
		
		// Add scale bar label with metric and imperial measurements
		const metricText = `${scaleBarWidthMm}mm (${(scaleBarWidthMm/10).toFixed(1)}cm)`;
		const imperialText = `${formatImperialText(scaleBarWidthMm/1000 * 3.28084)}`;
		
		const scaleBarLabel = new paper.PointText({
			point: new paper.Point(scaleBarX + scaleBarWidthPixels / 2, scaleBarY + scaleBarHeight + 15),
			content: `${metricText} | ${imperialText}`,
			fillColor: blueprintColor,
			fontSize: 12,
			fontFamily: blueprintFont,
			justification: 'center'
		});
		
		const scaleBarLabelBg = new paper.Path.Rectangle({
			rectangle: scaleBarLabel.bounds.expand(5),
			fillColor: labelBgColor,
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		scaleBarLabelBg.sendToBack();
		scaleBarGroup.addChild(scaleBarLabelBg);
		scaleBarGroup.addChild(scaleBarLabel);
		dimensionItems.push(scaleBarGroup);
		
		// Add a calibration square of known dimensions (1cm x 1cm)
		const squareSizeMm = 10; // 1cm calibration square
		const squareSizePixels = squareSizeMm * pixelsPerMeter / 1000;
		
		// FIXED: Log calibration square size for debugging
		console.log(`Calibration square: ${squareSizeMm}mm = ${squareSizePixels}px`);
		
		const calibrationSquare = new paper.Path.Rectangle({
			point: [scaleBarX - squareSizePixels - 20, scaleBarY],
			size: [squareSizePixels, squareSizePixels],
			fillColor: new paper.Color(0.12, 0.33, 0.65, 0.3), // Semi-transparent blueprint blue
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		const squareLabel = new paper.PointText({
			point: new paper.Point(calibrationSquare.bounds.center.x, calibrationSquare.bounds.bottom + 15),
			content: `1cm × 1cm`,
			fillColor: blueprintColor,
			fontSize: 10,
			fontFamily: blueprintFont,
			justification: 'center'
		});
		
		const squareLabelBg = new paper.Path.Rectangle({
			rectangle: squareLabel.bounds.expand(3),
			fillColor: labelBgColor,
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		squareLabelBg.sendToBack();
		const calibrationGroup = new paper.Group([calibrationSquare, squareLabelBg, squareLabel]);
		dimensionItems.push(calibrationGroup);
		
		// Add dimensions in the center of the canvas
		const centerInfo = new paper.PointText({
			point: paper.view.center,
			content: `Canvas Size: ${widthText} × ${heightText}`,
			fillColor: blueprintColor,
			fontSize: 18,
			fontFamily: blueprintFont,
			fontWeight: 'bold',
			justification: 'center'
		});
		
		// Create a white background with translucency
		const centerInfoBg = new paper.Path.Rectangle({
			rectangle: centerInfo.bounds.expand(10),
			fillColor: labelBgColor,
			strokeColor: blueprintColor,
			strokeWidth: 1
		});
		
		centerInfoBg.sendToBack();
		const centerInfoGroup = new paper.Group([centerInfoBg, centerInfo]);
		dimensionItems.push(centerInfoGroup);
		
		// Update the view to render the new items
		paper.view.update();
		
		return dimensionItems;
	}

	// Add helper function to determine if PDF will fit on standard paper
	function getClosestStandardPaperSize(widthMm, heightMm) {
		// Common paper sizes in mm (width, height) - with portrait orientation
		const standardSizes = {
			'A0': [841, 1189],
			'A1': [594, 841],
			'A2': [420, 594],
			'A3': [297, 420],
			'A4': [210, 297],
			'Letter': [215.9, 279.4],
			'Legal': [215.9, 355.6],
			'ARCH_E': [914.4, 1219.2] // 36 x 48 inches
		};
		
		// Normalize orientation for comparison (make width ≤ height)
		let w = widthMm;
		let h = heightMm;
		let landscape = false;
		
		if (w > h) {
			landscape = true;
			[w, h] = [h, w]; // Swap for comparison with standard sizes
		}
		
		// Find closest standard size
		let closestSize = 'Custom';
		let minDiff = Infinity;
		
		for (const [name, dims] of Object.entries(standardSizes)) {
			const [stdW, stdH] = dims;
			// Check if our size fits within this standard size
			if (w <= stdW && h <= stdH) {
				const diff = (stdW - w) + (stdH - h); // Total difference in dimensions
				if (diff < minDiff) {
					minDiff = diff;
					closestSize = name;
				}
			}
		}
		
		return { size: closestSize, landscape };
	}
</script>
{% endblock %}
