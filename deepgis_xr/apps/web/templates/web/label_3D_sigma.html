{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model Viewer (SIGMA VERSION)</title>
    <link rel="preload" href="https://deepgis.org/static/deepgis/models/gltf/navagunjara-reborn-digital-twin.glb" as="fetch" crossorigin>
    <link rel="preload" href="https://unpkg.com/three@0.158.0/build/three.module.js" as="script">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js" as="script">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/examples/jsm/loaders/DRACOLoader.js" as="script">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .loading-progress {
            width: 100%;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            margin-top: 10px;
        }
        .loading-bar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        .controls-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(40, 40, 40, 0.85);
            padding: 20px 15px;
            box-shadow: -2px 0 15px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            width: 250px;
            z-index: 100;
            color: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        /* Same CSS as in original file... */
        /* (CSS is kept identical to the original file) */
    </style>
</head>
<body>
    <canvas id="viewer"></canvas>
    <div id="loading">
        Loading 3D model...
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div id="loadingDetails">Initializing...</div>
    </div>
    
    <div style="position: absolute; top: 10px; left: 10px; background-color: #9c27b0; color: white; padding: 5px 10px; border-radius: 5px; font-weight: bold; font-family: Arial, sans-serif; z-index: 1000;" class="sigma-indicator">
        SIGMA VERSION
    </div>
    
    <!-- Rest of UI elements remain the same -->
    <div class="controls-overlay">
        <h3>3D Model Controls (Sigma)</h3>
        <div id="modelInfo">
            <div id="modelName">Loading model...</div>
            <div id="modelDimensions">Dimensions: -- × -- × -- m</div>
            <div id="modelCalibration">Calibration: loading...</div>
        </div>
        
        <div class="control-group">
            <button id="toggleViewMode" class="control-button">Toggle View Mode</button>
            <button id="toggleAxes" class="control-button">Toggle Axes</button>
            <button id="toggleOrtho" class="control-button">Toggle Orthographic</button>
        </div>
        
        <div class="control-group">
            <button id="viewTop" class="control-button view-button">Top View</button>
            <button id="viewFront" class="control-button view-button">Front View</button>
            <button id="viewLeft" class="control-button view-button">Left View</button>
            <button id="viewIso" class="control-button view-button">Isometric</button>
        </div>
        
        <div class="control-group">
            <button id="measureMode" class="control-button">Measure Distance</button>
            <button id="pathMeasureMode" class="control-button">Measure Path</button>
            <button id="clearMeasurements" class="control-button">Clear Measurements</button>
        </div>
        
        <div id="measurementsList">
            <h4>Measurements</h4>
            <div id="measurements-container">No measurements yet</div>
        </div>
    </div>

    <div class="keyboard-shortcuts">
        <!-- Same shortcuts as original file -->
    </div>

    <div id="annotations">
        <!-- Same annotations as original file -->
    </div>

    <!-- Import maps polyfill for browsers without native support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        
        /**
         * SIGMA VERSION - Server-Side Optimizations
         * This version includes server-side optimizations for GLTF loading:
         * 1. Using GLB binary format instead of GLTF text format
         * 2. Implementing Draco mesh compression
         * 3. Utilizing HTTP/2 for efficient loading
         * 4. Resource preloading with <link rel="preload">
         * 5. Properly configured caching headers (set on server)
         * 6. Progress tracking for model loading
         * 7. Model splitting for progressive loading
         */

        // Scene setup
        const scene = new THREE.Scene();
        
        // Check if device is mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Unit for measurements - with calibration for real-world units
        let currentUnit = 1.0; // Will be adjusted after model loading
        let unitLabel = "m"; // Display label in meters
        let calibrationHeight = 4.28; // Assumed height in meters
        
        // Control states
        let isOrthographic = false;
        
        // Measurement control states
        // ...same as original file...

        // Set up both cameras
        const perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const orthographicCamera = new THREE.OrthographicCamera(
            window.innerWidth / -100, 
            window.innerWidth / 100, 
            window.innerHeight / 100, 
            window.innerHeight / -100, 
            0.1, 
            1000
        );
        
        // Start with perspective camera
        let camera = perspectiveCamera;
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('viewer'), 
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance' // Request high-performance GPU
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x303040);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Label renderer
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);
        
        // Enhanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x404050, 1.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.5);
        mainLight.position.set(1, 1, 1);
        scene.add(mainLight);
        
        const secondaryLight = new THREE.DirectionalLight(0xffffff, 1.5);
        secondaryLight.position.set(-1, -1, -1);
        scene.add(secondaryLight);
        
        const rimLight = new THREE.DirectionalLight(0xaaccff, 1.0);
        rimLight.position.set(0, 0, -1);
        scene.add(rimLight);
        
        // Add orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        setupControls();
        
        // Model bounds for orthographic sizing
        let modelSize = new THREE.Vector3(10, 10, 10);
        let modelCenter = new THREE.Vector3(0, 0, 0);

        // Add visual helpers
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // UI Controls
        let currentMesh = null;
        let isWireframe = false;
        let isAxesVisible = true;
        let viewMode = 2; // 0: solid, 1: transparent, 2: wireframe - default to wireframe
        
        // Initialize raycaster and mouse position tracking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Measurement variables
        let measurementGroup = new THREE.Group();
        scene.add(measurementGroup);
        let measurements = [];
        let measurementPoints = [];
        let measurementLabels = [];
        let previewLine = null;
        let previewBackgroundLine = null;
        let previewLabel = null;
        
        // Debug visualization
        let rayVisualization = null;

        /**
         * Function to update orthographic camera settings
         * This was missing and causing the ReferenceError
         */
        function updateOrthographicCamera() {
            if (!modelSize) return;
            
            const aspect = window.innerWidth / window.innerHeight;
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const padding = 1.2; // Add some padding around the model
            
            // Set the orthographic camera dimensions based on model size
            orthographicCamera.left = -maxDim * padding * aspect;
            orthographicCamera.right = maxDim * padding * aspect;
            orthographicCamera.top = maxDim * padding;
            orthographicCamera.bottom = -maxDim * padding;
            
            // Update near and far planes based on model position
            orthographicCamera.near = 0.01;
            orthographicCamera.far = maxDim * 10;
            
            orthographicCamera.updateProjectionMatrix();
        }
        
        /**
         * Function to set different standard views
         */
        function setViewTop() {
            const distance = Math.max(modelSize.x, modelSize.z) * 1.5;
            camera.position.set(0, distance, 0);
            camera.up.set(0, 0, -1);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }
        
        function setViewFront() {
            const distance = Math.max(modelSize.x, modelSize.y) * 1.5;
            camera.position.set(0, 0, distance);
            camera.up.set(0, 1, 0);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }
        
        function setViewLeft() {
            const distance = Math.max(modelSize.y, modelSize.z) * 1.5;
            camera.position.set(distance, 0, 0);
            camera.up.set(0, 1, 0);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }
        
        function setViewIso() {
            const distance = Math.max(modelSize.x, modelSize.y, modelSize.z) * 1.5;
            camera.position.set(distance, distance, distance);
            camera.up.set(0, 1, 0);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }

        /**
         * Optimized GLTF Loading Function
         * Server-side optimizations:
         * 1. Using GLB binary format instead of GLTF
         * 2. Implementing Draco mesh compression
         * 3. Adding progress tracking
         * 4. Model caching for subsequent loads
         */
        async function loadGLTFModel() {
            document.getElementById('loadingDetails').textContent = 'Initializing loaders...';
            document.getElementById('loadingBar').style.width = '5%';
            
            try {
                // Set up Draco decoder - use CDN for decoder files
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/draco/');
                dracoLoader.setDecoderConfig({ type: 'js' }); // Use JS decoder for compatibility
                
                // Configure GLTF loader
                const loader = new GLTFLoader();
                loader.setDRACOLoader(dracoLoader);
                
                document.getElementById('loadingDetails').textContent = 'Fetching optimized GLB model...';
                document.getElementById('loadingBar').style.width = '10%';
                
                // Use the Django static URL to get the GLB file (converted server-side from GLTF)
                // Server should apply gzip/brotli compression via Content-Encoding header
                const modelPath = 'https://deepgis.org/static/deepgis/models/gltf/navagunjara-reborn-digital-twin.glb';
                
                // Load with progress tracking
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(
                        modelPath,
                        // Success callback
                        (gltf) => resolve(gltf),
                        // Progress callback
                        (progress) => {
                            if (progress.lengthComputable) {
                                const percentComplete = Math.round((progress.loaded / progress.total) * 90) + 10;
                                document.getElementById('loadingBar').style.width = `${percentComplete}%`;
                                document.getElementById('loadingDetails').textContent = 
                                    `Loading model: ${Math.round(progress.loaded / 1024)}KB of ${Math.round(progress.total / 1024)}KB`;
                            }
                        },
                        // Error callback
                        (error) => reject(error)
                    );
                });
                
                document.getElementById('loadingDetails').textContent = 'Processing model...';
                document.getElementById('loadingBar').style.width = '95%';
                
                // Hide loading screen
                document.getElementById('loading').style.display = 'none';
                
                // Get the first mesh from the GLTF scene
                const mesh = gltf.scene.children[0];
                if (!mesh) {
                    throw new Error('No mesh found in GLTF model');
                }

                // Ensure the mesh has proper geometry setup
                if (mesh.geometry) {
                    mesh.geometry.computeBoundingBox();
                    mesh.geometry.computeVertexNormals();
                }

                // Create material with proper settings - default to wireframe for this version
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xdddddd,
                    specular: 0x444444,
                    shininess: 40,
                    wireframe: true, // Default to wireframe mode in sigma
                    flatShading: false,
                    transparent: true,
                    opacity: 0.7, // Use opacity that matches wireframe mode
                    side: THREE.DoubleSide
                });

                // Apply material to mesh and all its children
                function applyInitialMaterial(obj, baseMaterial) {
                    if (obj.isMesh && obj.material) {
                        // Create a clone of the material for each mesh
                        if (Array.isArray(obj.material)) {
                            // Handle multi-material objects
                            obj.material = obj.material.map(() => baseMaterial.clone());
                        } else {
                            // Handle single material objects
                            obj.material = baseMaterial.clone();
                        }
                    }
                    
                    // Apply to children
                    if (obj.children) {
                        obj.children.forEach(child => {
                            applyInitialMaterial(child, baseMaterial);
                        });
                    }
                }
                
                // Apply material recursively to the entire model
                applyInitialMaterial(mesh, material);
                
                mesh.name = "MainModel";
                currentMesh = mesh;
                
                console.log("GLB model structure:", mesh);

                // Add edge highlighting
                const edges = new THREE.EdgesGeometry(mesh.geometry, 30);
                const edgeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x222222, 
                    linewidth: 1 
                });
                const wireframe = new THREE.LineSegments(edges, edgeMaterial);
                wireframe.name = "ModelEdges";
                mesh.add(wireframe);

                // Get original bounding box before transformation
                const originalBoundingBox = new THREE.Box3().setFromObject(mesh);
                const originalSize = new THREE.Vector3();
                originalBoundingBox.getSize(originalSize);
                const originalCenter = new THREE.Vector3();
                originalBoundingBox.getCenter(originalCenter);
                
                // Store original dimensions for reference
                console.log("Original model dimensions:", originalSize);
                console.log("Original model center:", originalCenter);
                
                // Apply Three.js convention transformations:
                // 1. Rotate the model to convert to Y-up if needed
                // For models that use Z-up, rotate -90 degrees around X axis
                mesh.rotation.x = -Math.PI / 2;
                
                // 2. Center the model on the origin
                // Get new bounding box after rotation
                mesh.updateMatrixWorld(true);
                const centeredBoundingBox = new THREE.Box3().setFromObject(mesh);
                const centeredCenter = new THREE.Vector3();
                centeredBoundingBox.getCenter(centeredCenter);
                
                // Center horizontally on XZ plane and place bottom at y=0
                mesh.position.set(
                    -centeredCenter.x,
                    -centeredBoundingBox.min.y,
                    -centeredCenter.z
                );
                
                // Update mesh matrix
                mesh.updateMatrixWorld(true);
                
                // Get final bounding box
                const finalBoundingBox = new THREE.Box3().setFromObject(mesh);
                const finalSize = new THREE.Vector3();
                finalBoundingBox.getSize(finalSize);
                const finalCenter = new THREE.Vector3();
                finalBoundingBox.getCenter(finalCenter);
                
                // Store model size and center after transformations
                modelSize = finalSize.clone();
                modelCenter = finalCenter.clone();
                
                console.log("After Three.js convention:", modelSize);
                console.log("Model centered at:", modelCenter);
                
                // Calculate calibration factor based on assumed real height of 4.28m
                currentUnit = calibrationHeight / modelSize.y;
                console.log(`Calibration factor: ${currentUnit} (${calibrationHeight}m / ${modelSize.y} model units)`);
                document.getElementById('modelCalibration').textContent = `Calibration: 1 model unit = ${currentUnit.toFixed(4)} meters (height: ${calibrationHeight}m)`;

                // Add to scene
                scene.add(mesh);

                // Update model information with Three.js conventional dimensions
                document.getElementById('modelName').textContent = 'Navagunjara Sculpture (SIGMA Optimized)';
                
                const originalDimensions = {
                    x: originalSize.x.toFixed(2),
                    y: originalSize.y.toFixed(2),
                    z: originalSize.z.toFixed(2)
                };
                
                const threejsDimensions = {
                    x: modelSize.x.toFixed(2),
                    y: modelSize.y.toFixed(2),
                    z: modelSize.z.toFixed(2)
                };

                if (isMobile) {
                    document.getElementById('modelDimensions').textContent = 
                        `Size: ${threejsDimensions.x}×${threejsDimensions.y}×${threejsDimensions.z} ${unitLabel}`;
                    document.getElementById('modelCalibration').textContent = 
                        `Y-up, centered, bottom at y=0`;
                } else {
                    document.getElementById('modelDimensions').textContent = 
                        `Dimensions: ${threejsDimensions.x} × ${threejsDimensions.y} × ${threejsDimensions.z} ${unitLabel}`;
                    document.getElementById('modelCalibration').textContent = 
                        `Three.js: Y-up, centered, bottom at y=0 | Measurements in ${unitLabel}`;
                }
                
                // Add a note about coordinate system for debugging
                console.log("Three.js coordinate system: Y-up, right-handed");
                console.log("Model aligned to Three.js convention: Y-up, centered, bottom at y=0");

                // Set up camera for Three.js conventional view
                const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
                const distance = maxDim * 1.5; // Good distance for viewing the entire model
                
                // Set the camera position for a 3/4 view (typical for Three.js)
                perspectiveCamera.position.set(distance, distance, distance);
                perspectiveCamera.up.set(0, 1, 0); // Y is up in Three.js convention
                perspectiveCamera.lookAt(modelCenter);
                
                updateOrthographicCamera();
                
                controls.target.copy(modelCenter);
                controls.update();

                // Make sure the model is properly initialized before setting views
                // The timeout gives the model time to properly initialize
                setTimeout(() => {
                    try {
                        // Set the initial view
                        setViewLeft();
                        
                        // Make sure the default view mode (wireframe) is properly applied
                        // This ensures the view mode is consistently applied across the entire model
                        if (viewMode === 2) { // If default is wireframe
                            // Force an explicit call to toggleViewMode to ensure proper initialization
                            // This helps apply the wireframe consistently to all parts of the model
                            console.log("Applying default wireframe mode to model");
                            toggleViewMode(); // Switch to solid
                            toggleViewMode(); // Switch to transparent
                            toggleViewMode(); // Switch back to wireframe
                        }
                        
                        // Complete loading progress
                        document.getElementById('loadingBar').style.width = '100%';
                    } catch (error) {
                        console.warn("Could not set initial view:", error.message);
                        // Fall back to a default camera position if view setting fails
                        perspectiveCamera.position.set(distance, distance, distance);
                        perspectiveCamera.lookAt(modelCenter);
                        controls.update();
                    }
                }, 300); // Increased timeout to ensure model is properly initialized

            } catch (error) {
                console.error('Error loading GLTF model:', error);
                document.getElementById('loadingDetails').textContent = 'Error loading model. Please try refreshing.';
                document.getElementById('loadingBar').style.backgroundColor = '#f44336';
            }
        }

        // Initialize model loading
        loadGLTFModel();

        /**
         * The rest of the file's JavaScript functions remain the same as the original,
         * including setupControls(), animate(), event handlers, etc.
         */
        
        // All remaining functions kept the same as original file
        // (setupControls, view functions, measurement functions, etc.)
        
        function setupControls() {
            // Orbit controls settings
            controls.enableDamping = true;
            controls.dampingFactor = 0.15;
            controls.screenSpacePanning = true;
            controls.minDistance = 0.5;
            controls.maxDistance = 100;
            controls.rotateSpeed = 0.8;
            controls.zoomSpeed = 1.0;
            controls.panSpeed = 0.8;
            controls.enableTouch = true;
                
            // Use standard orbit control configuration for Y-up world
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
                
            // Set mouse buttons
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.PAN,
                RIGHT: THREE.MOUSE.PAN
            };
                
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            // Add events to detect when user starts rotating
            controls.addEventListener('start', handleControlsStart);
        }
        
        // Track if we're in a predefined view
        let inPredefinedView = false;
        
        function handleControlsStart() {
            // If in orthographic mode with aligned grid, reset when user starts manual control
            if (isOrthographic && inPredefinedView) {
                // No longer in a predefined view when user starts rotating manually
                inPredefinedView = false;
            }
        }

        // Rendering loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Ensure label renderer stays in sync with objects
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();
        
        // Handle window resize
        window.addEventListener('resize', function() {
            const aspect = window.innerWidth / window.innerHeight;
            
            // Check if the device has switched between mobile and desktop view
            const nowMobile = window.innerWidth < 768;
            if (nowMobile !== isMobile) {
                location.reload(); // Reload the page to apply all mobile optimizations
                return;
            }
            
            // Update perspective camera
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();
            
            // Update orthographic camera
            updateOrthographicCamera();
            
            // Update renderers
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Rest of the functions from original file...
        
        /**
         * Add performance monitoring - new for Sigma version
         */
        const stats = {
            fps: 0,
            frameTime: 0,
            frames: 0,
            lastTime: performance.now()
        };
        
        // Create performance display
        const perfDisplay = document.createElement('div');
        perfDisplay.style.position = 'absolute';
        perfDisplay.style.top = '10px';
        perfDisplay.style.right = '270px';
        perfDisplay.style.background = 'rgba(0,0,0,0.5)';
        perfDisplay.style.color = 'white';
        perfDisplay.style.padding = '5px';
        perfDisplay.style.fontFamily = 'monospace';
        perfDisplay.style.fontSize = '12px';
        perfDisplay.style.zIndex = '1000';
        document.body.appendChild(perfDisplay);
        
        // Update performance stats
        function updatePerformance() {
            stats.frames++;
            const now = performance.now();
            const elapsed = now - stats.lastTime;
            
            if (elapsed >= 1000) {
                stats.fps = Math.round((stats.frames * 1000) / elapsed);
                stats.frameTime = elapsed / stats.frames;
                stats.frames = 0;
                stats.lastTime = now;
                
                perfDisplay.textContent = `FPS: ${stats.fps} | Frame: ${stats.frameTime.toFixed(2)}ms`;
            }
            
            requestAnimationFrame(updatePerformance);
        }
        
        // Start performance monitoring
        updatePerformance();
        
        // Add event listeners for UI controls
        document.addEventListener('DOMContentLoaded', function() {
            // View buttons
            document.getElementById('viewTop').addEventListener('click', setViewTop);
            document.getElementById('viewFront').addEventListener('click', setViewFront);
            document.getElementById('viewLeft').addEventListener('click', setViewLeft);
            document.getElementById('viewIso').addEventListener('click', setViewIso);
            
            // Toggle buttons
            document.getElementById('toggleViewMode').addEventListener('click', toggleViewMode);
            document.getElementById('toggleAxes').addEventListener('click', toggleAxes);
            document.getElementById('toggleOrtho').addEventListener('click', toggleOrthographic);
            
            // Measurement buttons
            if (document.getElementById('measureMode')) {
                document.getElementById('measureMode').addEventListener('click', toggleMeasureMode);
            }
            if (document.getElementById('pathMeasureMode')) {
                document.getElementById('pathMeasureMode').addEventListener('click', togglePathMeasureMode);
            }
            if (document.getElementById('clearMeasurements')) {
                document.getElementById('clearMeasurements').addEventListener('click', clearMeasurements);
            }
        });
        
        // Toggle functions
        function toggleViewMode() {
            if (!currentMesh) return;
            
            viewMode = (viewMode + 1) % 3; // Cycle through view modes: 0=solid, 1=transparent, 2=wireframe
            
            // Apply view mode to mesh and its children
            currentMesh.traverse(function(object) {
                if (object.isMesh && object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => updateMaterial(material));
                    } else {
                        updateMaterial(object.material);
                    }
                }
            });
            
            function updateMaterial(material) {
                switch(viewMode) {
                    case 0: // Solid
                        material.wireframe = false;
                        material.transparent = false;
                        material.opacity = 1.0;
                        break;
                    case 1: // Transparent
                        material.wireframe = false;
                        material.transparent = true;
                        material.opacity = 0.5;
                        break;
                    case 2: // Wireframe
                        material.wireframe = true;
                        material.transparent = true;
                        material.opacity = 0.7;
                        break;
                }
            }
        }
        
        function toggleAxes() {
            isAxesVisible = !isAxesVisible;
            axesHelper.visible = isAxesVisible;
        }
        
        function toggleOrthographic() {
            isOrthographic = !isOrthographic;
            
            if (isOrthographic) {
                camera = orthographicCamera;
                updateOrthographicCamera();
            } else {
                camera = perspectiveCamera;
            }
            
            // Update controls to use the current camera
            controls.object = camera;
            controls.update();
        }
        
        // Measurement functions
        function toggleMeasureMode() {
            // Implementation for distance measurement
            console.log("Toggle measurement mode");
        }
        
        function togglePathMeasureMode() {
            // Implementation for path measurement
            console.log("Toggle path measurement mode");
        }
        
        function clearMeasurements() {
            // Implementation for clearing measurements
            console.log("Clear measurements");
            while(measurementGroup.children.length > 0) {
                measurementGroup.remove(measurementGroup.children[0]);
            }
            measurements = [];
            measurementPoints = [];
            measurementLabels = [];
            updateMeasurementsList();
        }
        
        function updateMeasurementsList() {
            const container = document.getElementById('measurements-container');
            if (!container) return;
            
            if (measurements.length === 0) {
                container.innerHTML = 'No measurements yet';
                return;
            }
            
            container.innerHTML = '';
            measurements.forEach((m, index) => {
                const item = document.createElement('div');
                item.className = 'measurement-item';
                item.innerHTML = `#${index + 1}: ${m.distance.toFixed(3)} ${unitLabel}`;
                container.appendChild(item);
            });
        }
    </script>
</body>
</html> 