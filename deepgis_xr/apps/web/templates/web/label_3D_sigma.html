{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model Viewer (SIGMA VERSION)</title>
    <!-- Force high-performance GPU on dual-GPU systems -->
    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <!-- Add GPU preference in multiple ways -->
    <canvas id="gpu-preference" style="display:none"></canvas>
    <script>
        // Try to force high-performance GPU before any other code runs
        try {
            const canvas = document.getElementById('gpu-preference');
            const gl = canvas.getContext('webgl', {powerPreference: 'high-performance', failIfMajorPerformanceCaveat: true});
            console.log("Initialized preference GPU context:", gl ? "success" : "failed");
        } catch(e) {
            console.warn("Could not initialize preference GPU context:", e);
        }
    </script>
    <!-- Fix CORS issues by adding proper crossorigin attributes -->
    <link rel="preload" href="https://deepgis.org/static/deepgis/models/gltf/navagunjara-reborn-digital-twin-propane-and-solar-v4.glb" as="fetch" crossorigin="anonymous">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/build/three.module.js" as="script" crossorigin="anonymous">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js" as="script" crossorigin="anonymous">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/examples/jsm/loaders/DRACOLoader.js" as="script" crossorigin="anonymous">
    <style>
        body { margin: 0; overflow: hidden; background: #f5f5f5; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .loading-progress {
            width: 100%;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            margin-top: 10px;
        }
        .loading-bar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        .controls-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(40, 40, 40, 0.85);
            padding: 20px 15px;
            box-shadow: -2px 0 15px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            width: 250px;
            z-index: 100;
            color: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .keyboard-shortcuts {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(40, 40, 40, 0.85);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
            color: white;
            max-width: 300px;
        }
        .keyboard-shortcuts h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #9c27b0;
        }
        .keyboard-shortcuts ul {
            margin: 0;
            padding-left: 20px;
            line-height: 1.6;
        }
        .keyboard-shortcuts li strong {
            display: inline-block;
            min-width: 30px;
            color: #4caf50;
        }
        @media (max-width: 768px) {
            .keyboard-shortcuts {
                display: none !important;
            }
        }
        /* Same CSS as in original file... */
        /* (CSS is kept identical to the original file) */
    </style>
    <!-- Add responsive CSS for debug console and toggle button -->
    <style>
        @media (max-width: 768px) {
            #debug-console {
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                top: auto !important;
                width: 100vw !important;
                max-width: 100vw !important;
                max-height: 45vh !important;
                border-radius: 12px 12px 0 0 !important;
                font-size: 15px !important;
                padding: 18px 10px 10px 10px !important;
                z-index: 2000 !important;
                box-shadow: 0 -2px 12px rgba(0,0,0,0.25);
                overflow-y: auto !important;
                display: none;
                background: rgba(20,20,20,0.97) !important;
            }
            #debug-toggle-btn {
                position: fixed;
                right: 18px;
                bottom: 18px;
                z-index: 2100;
                background: #673ab7;
                color: #fff;
                border: none;
                border-radius: 50%;
                width: 54px;
                height: 54px;
                font-size: 18px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.18);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: background 0.2s;
            }
            #debug-toggle-btn.active {
                background: #311b92;
            }
        }
    </style>
</head>
<body>
    <canvas id="viewer"></canvas>
    <div id="loading">
        Loading 3D model...
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div id="loadingDetails">Initializing...</div>
    </div>
    
    <div style="position: absolute; top: 10px; left: 10px; background-color: #9c27b0; color: white; padding: 5px 10px; border-radius: 5px; font-weight: bold; font-family: Arial, sans-serif; z-index: 1000;" class="sigma-indicator">
        SIGMA VERSION
    </div>
    
    <div class="keyboard-shortcuts">
        <h3>Keyboard Shortcuts</h3>
        <ul>
            <li><strong>M</strong> - Toggle measure mode</li>
            <li><strong>P</strong> - Toggle path measure mode</li>
            <li><strong>C</strong> - Clear all measurements</li>
            <li><strong>F</strong> - Finish path (closes if possible)</li>
            <li><strong>Space</strong> - Enable rotation while measuring</li>
            <li><strong>ESC</strong> - Exit measure mode</li>
            <li><strong>O</strong> - Toggle orthographic view</li>
            <li><strong>G</strong> - Toggle grid & axes</li>
            <li><strong>V</strong> - Toggle view mode</li>
            <li><strong>1-4</strong> - Standard views</li>
        </ul>
    </div>
    
    <div class="controls-overlay">
        <h3>3D Model Controls (Sigma)</h3>
        <div id="modelInfo">
            <div id="modelName">Loading model...</div>
            <div id="modelDimensions">Dimensions: -- × -- × -- m</div>
            <div id="modelCalibration">Calibration: loading...</div>
        </div>
        
        <div class="control-group">
            <button id="toggleViewMode" class="control-button">Toggle View Mode</button>
            <button id="toggleGridAxes" class="control-button">Toggle Grid & Axes</button>
            <button id="toggleOrtho" class="control-button">Toggle Orthographic</button>
        </div>
        
        <div class="control-group">
            <button id="viewTop" class="control-button view-button">Top View</button>
            <button id="viewFront" class="control-button view-button">Front View</button>
            <button id="viewLeft" class="control-button view-button">Left View</button>
            <button id="viewIso" class="control-button view-button">Isometric</button>
        </div>
        
        <div class="control-group">
            <button id="measureMode" class="control-button">Measure Distance</button>
            <button id="pathMeasureMode" class="control-button">Measure Path</button>
            <button id="clearMeasurements" class="control-button">Clear Measurements</button>
            <button id="finishPathBtn" class="control-button" style="background-color: #e91e63;">Finish Path</button>
        </div>
        
        <div class="control-group">
            <label for="unitSelector" style="display:block;margin-bottom:5px;color:#ddd;">Measurement Units:</label>
            <select id="unitSelector" style="width:100%;padding:5px;background:#333;color:#fff;border:1px solid #555;border-radius:3px;">
                <option value="m">Meters (m)</option>
                <option value="cm">Centimeters (cm)</option>
                <option value="ft">Feet (ft)</option>
                <option value="in">Inches (in)</option>
            </select>
        </div>
        
        <div id="measurementsList">
            <h4>Measurements</h4>
            <div id="measurements-container">No measurements yet</div>
        </div>

        <div class="control-group">
            <h4>Model Hierarchy <span id="object-count" style="font-size: 12px; color: #aaa;">(0 objects)</span></h4>
            <div id="hierarchy-container" style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; margin-top: 5px;">
                <div id="hierarchy-tree">Loading hierarchy...</div>
            </div>
        </div>
    </div>

    <div class="keyboard-shortcuts">
        <!-- Same shortcuts as original file -->
    </div>

    <div id="annotations">
        <!-- Same annotations as original file -->
    </div>

    <!-- Import maps polyfill for browsers without native support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Create debugConsole and debugToggleBtn at the top so they are available everywhere
        const debugConsole = document.createElement('div');
        debugConsole.id = 'debug-console';
        debugConsole.style.position = 'absolute';
        debugConsole.style.left = '10px';
        debugConsole.style.bottom = '10px';
        debugConsole.style.maxWidth = '350px';
        debugConsole.style.maxHeight = '350px';
        debugConsole.style.overflow = 'auto';
        debugConsole.style.background = 'rgba(0,0,0,0.85)';
        debugConsole.style.color = 'white';
        debugConsole.style.padding = '10px';
        debugConsole.style.fontFamily = 'monospace';
        debugConsole.style.fontSize = '12px';
        debugConsole.style.zIndex = '1000';
        debugConsole.style.borderRadius = '6px';
        debugConsole.style.display = 'none'; // Hide debug console by default
        document.body.appendChild(debugConsole);

        const debugToggleBtn = document.createElement('button');
        debugToggleBtn.id = 'debug-toggle-btn';
        debugToggleBtn.innerHTML = 'Debug';
        debugToggleBtn.style.display = 'none'; // Hide debug toggle button by default
        debugToggleBtn.style.position = 'fixed';
        debugToggleBtn.style.right = '18px';
        debugToggleBtn.style.bottom = '18px';
        debugToggleBtn.style.zIndex = '2100';
        debugToggleBtn.style.background = '#673ab7';
        debugToggleBtn.style.color = '#fff';
        debugToggleBtn.style.border = 'none';
        debugToggleBtn.style.borderRadius = '50%';
        debugToggleBtn.style.width = '54px';
        debugToggleBtn.style.height = '54px';
        debugToggleBtn.style.fontSize = '18px';
        debugToggleBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.18)';
        debugToggleBtn.style.display = 'none';
        debugToggleBtn.style.alignItems = 'center';
        debugToggleBtn.style.justifyContent = 'center';
        debugToggleBtn.style.cursor = 'pointer';
        debugToggleBtn.style.transition = 'background 0.2s';
        document.body.appendChild(debugToggleBtn);

        // Add state management class
        class ViewerState {
            constructor() {
                this.isMeasureMode = false;
                this.isPathMeasureMode = false;
                this.currentMesh = null;
                this.needsRender = false;
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
                this.isHighPerformanceMode = true;
                this.viewMode = 1; // 0: solid, 1: transparent, 2: wireframe
                this.isOrthographic = false;
                this.isGridAxesVisible = true;
                this.measurementPoints = [];
                this.pathMeasurementPoints = [];
                this.pathMeasurementLines = [];
                this.pathMeasurementLabels = [];
                this.pathTotalDistance = 0;
                this.inPredefinedView = false;
                this.measurements = [];
                this.currentUnit = 1.0;
                this.unitLabel = 'm';
                this.modelSize = new THREE.Vector3(10, 10, 10);
                this.modelCenter = new THREE.Vector3(0, 0, 0);
                
                // Add new view mode properties
                this.currentView = 'iso'; // 'iso', 'top', 'front', 'left'
                this.viewTransitionDuration = 1000; // ms
                this.isTransitioning = false;
                this.cameraPosition = new THREE.Vector3();
                this.cameraTarget = new THREE.Vector3();
            }

            toggleMeasureMode() {
                if (this.isPathMeasureMode) {
                    this.togglePathMeasureMode();
                }
                this.isMeasureMode = !this.isMeasureMode;
                
                // Disable rotation in measure mode
                if (this.isMeasureMode && controls) {
                    controls.enableRotate = false;
                } else if (controls) {
                    controls.enableRotate = true;
                }
                
                this.needsRender = true;
            }

            togglePathMeasureMode() {
                if (this.isMeasureMode) {
                    this.toggleMeasureMode();
                }
                this.isPathMeasureMode = !this.isPathMeasureMode;
                
                // Disable rotation in path measure mode
                if (this.isPathMeasureMode && controls) {
                    controls.enableRotate = false;
                } else if (controls) {
                    controls.enableRotate = true;
                }
                
                this.needsRender = true;
            }

            updateModelDimensions(size, center) {
                this.modelSize.copy(size);
                this.modelCenter.copy(center);
            }

            // Add view mode methods
            setViewMode(mode) {
                if (this.isTransitioning) return;
                
                const oldMode = this.viewMode;
                this.viewMode = mode;
                
                if (this.currentMesh) {
                    this.currentMesh.traverse((object) => {
                        if (object.isMesh) {
                            const materials = Array.isArray(object.material) ? object.material : [object.material];
                            materials.forEach(material => {
                                switch (mode) {
                                    case 0: // Solid
                                        material.transparent = false;
                                        material.wireframe = false;
                                        break;
                                    case 1: // Transparent
                                        material.transparent = true;
                                        material.opacity = 0.7;
                                        material.wireframe = false;
                                        break;
                                    case 2: // Wireframe
                                        material.transparent = true;
                                        material.opacity = 0.3;
                                        material.wireframe = true;
                                        break;
                                }
                                material.needsUpdate = true;
                            });
                        }
                    });
                }
                
                this.needsRender = true;
                return oldMode !== mode;
            }

            toggleOrthographic() {
                if (this.isTransitioning) return;
                
                this.isOrthographic = !this.isOrthographic;
                this.needsRender = true;
                return true;
            }

            setPredefinedView(view) {
                if (this.isTransitioning || !this.modelSize) return;
                
                this.isTransitioning = true;
                this.currentView = view;
                
                const distance = Math.max(this.modelSize.x, this.modelSize.y, this.modelSize.z) * 1.5;
                const startPosition = this.cameraPosition.clone();
                const startTarget = this.cameraTarget.clone();
                let endPosition, endTarget;
                
                switch (view) {
                    case 'top':
                        endPosition = new THREE.Vector3(0, distance, 0);
                        endTarget = this.modelCenter.clone();
                        break;
                    case 'front':
                        endPosition = new THREE.Vector3(0, 0, distance);
                        endTarget = this.modelCenter.clone();
                        break;
                    case 'left':
                        endPosition = new THREE.Vector3(distance, 0, 0);
                        endTarget = this.modelCenter.clone();
                        break;
                    case 'iso':
                    default:
                        endPosition = new THREE.Vector3(distance, distance, distance);
                        endTarget = this.modelCenter.clone();
                        break;
                }
                
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / this.viewTransitionDuration, 1);
                    
                    // Ease in-out function
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    this.cameraPosition.lerpVectors(startPosition, endPosition, easeProgress);
                    this.cameraTarget.lerpVectors(startTarget, endTarget, easeProgress);
                    
                    camera.position.copy(this.cameraPosition);
                    controls.target.copy(this.cameraTarget);
                    controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.isTransitioning = false;
                        this.inPredefinedView = true;
                    }
                    
                    this.needsRender = true;
                };
                
                animate();
                return true;
            }

            toggleGridAxes() {
                this.isGridAxesVisible = !this.isGridAxesVisible;
                if (axesHelper) {
                    axesHelper.visible = this.isGridAxesVisible;
                }
                if (gridHelper) {
                    gridHelper.visible = this.isGridAxesVisible;
                }
                this.needsRender = true;
                return true;
            }
        }

        // Initialize state at the very top before any function uses it
        const state = new ViewerState();

        // Configure Three.js to allow software rendering fallback
        // This is needed for machines where hardware acceleration is not available
        window.THREE_ALLOW_SOFTWARE_RENDERER = true;

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        
        /**
         * SIGMA VERSION - Server-Side Optimizations
         * This version includes server-side optimizations for GLTF loading:
         * 1. Using GLB binary format instead of GLTF
         * 2. Implementing Draco mesh compression
         * 3. Utilizing HTTP/2 for efficient loading
         * 4. Resource preloading with <link rel="preload">
         * 5. Properly configured caching headers (set on server)
         * 6. Progress tracking for model loading
         * 7. Model splitting for progressive loading
         */

        // Scene setup
        const scene = new THREE.Scene();
        
        // Add lighting setup
        function setupLighting() {
            // Ambient light for overall scene brightness
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Main directional light (sun-like) - increased intensity and angled position
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.6); // Doubled intensity from 0.8 to 1.6
            mainLight.position.set(10, 8, -5); // Angled position with offset
            mainLight.castShadow = true;
            
            // Configure shadow properties
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -10;
            mainLight.shadow.camera.right = 10;
            mainLight.shadow.camera.top = 10;
            mainLight.shadow.camera.bottom = -10;
            scene.add(mainLight);

            // Secondary directional light (fill light) - adjusted to complement main light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4); // Slightly increased fill light
            fillLight.position.set(-8, 4, 8); // Adjusted position to balance main light
            scene.add(fillLight);

            // Hemisphere light for more natural outdoor lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // Add subtle point lights for detail enhancement
            const pointLight1 = new THREE.PointLight(0xffffff, 0.3);
            pointLight1.position.set(0, 5, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffffff, 0.3);
            pointLight2.position.set(0, -5, 0);
            scene.add(pointLight2);

            // Store lights in state for potential updates
            state.lights = {
                ambient: ambientLight,
                main: mainLight,
                fill: fillLight,
                hemisphere: hemiLight,
                point1: pointLight1,
                point2: pointLight2
            };
        }

        // Add grid helper
        const gridSize = 20;
        const gridDivisions = 20;
        const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x000000, 0x000000);
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // Initialize lighting
        setupLighting();

        // Check if device is mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Try to detect NVIDIA GPU specifically before renderer creation
        let hasNvidiaGPU = false;
        try {
            const testCanvas = document.createElement('canvas');
            const testContext = testCanvas.getContext('webgl', {powerPreference: 'high-performance'});
            if (testContext) {
                const debugInfo = testContext.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = testContext.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    hasNvidiaGPU = renderer && (renderer.toLowerCase().includes('nvidia') || 
                                               renderer.toLowerCase().includes('geforce') || 
                                               renderer.toLowerCase().includes('quadro'));
                    console.log("GPU detection:", renderer, hasNvidiaGPU ? "NVIDIA detected" : "NVIDIA not detected");
                }
            }
        } catch (e) {
            console.warn("Error during pre-renderer GPU detection:", e);
        }
        
        // Unit for measurements - with calibration for real-world units
        let currentUnit = 1.0; // Will be adjusted after model loading
        let unitLabel = "m"; // Display label in meters
        let calibrationHeight = 4.28; // Assumed height in meters
        
        // Control states
        let isOrthographic = false;
        
        // Measurement control states
        let isMeasureMode = false;
        let isPathMeasureMode = false;
        let pathMeasurementPoints = [];
        let pathMeasurementLines = [];
        let pathMeasurementLabels = [];
        let pathTotalDistance = 0;
        let pathTotalLabel = null;
        
        // Set up both cameras
        const perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const orthographicCamera = new THREE.OrthographicCamera(
            window.innerWidth / -100, 
            window.innerWidth / 100, 
            window.innerHeight / 100, 
            window.innerHeight / -100, 
            0.1, 
            1000
        );
        
        // Start with perspective camera
        let camera = perspectiveCamera;
        
        // Create renderer with strong hints for high-performance GPU
        const rendererOptions = {
            canvas: document.getElementById('viewer'), 
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance',
            failIfMajorPerformanceCaveat: false, // Allow fallback to software rendering
            preserveDrawingBuffer: true
        };
        
        // If we know we have NVIDIA, add more aggressive settings
        if (hasNvidiaGPU) {
            console.log("Using aggressive settings for NVIDIA GPU");
            rendererOptions.precision = 'highp';
        }
        
        let renderer;
        
        // Let THREE.js handle WebGL context creation
        try {
            console.log("Creating WebGL renderer");
            renderer = new THREE.WebGLRenderer(rendererOptions);
            console.log("Successfully created WebGL renderer");
            
            // Enable shadow mapping
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
        } catch (e) {
            console.error("Failed to create WebGL renderer:", e);
            // Show a friendly error message
            const errorDiv = document.createElement('div');
            errorDiv.style.position = 'absolute';
            errorDiv.style.top = '50%';
            errorDiv.style.left = '50%';
            errorDiv.style.transform = 'translate(-50%, -50%)';
            errorDiv.style.background = 'rgba(220,0,0,0.8)';
            errorDiv.style.color = 'white';
            errorDiv.style.padding = '20px';
            errorDiv.style.borderRadius = '5px';
            errorDiv.style.maxWidth = '400px';
            errorDiv.style.textAlign = 'center';
            errorDiv.style.zIndex = '2000';
            errorDiv.innerHTML = `
                <h3>WebGL Not Available</h3>
                <p>Your browser does not support WebGL or it is disabled.</p>
                <p>Please try a different browser or enable WebGL in your browser settings.</p>
                <p>For Chrome: chrome://settings/system → Use hardware acceleration when available</p>
                <p>For Firefox: about:config → webgl.force-enabled = true</p>
            `;
            document.body.appendChild(errorDiv);
            throw new Error("WebGL not available, stopping script execution.");
        }
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xeeeeee); // Changed from 0xf5f5f5 to 0xeeeeee for a slightly darker gray
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Force renderer to use all available functionality
        renderer.outputEncoding = THREE.sRGBEncoding;
        // Reduce precision if we're in software mode for better performance
        if (renderer.capabilities.precision === 'lowp') {
            renderer.precision = 'lowp';
        }
        
        // Check GPU and renderer info
        const gl = renderer.getContext();
        
        // Create GPU info section
        const gpuInfoSection = document.createElement('div');
        gpuInfoSection.id = 'gpu-info-section';
        debugConsole.appendChild(gpuInfoSection);

        // Create hierarchy section
        const hierarchySection = document.createElement('div');
        hierarchySection.id = 'hierarchy-section';
        hierarchySection.style.marginTop = '12px';
        debugConsole.appendChild(hierarchySection);
        
        // Function to get GPU info (update gpuInfoSection instead of gpuInfoDisplay)
        function getGPUInfo() {
            // Simplified function that only returns basic GPU info without displaying it
            try {
                const renderer = gl.getParameter(gl.RENDERER);
                const vendor = gl.getParameter(gl.VENDOR);
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                let unmaskedRenderer, unmaskedVendor;
                
                if (debugInfo) {
                    unmaskedRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    unmaskedVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                }
                
                const isSoftwareRendering = 
                    (unmaskedRenderer && (
                        unmaskedRenderer.includes('SwiftShader') || 
                        unmaskedRenderer.includes('llvmpipe') ||
                        unmaskedRenderer.includes('Software') ||
                        unmaskedRenderer.includes('Microsoft Basic Render')
                    )) ||
                    (renderer && (
                        renderer.includes('SwiftShader') ||
                        renderer.includes('llvmpipe') ||
                        renderer.includes('Software') ||
                        renderer.includes('Microsoft Basic Render')
                    ));
                
                const isAccelerated = !isSoftwareRendering;
                const isWebGL2 = gl instanceof WebGL2RenderingContext;
                
                // Log detailed info to console for debugging only
                console.log('GPU INFO:', {
                    renderer, vendor, unmaskedRenderer, unmaskedVendor,
                    isAccelerated, isSoftwareRendering,
                    webglVersion: isWebGL2 ? '2.0' : '1.0'
                });
                
                return {
                    renderer: unmaskedRenderer || renderer,
                    vendor: unmaskedVendor || vendor,
                    isAccelerated,
                    webglVersion: isWebGL2 ? '2.0' : '1.0'
                };
            } catch (err) {
                console.error('Error getting GPU info:', err);
                return null;
            }
        }
        
        // Run GPU detection but don't display results
        const gpuInfo = getGPUInfo();
        
        // Label renderer
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Add orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        setupControls();
        
        // Model bounds for orthographic sizing
        let modelSize = new THREE.Vector3(10, 10, 10);
        let modelCenter = new THREE.Vector3(0, 0, 0);

        // Add visual helpers
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // UI Controls
        let currentMesh = null;
        let isWireframe = false;
        let isGridAxesVisible = true;
        let viewMode = 1; // 0: solid, 1: transparent, 2: wireframe - default to transparent
        
        // Performance options
        let isHighPerformanceMode = true; // Start in high performance mode
        let showBoundingBox = false;
        let boxHelper = null;
        let enableDynamicLighting = false; // Disable dynamic lighting by default for performance
        let hierarchyContainer = null; // Declare at global scope
        
        // Add performance control button
        const perfModeBtn = document.createElement('button');
        perfModeBtn.textContent = 'High Performance';
        perfModeBtn.style.position = 'absolute';
        perfModeBtn.style.top = '50px';
        perfModeBtn.style.left = '10px';
        perfModeBtn.style.padding = '5px 10px';
        perfModeBtn.style.backgroundColor = '#4CAF50';
        perfModeBtn.style.color = 'white';
        perfModeBtn.style.border = 'none';
        perfModeBtn.style.borderRadius = '3px';
        perfModeBtn.style.cursor = 'pointer';
        perfModeBtn.style.zIndex = '1000';
        document.body.appendChild(perfModeBtn);
        
        perfModeBtn.addEventListener('click', () => {
            isHighPerformanceMode = !isHighPerformanceMode;
            perfModeBtn.textContent = isHighPerformanceMode ? 'High Performance' : 'High Quality';
            perfModeBtn.style.backgroundColor = isHighPerformanceMode ? '#4CAF50' : '#ff9800';
            
            // Apply performance optimizations
            applyPerformanceSettings();
        });
        
        function applyPerformanceSettings() {
            if (isHighPerformanceMode) {
                // High performance settings
                renderer.setPixelRatio(1); // Lower pixel ratio
                if (boxHelper) boxHelper.visible = false;
                if (hierarchyContainer) hierarchyContainer.style.display = 'none';
                
                // Simplify materials for better performance
                if (currentMesh) {
                    currentMesh.traverse(function(obj) {
                        if (obj.isMesh && obj.material) {
                            const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                            materials.forEach(material => {
                                // Use simpler materials for better performance
                                material.flatShading = true;
                                material.needsUpdate = true;
                            });
                        }
                    });
                }
            } else {
                // High quality settings
                renderer.setPixelRatio(window.devicePixelRatio);
                if (boxHelper) boxHelper.visible = showBoundingBox;
                
                // Restore materials
                if (currentMesh) {
                    currentMesh.traverse(function(obj) {
                        if (obj.isMesh && obj.material) {
                            const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                            materials.forEach(material => {
                                material.flatShading = false;
                                material.needsUpdate = true;
                            });
                        }
                    });
                }
            }
        }
        
        // Raycaster and mouse position tracking with debounce for better performance
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let raycastDebounce = null;
        
        // Measurement variables
        let measurementGroup = new THREE.Group();
        scene.add(measurementGroup);
        let measurements = [];
        let measurementPoints = [];
        let measurementLabels = [];
        let previewLine = null;
        let previewBackgroundLine = null;
        let previewLabel = null;
        
        // Debug visualization
        let rayVisualization = null;

        /**
         * Function to update orthographic camera settings
         * This was missing and causing the ReferenceError
         */
        function updateOrthographicCamera() {
            if (!modelSize) return;
            
            const aspect = window.innerWidth / window.innerHeight;
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const padding = 1.2; // Add some padding around the model
            
            // Set the orthographic camera dimensions based on model size
            orthographicCamera.left = -maxDim * padding * aspect;
            orthographicCamera.right = maxDim * padding * aspect;
            orthographicCamera.top = maxDim * padding;
            orthographicCamera.bottom = -maxDim * padding;
            
            // Update near and far planes based on model position
            orthographicCamera.near = 0.01;
            orthographicCamera.far = maxDim * 10;
            
            orthographicCamera.updateProjectionMatrix();
            controls.update();
        }
        
        /**
         * Function to set different standard views
         */
        function setViewTop() {
            if (state.isTransitioning) return;
            
            const distance = Math.max(modelSize.x, modelSize.z) * 1.5;
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPosition = new THREE.Vector3(0, distance, 0);
            const endTarget = modelCenter.clone();
            
            animateCameraTransition(startPosition, endPosition, startTarget, endTarget, () => {
                camera.up.set(0, 0, -1);
                controls.update();
                state.inPredefinedView = true;
            });
        }
        
        function setViewFront() {
            if (state.isTransitioning) return;
            
            const distance = Math.max(modelSize.x, modelSize.y) * 1.5;
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPosition = new THREE.Vector3(0, 0, distance);
            const endTarget = modelCenter.clone();
            
            animateCameraTransition(startPosition, endPosition, startTarget, endTarget, () => {
                camera.up.set(0, 1, 0);
                controls.update();
                state.inPredefinedView = true;
            });
        }
        
        function setViewLeft() {
            if (state.isTransitioning) return;
            
            const distance = Math.max(modelSize.y, modelSize.z) * 1.5;
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPosition = new THREE.Vector3(distance, 0, 0);
            const endTarget = modelCenter.clone();
            
            animateCameraTransition(startPosition, endPosition, startTarget, endTarget, () => {
                camera.up.set(0, 1, 0);
                controls.update();
                state.inPredefinedView = true;
            });
        }
        
        function setViewIso() {
            if (state.isTransitioning) return;
            
            const distance = Math.max(modelSize.x, modelSize.y, modelSize.z) * 1.5;
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPosition = new THREE.Vector3(distance, distance, distance);
            const endTarget = modelCenter.clone();
            
            animateCameraTransition(startPosition, endPosition, startTarget, endTarget, () => {
                camera.up.set(0, 1, 0);
                controls.update();
                state.inPredefinedView = true;
            });
        }

        function animateCameraTransition(startPosition, endPosition, startTarget, endTarget, onComplete) {
            state.isTransitioning = true;
            const startTime = Date.now();
            const duration = 1000; // 1 second transition
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease in-out function
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                camera.position.lerpVectors(startPosition, endPosition, easeProgress);
                controls.target.lerpVectors(startTarget, endTarget, easeProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    state.isTransitioning = false;
                    if (onComplete) onComplete();
                }
                
                state.needsRender = true;
            }
            
            animate();
        }

        /**
         * Optimized GLTF Loading Function
         * Server-side optimizations:
         * 1. Using GLB binary format instead of GLTF
         * 2. Implementing Draco mesh compression
         * 3. Adding progress tracking
         * 4. Model caching for subsequent loads
         */
        async function loadGLTFModel() {
            try {
                cleanupResources(); // Clean up before loading new model
                
                document.getElementById('loadingDetails').textContent = 'Initializing loaders...';
                document.getElementById('loadingBar').style.width = '5%';
                
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/draco/');
                dracoLoader.setDecoderConfig({ type: 'js' });
                
                const loader = new GLTFLoader();
                loader.setCrossOrigin('anonymous');
                loader.setDRACOLoader(dracoLoader);

                // Add texture loading manager
                const textureLoader = new THREE.TextureLoader();
                const loadingManager = new THREE.LoadingManager();
                
                // Track texture loading progress
                loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
                    const progress = (itemsLoaded / itemsTotal) * 100;
                    document.getElementById('loadingDetails').textContent = `Loading textures: ${Math.round(progress)}%`;
                    document.getElementById('loadingBar').style.width = `${Math.min(90, 10 + progress * 0.8)}%`;
                };

                // Handle texture loading errors
                loadingManager.onError = (url) => {
                    console.error('Error loading texture:', url);
                    showErrorToUser(`Failed to load texture: ${url}`);
                };

                // Configure texture loader with manager
                textureLoader.manager = loadingManager;
                
                document.getElementById('loadingDetails').textContent = 'Fetching optimized GLB model...';
                document.getElementById('loadingBar').style.width = '10%';
                
                const modelPath = 'https://deepgis.org/static/deepgis/models/gltf/navagunjara-reborn-digital-twin-propane-and-solar-v4.glb';
                
                const modelResponse = await fetch(modelPath, { 
                    credentials: 'omit',
                    mode: 'cors' 
                });
                
                if (!modelResponse.ok) {
                    throw new Error(`Failed to fetch model: ${modelResponse.status} ${modelResponse.statusText}`);
                }
                
                const modelData = await modelResponse.arrayBuffer();
                
                const gltf = await new Promise((resolve, reject) => {
                    loader.parse(
                        modelData,
                        '',
                        resolve,
                        reject
                    );
                });
                
                document.getElementById('loadingDetails').textContent = 'Processing model and textures...';
                document.getElementById('loadingBar').style.width = '95%';
                
                const mesh = gltf.scene;
                if (!mesh) {
                    throw new Error('No objects found in GLTF model scene');
                }

                // Process textures and materials
                mesh.traverse((object) => {
                    if (object.isMesh) {
                        // Enable shadows
                        object.castShadow = true;
                        object.receiveShadow = true;
                        
                        const materials = Array.isArray(object.material) ? object.material : [object.material];
                        materials.forEach(material => {
                            // Enable texture anisotropy if supported
                            if (material.map) {
                                material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                material.map.minFilter = THREE.LinearMipmapLinearFilter;
                                material.map.magFilter = THREE.LinearFilter;
                                material.map.needsUpdate = true;
                            }
                            
                            // Set material properties for better texture rendering
                            material.needsUpdate = true;
                            material.side = THREE.DoubleSide;
                            
                            // Enable transparency if needed
                            if (material.transparent) {
                                material.depthWrite = false;
                            }
                            
                            // Enable shadows in material
                            material.shadowSide = THREE.FrontSide;
                        });
                    }
                });
                
                state.currentMesh = mesh;
                scene.add(mesh);
                
                // Compute bounding box and center
                const boundingBox = new THREE.Box3().setFromObject(mesh);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const center = new THREE.Vector3();
                boundingBox.getCenter(center);
                
                state.updateModelDimensions(size, center);
                
                // Update camera and controls
                updateOrthographicCamera();
                controls.target.copy(center);
                controls.update();

                // Set default view to isometric with closer zoom and lower angle
                const distance = Math.max(size.x, size.y, size.z) * 0.4; // Reduced from 0.5 to 0.4 for even closer zoom
                camera.position.set(distance, distance * 0.7, distance); // Lowered the Y position to 70% of the distance
                camera.up.set(0, 1, 0);
                controls.target.copy(center);
                controls.update();

                // Update UI to show only dimensions
                const dimensionsText = `Dimensions: ${size.x.toFixed(2)} × ${size.y.toFixed(2)} × ${size.z.toFixed(2)} meters`;
                document.getElementById('modelDimensions').textContent = dimensionsText;
                document.getElementById('modelCalibration').textContent = '';

                // For measurements, use 1:1 (no calibration)
                state.currentUnit = 1.0;
                state.unitLabel = 'm';

                // Complete loading
                document.getElementById('loadingBar').style.width = '100%';
                document.getElementById('loading').style.display = 'none';
                
                state.needsRender = true;

                // Update hierarchy display after model is loaded
                updateHierarchyDisplay();

                // Initialize unit selector with default value
                document.getElementById('unitSelector').value = 'm';

            } catch (error) {
                console.error('Error loading GLTF model:', error);
                document.getElementById('loadingDetails').textContent = 'Error loading model. Please try refreshing.';
                document.getElementById('loadingBar').style.backgroundColor = '#f44336';
                showErrorToUser('Failed to load 3D model. Please refresh the page.');
                cleanupResources();
            }
        }

        // Unit conversion helper
        function convertUnit(meters, targetUnit) {
            switch (targetUnit) {
                case 'm':
                    return { value: meters, label: 'm' };
                case 'cm':
                    return { value: meters * 100, label: 'cm' };
                case 'ft':
                    return { value: meters * 3.28084, label: 'ft' };
                case 'in':
                    return { value: meters * 39.3701, label: 'in' };
                default:
                    return { value: meters, label: 'm' };
            }
        }

        // Track completed paths
        let completedPaths = [];
        let currentPathId = 1;
        let isRotationKeyPressed = false;

        // Function to finish current path - will close it if possible, then complete it
        function finishPath() {
            // Only do something if we're in path measure mode and have at least 2 points
            if (!state.isPathMeasureMode || state.pathMeasurementPoints.length < 2) {
                if (!state.isPathMeasureMode) {
                    showToast('Path measure mode not active');
                } else {
                    showToast('Need at least 2 points to finish a path');
                }
                return;
            }
            
            // If we have 3 or more points, we can close the path by connecting last to first
            if (state.pathMeasurementPoints.length >= 3) {
                const firstPoint = state.pathMeasurementPoints[0];
                const lastPoint = state.pathMeasurementPoints[state.pathMeasurementPoints.length - 1];
                
                // Calculate segment distance
                const segmentDistance = lastPoint.distanceTo(firstPoint);
                const scaledDistance = segmentDistance * state.currentUnit;
                
                // Create line between points
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([lastPoint, firstPoint]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xe91e63, linewidth: 2 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                
                // Create background line for better visibility
                const bgLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 4 });
                const bgLine = new THREE.Line(lineGeometry.clone(), bgLineMaterial);
                
                // Add lines to measurement group
                measurementGroup.add(bgLine);
                measurementGroup.add(line);
                state.pathMeasurementLines.push({ line, bgLine });
                
                // Create segment label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'distance-label';
                labelDiv.style.padding = '2px 6px';
                labelDiv.style.borderRadius = '2px';
                labelDiv.style.background = 'rgba(233,30,99,0.9)';
                labelDiv.style.color = 'white';
                labelDiv.style.fontFamily = 'Arial, sans-serif';
                labelDiv.style.fontSize = '10px';
                labelDiv.textContent = `${scaledDistance.toFixed(2)} ${state.unitLabel}`;
                labelDiv.style.whiteSpace = 'nowrap';
                
                const labelObj = new CSS2DObject(labelDiv);
                
                // Position label at midpoint
                const midpoint = new THREE.Vector3().addVectors(lastPoint, firstPoint).multiplyScalar(0.5);
                labelObj.position.copy(midpoint);
                scene.add(labelObj);
                state.pathMeasurementLabels.push(labelObj);
                
                // Add to global measurement labels array for tracking
                measurementLabels.push(labelObj);
                
                // Update total distance
                state.pathTotalDistance += segmentDistance;
                
                // Update total label
                if (pathTotalLabel) {
                    pathTotalLabel.element.innerHTML = `Total: ${(state.pathTotalDistance * state.currentUnit).toFixed(2)} ${state.unitLabel} (closed)`;
                    pathTotalLabel.position.copy(firstPoint);
                }
                
                showToast('Path closed and completed');
            } else {
                showToast('Path completed');
            }
            
            // Clean up preview elements
            cleanupPreviewElements();
            
            // Create a complete path object
            const completedPath = {
                id: currentPathId,
                points: [...state.pathMeasurementPoints], // Clone the points array
                totalDistance: state.pathTotalDistance,
                lines: state.pathMeasurementLines.map(line => ({ line: line.line, bgLine: line.bgLine })),
                labels: [...state.pathMeasurementLabels]
            };
            
            // Add to completed paths
            completedPaths.push(completedPath);
            
            // Increment the path ID
            currentPathId++;
            
            // Prepare for a new path but keep visual elements visible
            state.pathMeasurementPoints = [];
            state.pathMeasurementLines = [];
            state.pathMeasurementLabels = [];
            state.pathTotalDistance = 0;
            
            // Hide the total label until we start a new path
            if (pathTotalLabel) {
                pathTotalLabel.visible = false;
            }
            
            // Update the measurements display
            updateMeasurementsDisplay();
            
            state.needsRender = true;
        }

        // Function to cancel in-progress path measurement
        function cancelInProgressPathMeasurement() {
            // If we haven't started a new path or only have one point, completely cancel
            if (state.pathMeasurementPoints.length <= 1) {
                clearAllMeasurements();
                return;
            }
            
            // If we have multiple points, just remove the last one (in-progress point)
            if (state.pathMeasurementPoints.length > 0) {
                // Remove the last point
                state.pathMeasurementPoints.pop();
                
                // Remove the last line segment if it exists
                if (state.pathMeasurementLines.length > 0) {
                    const lastLine = state.pathMeasurementLines.pop();
                    measurementGroup.remove(lastLine.line);
                    measurementGroup.remove(lastLine.bgLine);
                }
                
                // Remove the corresponding label
                if (state.pathMeasurementLabels.length > 0) {
                    const lastLabel = state.pathMeasurementLabels.pop();
                    scene.remove(lastLabel);
                    
                    // Also remove from global tracking array
                    const labelIndex = measurementLabels.indexOf(lastLabel);
                    if (labelIndex !== -1) {
                        measurementLabels.splice(labelIndex, 1);
                    }
                }
                
                // Update total distance by recalculating from remaining points
                state.pathTotalDistance = 0;
                for (let i = 0; i < state.pathMeasurementPoints.length - 1; i++) {
                    state.pathTotalDistance += state.pathMeasurementPoints[i].distanceTo(state.pathMeasurementPoints[i + 1]);
                }
                
                // Update the total label
                if (pathTotalLabel && state.pathMeasurementPoints.length > 0) {
                    const convertedTotal = state.pathTotalDistance * state.currentUnit;
                    pathTotalLabel.element.innerHTML = `Total: ${convertedTotal.toFixed(2)} ${state.unitLabel}`;
                    // Position at the last point
                    pathTotalLabel.position.copy(state.pathMeasurementPoints[state.pathMeasurementPoints.length - 1]);
                    pathTotalLabel.visible = true;
                } else if (pathTotalLabel) {
                    pathTotalLabel.visible = false;
                }
                
                // Force a render
                state.needsRender = true;
                
                showToast('Removed last point');
            }
        }

        // Add event listener for unit selector
        document.getElementById('unitSelector').addEventListener('change', function(event) {
            const newUnit = event.target.value;
            const conversionResult = convertUnit(1.0, newUnit); // 1 meter to new unit
            state.currentUnit = conversionResult.value;
            state.unitLabel = conversionResult.label;
            
            // Update existing measurement displays
            updateAllMeasurementUnits();
            
            // Update UI
            updateMeasurementsDisplay();
            
            showToast(`Units changed to ${conversionResult.label}`);
        });

        // Add event listener for complete path button
        //Removed reference to completePathBtn as it's now handled by finishPathBtn
        
        // Function to clean up preview elements
        function cleanupPreviewElements() {
            if (previewLine) {
                if (previewLine.geometry) previewLine.geometry.dispose();
                if (previewLine.material) previewLine.material.dispose();
                measurementGroup.remove(previewLine);
                previewLine = null;
            }
            
            if (previewBackgroundLine) {
                if (previewBackgroundLine.geometry) previewBackgroundLine.geometry.dispose();
                if (previewBackgroundLine.material) previewBackgroundLine.material.dispose();
                measurementGroup.remove(previewBackgroundLine);
                previewBackgroundLine = null;
            }
            
            if (previewLabel) {
                scene.remove(previewLabel);
                previewLabel = null;
            }
            
            state.needsRender = true;
        }

        // Enhance rotation key handling for measurements
        let previousRotateState = true;
        document.addEventListener('keydown', function(event) {
            // 'M' key for measure mode
            if (event.key === 'm' || event.key === 'M') {
                state.toggleMeasureMode();
                showToast(`Measure mode: ${state.isMeasureMode ? 'Enabled' : 'Disabled'}`);
                if (state.isMeasureMode) {
                    document.body.style.cursor = 'crosshair';
                    previousRotateState = controls.enableRotate;
                    controls.enableRotate = false;
                } else {
                    document.body.style.cursor = 'default';
                    controls.enableRotate = previousRotateState;
                    cleanupPreviewElements();
                }
            }
            
            // 'P' key for path measure mode
            if (event.key === 'p' || event.key === 'P') {
                state.togglePathMeasureMode();
                showToast(`Path measure mode: ${state.isPathMeasureMode ? 'Enabled' : 'Disabled'}`);
                if (state.isPathMeasureMode) {
                    document.body.style.cursor = 'crosshair';
                    previousRotateState = controls.enableRotate;
                    controls.enableRotate = false;
                    
                    // Initialize total distance label if not exists
                    if (!pathTotalLabel) {
                        const totalDiv = document.createElement('div');
                        totalDiv.className = 'distance-label';
                        totalDiv.style.padding = '4px 8px';
                        totalDiv.style.borderRadius = '2px';
                        totalDiv.style.background = 'rgba(0,0,0,0.7)';
                        totalDiv.style.color = 'white';
                        totalDiv.style.fontFamily = 'Arial, sans-serif';
                        totalDiv.style.fontSize = '12px';
                        totalDiv.style.fontWeight = 'bold';
                        totalDiv.innerHTML = 'Total: 0.00 m';
                        totalDiv.style.whiteSpace = 'nowrap';
                        
                        const totalLabelObject = new CSS2DObject(totalDiv);
                        totalLabelObject.position.set(0, 0, 0);
                        totalLabelObject.visible = false;
                        scene.add(totalLabelObject);
                        
                        pathTotalLabel = totalLabelObject;
                    }
                } else {
                    document.body.style.cursor = 'default';
                    controls.enableRotate = previousRotateState;
                    if (pathTotalLabel) {
                        pathTotalLabel.visible = false;
                    }
                    state.pathMeasurementPoints = [];
                    state.pathTotalDistance = 0;
                    cleanupPreviewElements();
                }
            }
            
            // 'Escape' key to exit any measurement mode
            if (event.key === 'Escape') {
                if (state.isPathMeasureMode && state.pathMeasurementPoints.length > 0) {
                    // Only cancel the in-progress path measurement
                    cancelInProgressPathMeasurement();
                } else if (state.isMeasureMode || state.isPathMeasureMode) {
                    state.isMeasureMode = false;
                    state.isPathMeasureMode = false;
                    document.body.style.cursor = 'default';
                    controls.enableRotate = previousRotateState;
                    showToast('Measurement mode disabled');
                    
                    cleanupPreviewElements();
                    
                    if (pathTotalLabel) {
                        pathTotalLabel.visible = false;
                    }
                    
                    state.needsRender = true;
                }
            }
            
            // 'C' key to clear measurements
            if (event.key === 'c' || event.key === 'C') {
                clearAllMeasurements();
                showToast('Measurements cleared');
            }
            
            // 'F' key to complete current path
            if (event.key === 'f' || event.key === 'F') {
                finishPath();
            }
            
            // 'L' key to close current path (connect first and last points)
            if (event.key === 'l' || event.key === 'L') {
                finishPath();
            }
            
            // 'O' key to toggle orthographic view
            if (event.key === 'o' || event.key === 'O') {
                if (state.toggleOrthographic()) {
                    camera = state.isOrthographic ? orthographicCamera : perspectiveCamera;
                    controls.object = camera;
                    updateOrthographicCamera();
                    showToast(`Camera mode: ${state.isOrthographic ? 'Orthographic' : 'Perspective'}`);
                }
            }
            
            // 'G' key to toggle grid & axes
            if (event.key === 'g' || event.key === 'G') {
                if (state.toggleGridAxes()) {
                    showToast(`Grid & Axes: ${state.isGridAxesVisible ? 'Visible' : 'Hidden'}`);
                }
            }
            
            // 'V' key to toggle view mode
            if (event.key === 'v' || event.key === 'V') {
                const newMode = (state.viewMode + 1) % 3;
                if (state.setViewMode(newMode)) {
                    showToast(`View mode: ${['Solid', 'Transparent', 'Wireframe'][newMode]}`);
                }
            }
            
            // Number keys for standard views
            if (event.key === '1') {
                if (state.setPredefinedView('iso')) {
                    showToast('Isometric view');
                }
            }
            if (event.key === '2') {
                if (state.setPredefinedView('top')) {
                    showToast('Top view');
                }
            }
            if (event.key === '3') {
                if (state.setPredefinedView('front')) {
                    showToast('Front view');
                }
            }
            if (event.key === '4') {
                if (state.setPredefinedView('left')) {
                    showToast('Left view');
                }
            }
            
            // Space bar for rotation while measuring
            if (event.key === ' ') {
                isRotationKeyPressed = true;
                if (state.isMeasureMode || state.isPathMeasureMode) {
                    controls.enableRotate = true;
                }
                event.preventDefault(); // Prevent page scrolling
            }
        });

        // Improved keyup listener for rotation key
        document.addEventListener('keyup', function(event) {
            if (event.key === ' ') { // Space key
                isRotationKeyPressed = false;
                if ((state.isMeasureMode || state.isPathMeasureMode) && !controls.enableRotate) {
                    controls.enableRotate = false; // Restore to disabled state
                }
            }
        });

        // Function to update all measurement units with improved preview handling
        function updateAllMeasurementUnits() {
            // Update regular measurement labels
            for (const measurement of state.measurements) {
                const meterDistance = measurement.points[0].distanceTo(measurement.points[1]);
                const convertedDistance = meterDistance * state.currentUnit;
                measurement.distance = convertedDistance;
                measurement.label.element.textContent = `${convertedDistance.toFixed(2)} ${state.unitLabel}`;
            }
            
            // Update path measurement segment labels
            for (let i = 0; i < state.pathMeasurementLabels.length; i++) {
                if (i < state.pathMeasurementPoints.length - 1) {
                    const point1 = state.pathMeasurementPoints[i];
                    const point2 = state.pathMeasurementPoints[i + 1];
                    const meterDistance = point1.distanceTo(point2);
                    const convertedDistance = meterDistance * state.currentUnit;
                    state.pathMeasurementLabels[i].element.textContent = `${convertedDistance.toFixed(2)} ${state.unitLabel}`;
                }
            }
            
            // Update total path distance label
            if (pathTotalLabel && state.pathTotalDistance > 0) {
                const convertedTotal = state.pathTotalDistance * state.currentUnit;
                pathTotalLabel.element.innerHTML = `Total: ${convertedTotal.toFixed(2)} ${state.unitLabel}`;
            }
            
            // Update preview label if active
            if (previewLabel) {
                // Try to get the points being measured
                let distance;
                if (state.isMeasureMode && state.measurementPoints.length === 1 && previewLine) {
                    // Find where the preview line connects
                    const positions = previewLine.geometry.attributes.position.array;
                    const start = new THREE.Vector3(
                        positions[0], positions[1], positions[2]
                    );
                    const end = new THREE.Vector3(
                        positions[3], positions[4], positions[5]
                    );
                    distance = start.distanceTo(end) * state.currentUnit;
                    previewLabel.element.textContent = `${distance.toFixed(2)} ${state.unitLabel}`;
                } else if (state.isPathMeasureMode && state.pathMeasurementPoints.length > 0 && previewLine) {
                    // Similar logic for path preview
                    const positions = previewLine.geometry.attributes.position.array;
                    const start = new THREE.Vector3(
                        positions[0], positions[1], positions[2]
                    );
                    const end = new THREE.Vector3(
                        positions[3], positions[4], positions[5]
                    );
                    const segmentDistance = start.distanceTo(end) * state.currentUnit;
                    const totalDistance = (state.pathTotalDistance + start.distanceTo(end)) * state.currentUnit;
                    previewLabel.element.textContent = `${segmentDistance.toFixed(2)} ${state.unitLabel}`;
                    
                    if (pathTotalLabel) {
                        pathTotalLabel.element.innerHTML = `Total: ${totalDistance.toFixed(2)} ${state.unitLabel} (preview)`;
                    }
                }
            }
            
            state.needsRender = true;
        }

        // Initialize the viewer
        loadGLTFModel();
        animate();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            cleanupResources();
            window.removeEventListener('resize', boundResizeHandler);
            window.removeEventListener('orientationchange', boundResizeHandler);
        });

        // Resource cleanup function
        function cleanupResources() {
            if (state.currentMesh) {
                scene.remove(state.currentMesh);
                state.currentMesh.traverse((object) => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => {
                                // Dispose textures
                                if (material.map) material.map.dispose();
                                if (material.lightMap) material.lightMap.dispose();
                                if (material.bumpMap) material.bumpMap.dispose();
                                if (material.normalMap) material.normalMap.dispose();
                                if (material.specularMap) material.specularMap.dispose();
                                if (material.envMap) material.envMap.dispose();
                                if (material.aoMap) material.aoMap.dispose();
                                if (material.displacementMap) material.displacementMap.dispose();
                                if (material.emissiveMap) material.emissiveMap.dispose();
                                if (material.gradientMap) material.gradientMap.dispose();
                                if (material.alphaMap) material.alphaMap.dispose();
                                if (material.roughnessMap) material.roughnessMap.dispose();
                                if (material.metalnessMap) material.metalnessMap.dispose();
                                
                                // Dispose material
                                material.dispose();
                            });
                        } else {
                            // Dispose textures
                            if (object.material.map) object.material.map.dispose();
                            if (object.material.lightMap) object.material.lightMap.dispose();
                            if (object.material.bumpMap) object.material.bumpMap.dispose();
                            if (object.material.normalMap) object.material.normalMap.dispose();
                            if (object.material.specularMap) object.material.specularMap.dispose();
                            if (object.material.envMap) object.material.envMap.dispose();
                            if (object.material.aoMap) object.material.aoMap.dispose();
                            if (object.material.displacementMap) object.material.displacementMap.dispose();
                            if (object.material.emissiveMap) object.material.emissiveMap.dispose();
                            if (object.material.gradientMap) object.material.gradientMap.dispose();
                            if (object.material.alphaMap) object.material.alphaMap.dispose();
                            if (object.material.roughnessMap) object.material.roughnessMap.dispose();
                            if (object.material.metalnessMap) object.material.metalnessMap.dispose();
                            
                            // Dispose material
                            object.material.dispose();
                        }
                    }
                });
            }
            
            // Clean up measurement resources
            if (measurementGroup) {
                measurementGroup.traverse((object) => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
                scene.remove(measurementGroup);
            }

            // Clean up renderer
            if (renderer) {
                renderer.dispose();
            }

            // Reset state
            state.measurementPoints = [];
            state.pathMeasurementPoints = [];
            state.pathMeasurementLines = [];
            state.pathMeasurementLabels = [];
            state.pathTotalDistance = 0;
            state.measurements = [];

            // Recreate measurement group
            measurementGroup = new THREE.Group();
            scene.add(measurementGroup);
        }

        // Safe render function with error handling
        function safeRender() {
            try {
                if (state.needsRender) {
                    renderer.render(scene, camera);
                    // Always render labels if we have any type of measurements
                    // This was checking only measurementLabels which is incorrect
                    labelRenderer.render(scene, camera);
                    
                    // Debug logging - uncomment if needed to diagnose label issues
                    // console.log('Rendering labels - Regular measurements:', state.measurements.length, 
                    //             'Path labels:', state.pathMeasurementLabels.length,
                    //             'Total tracked:', measurementLabels.length);
                    
                    state.needsRender = true; // Force continuous rendering to ensure labels stay visible
                }
            } catch (error) {
                console.error('Render error:', error);
                showErrorToUser('Rendering error occurred. Please refresh the page.');
            }
        }

        // Add function to update light positions based on camera
        function updateLightPositions() {
            if (!state.lights) return;
            
            // Update main light to follow camera while maintaining angle
            const cameraPosition = camera.position.clone();
            const mainLightOffset = new THREE.Vector3(10, 8, -5); // Keep the angled offset
            state.lights.main.position.copy(cameraPosition).add(mainLightOffset);
            
            // Update fill light to be opposite to main light
            const fillLightOffset = new THREE.Vector3(-8, 4, 8); // Keep the complementary offset
            state.lights.fill.position.copy(cameraPosition).add(fillLightOffset);
            
            // Update hemisphere light to stay above scene
            state.lights.hemisphere.position.y = Math.max(20, cameraPosition.y + 10);
            
            // Update point lights to follow camera but maintain relative positions
            state.lights.point1.position.copy(cameraPosition);
            state.lights.point1.position.y += 5;
            
            state.lights.point2.position.copy(cameraPosition);
            state.lights.point2.position.y -= 5;
        }

        // Update the animate function to include light position updates
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.enabled) {
                controls.update();
                updateLightPositions(); // Update light positions based on camera movement
            }
            
            safeRender();
        }

        // Improved mobile support
        function handleOrientationChange() {
            const isLandscape = window.innerWidth > window.innerHeight;
            state.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
            
            // Update UI for mobile - keep debug elements hidden
            debugConsole.style.display = 'none';
            debugToggleBtn.style.display = 'none';
            
            // Update camera and renderer
            updateOrthographicCamera();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            
            state.needsRender = true;
        }

        // Add proper event listener cleanup
        const boundResizeHandler = handleOrientationChange.bind(this);
        window.addEventListener('resize', boundResizeHandler);
        window.addEventListener('orientationchange', boundResizeHandler);

        // Improved measurement point validation
        function validatePoint(point) {
            if (!point || !(point instanceof THREE.Vector3)) {
                console.error('Invalid point provided');
                return false;
            }
            
            // Check if point is within reasonable bounds
            const maxDistance = 1000; // Adjust based on your scene size
            if (Math.abs(point.x) > maxDistance || 
                Math.abs(point.y) > maxDistance || 
                Math.abs(point.z) > maxDistance) {
                console.error('Point is too far from origin');
                return false;
            }
            
            return true;
        }

        // Improved measurement point addition
        function addMeasurementPoint(point) {
            if (!validatePoint(point)) {
                showErrorToUser('Invalid measurement point');
                return;
            }
            
            // Add point marker
            const markerGroup = new THREE.Group();
            markerGroup.position.copy(point);
            
            // Create marker geometry
            const markerSize = 0.08;
            const markerGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-markerSize, 0, 0),
                new THREE.Vector3(markerSize, 0, 0),
                new THREE.Vector3(0, -markerSize, 0),
                new THREE.Vector3(0, markerSize, 0),
                new THREE.Vector3(0, 0, -markerSize),
                new THREE.Vector3(0, 0, markerSize)
            ]);
            
            const markerMaterial = new THREE.LineBasicMaterial({ color: 0x4caf50 });
            const marker = new THREE.LineSegments(markerGeometry, markerMaterial);
            markerGroup.add(marker);
            
            measurementGroup.add(markerGroup);
            state.measurementPoints.push(point);
            
            if (state.measurementPoints.length === 2) {
                createMeasurement(state.measurementPoints[0], state.measurementPoints[1]);
                state.measurementPoints = [];
            }
            
            state.needsRender = true;
        }

        // Error display function
        function showErrorToUser(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.position = 'fixed';
            errorDiv.style.top = '20px';
            errorDiv.style.left = '50%';
            errorDiv.style.transform = 'translateX(-50%)';
            errorDiv.style.backgroundColor = 'rgba(244, 67, 54, 0.9)';
            errorDiv.style.color = 'white';
            errorDiv.style.padding = '10px 20px';
            errorDiv.style.borderRadius = '5px';
            errorDiv.style.zIndex = '2000';
            errorDiv.textContent = message;
            
            document.body.appendChild(errorDiv);
            
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    document.body.removeChild(errorDiv);
                }
            }, 5000);
        }

        // Add setupControls function
        function setupControls() {
            try {
                // Orbit controls settings
                controls.enableDamping = true;
                controls.dampingFactor = 0.15;
                controls.screenSpacePanning = true;
                controls.minDistance = 0.5;
                controls.maxDistance = 100;
                controls.rotateSpeed = 0.8;
                controls.zoomSpeed = 1.0;
                controls.panSpeed = 0.8;
                controls.enableTouch = true;
                
                // Use standard orbit control configuration for Y-up world
                controls.minPolarAngle = 0;
                controls.maxPolarAngle = Math.PI;
                
                // Set mouse buttons
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.PAN,
                    RIGHT: THREE.MOUSE.PAN
                };
                
                controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                
                // Add events to detect when user starts rotating
                controls.addEventListener('start', () => {
                    if (state.inPredefinedView) {
                        state.inPredefinedView = false;
                    }
                });

                // Add error handling for control updates
                const originalUpdate = controls.update;
                controls.update = function() {
                    try {
                        originalUpdate.call(this);
                        // Update state with current camera position and target
                        state.cameraPosition.copy(camera.position);
                        state.cameraTarget.copy(controls.target);
                    } catch (error) {
                        console.error('Error updating controls:', error);
                        showErrorToUser('Error updating camera controls. Please refresh the page.');
                    }
                };

                // Add error handling for control changes
                controls.addEventListener('change', () => {
                    state.needsRender = true;
                });

                console.log('Controls setup complete');
            } catch (error) {
                console.error('Error setting up controls:', error);
                showErrorToUser('Error setting up camera controls. Please refresh the page.');
            }
        }

        // Update camera setup
        function setupCameras() {
            // Update aspect ratio for both cameras
            const aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();
            
            // Update orthographic camera frustum
            const frustumSize = Math.max(modelSize.x, modelSize.y, modelSize.z) * 1.5;
            orthographicCamera.left = -frustumSize * aspect;
            orthographicCamera.right = frustumSize * aspect;
            orthographicCamera.top = frustumSize;
            orthographicCamera.bottom = -frustumSize;
            orthographicCamera.updateProjectionMatrix();
            
            // Update current camera
            if (state.isOrthographic) {
                camera = orthographicCamera;
            } else {
                camera = perspectiveCamera;
            }
            
            // Update controls
            controls.object = camera;
            controls.update();
        }

        // Add event listeners for view mode buttons
        document.getElementById('toggleViewMode').addEventListener('click', () => {
            const newMode = (state.viewMode + 1) % 3;
            if (state.setViewMode(newMode)) {
                showToast(`View mode: ${['Solid', 'Transparent', 'Wireframe'][newMode]}`);
            }
        });

        document.getElementById('toggleOrtho').addEventListener('click', () => {
            if (state.toggleOrthographic()) {
                camera = state.isOrthographic ? orthographicCamera : perspectiveCamera;
                controls.object = camera;
                updateOrthographicCamera();
                showToast(`Camera mode: ${state.isOrthographic ? 'Orthographic' : 'Perspective'}`);
            }
        });

        document.getElementById('toggleGridAxes').addEventListener('click', () => {
            if (state.toggleGridAxes()) {
                showToast(`Grid & Axes: ${state.isGridAxesVisible ? 'Visible' : 'Hidden'}`);
            }
        });

        // Add event listeners for predefined views
        document.getElementById('viewTop').addEventListener('click', () => {
            if (state.setPredefinedView('top')) {
                showToast('Top view');
            }
        });

        document.getElementById('viewFront').addEventListener('click', () => {
            if (state.setPredefinedView('front')) {
                showToast('Front view');
            }
        });

        document.getElementById('viewLeft').addEventListener('click', () => {
            if (state.setPredefinedView('left')) {
                showToast('Left view');
            }
        });

        document.getElementById('viewIso').addEventListener('click', () => {
            if (state.setPredefinedView('iso')) {
                showToast('Isometric view');
            }
        });

        // Add event listeners for measurement buttons
        document.getElementById('measureMode').addEventListener('click', () => {
            state.toggleMeasureMode();
            showToast(`Measure mode: ${state.isMeasureMode ? 'Enabled' : 'Disabled'}`);
            if (state.isMeasureMode) {
                document.body.style.cursor = 'crosshair';
            } else {
                document.body.style.cursor = 'default';
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                if (previewBackgroundLine) {
                    measurementGroup.remove(previewBackgroundLine);
                    previewBackgroundLine = null;
                }
                if (previewLabel) {
                    scene.remove(previewLabel);
                    previewLabel = null;
                }
            }
        });

        document.getElementById('pathMeasureMode').addEventListener('click', () => {
            state.togglePathMeasureMode();
            showToast(`Path measure mode: ${state.isPathMeasureMode ? 'Enabled' : 'Disabled'}`);
            if (state.isPathMeasureMode) {
                document.body.style.cursor = 'crosshair';
                // Initialize total distance label
                if (!pathTotalLabel) {
                    const totalDiv = document.createElement('div');
                    totalDiv.className = 'distance-label';
                    totalDiv.style.padding = '4px 8px';
                    totalDiv.style.borderRadius = '2px';
                    totalDiv.style.background = 'rgba(0,0,0,0.7)';
                    totalDiv.style.color = 'white';
                    totalDiv.style.fontFamily = 'Arial, sans-serif';
                    totalDiv.style.fontSize = '12px';
                    totalDiv.style.fontWeight = 'bold';
                    totalDiv.innerHTML = 'Total: 0.00 m';
                    totalDiv.style.whiteSpace = 'nowrap';
                    
                    const totalLabelObject = new CSS2DObject(totalDiv);
                    totalLabelObject.position.set(0, 0, 0);
                    totalLabelObject.visible = false;
                    scene.add(totalLabelObject);
                    
                    pathTotalLabel = totalLabelObject;
                }
            } else {
                document.body.style.cursor = 'default';
                if (pathTotalLabel) {
                    pathTotalLabel.visible = false;
                }
                state.pathMeasurementPoints = [];
                state.pathTotalDistance = 0;
            }
        });

        document.getElementById('clearMeasurements').addEventListener('click', () => {
            clearAllMeasurements();
            showToast('Measurements cleared');
        });

        document.getElementById('finishPathBtn').addEventListener('click', () => {
            finishPath();
        });

        // Function to create a measurement between two points with improved cleanup
        function createMeasurement(point1, point2) {
            if (!validatePoint(point1) || !validatePoint(point2)) {
                return;
            }
            
            // Clean up preview elements first
            cleanupPreviewElements();
            
            // Calculate distance
            const distance = point1.distanceTo(point2);
            const scaledDistance = distance * state.currentUnit;
            
            // Create line between points
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x4caf50, linewidth: 2 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            // Create background line for better visibility
            const bgLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 4 });
            const bgLine = new THREE.Line(lineGeometry.clone(), bgLineMaterial);
            
            // Add lines to measurement group
            measurementGroup.add(bgLine);
            measurementGroup.add(line);
            
            // Create label
            const labelDiv = document.createElement('div');
            labelDiv.className = 'distance-label';
            labelDiv.style.padding = '2px 6px';
            labelDiv.style.borderRadius = '2px';
            labelDiv.style.background = 'rgba(76,175,80,0.9)';
            labelDiv.style.color = 'white';
            labelDiv.style.fontFamily = 'Arial, sans-serif';
            labelDiv.style.fontSize = '12px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.textContent = `${scaledDistance.toFixed(2)} ${state.unitLabel}`;
            labelDiv.style.whiteSpace = 'nowrap';
            
            const labelObj = new CSS2DObject(labelDiv);
            
            // Position label at midpoint
            const midpoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
            labelObj.position.copy(midpoint);
            scene.add(labelObj);
            
            // Add to measurements list for tracking
            state.measurements.push({
                points: [point1.clone(), point2.clone()],
                distance: scaledDistance,
                line: line,
                bgLine: bgLine,
                label: labelObj
            });
            
            // Add the label to measurement labels array for tracking
            measurementLabels.push(labelObj);
            
            // Update UI display
            updateMeasurementsDisplay();
            
            state.needsRender = true;
        }

        // Function to create a path measurement point
        function addPathMeasurementPoint(point) {
            if (!validatePoint(point)) {
                return;
            }
            
            // Add point marker
            const markerGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xe91e63 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(point);
            measurementGroup.add(marker);
            
            state.pathMeasurementPoints.push(point);
            
            // If we have at least two points, create a line segment
            if (state.pathMeasurementPoints.length >= 2) {
                const lastPoint = state.pathMeasurementPoints[state.pathMeasurementPoints.length - 2];
                const currentPoint = state.pathMeasurementPoints[state.pathMeasurementPoints.length - 1];
                
                // Calculate segment distance
                const segmentDistance = lastPoint.distanceTo(currentPoint);
                const scaledDistance = segmentDistance * state.currentUnit;
                
                // Create line between points
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([lastPoint, currentPoint]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xe91e63, linewidth: 2 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                
                // Create background line for better visibility
                const bgLineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 4 });
                const bgLine = new THREE.Line(lineGeometry.clone(), bgLineMaterial);
                
                // Add lines to measurement group
                measurementGroup.add(bgLine);
                measurementGroup.add(line);
                state.pathMeasurementLines.push({ line, bgLine });
                
                // Create segment label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'distance-label';
                labelDiv.style.padding = '2px 6px';
                labelDiv.style.borderRadius = '2px';
                labelDiv.style.background = 'rgba(233,30,99,0.9)';
                labelDiv.style.color = 'white';
                labelDiv.style.fontFamily = 'Arial, sans-serif';
                labelDiv.style.fontSize = '10px';
                labelDiv.textContent = `${scaledDistance.toFixed(2)} ${state.unitLabel}`;
                labelDiv.style.whiteSpace = 'nowrap';
                
                const labelObj = new CSS2DObject(labelDiv);
                
                // Position label at midpoint
                const midpoint = new THREE.Vector3().addVectors(lastPoint, currentPoint).multiplyScalar(0.5);
                labelObj.position.copy(midpoint);
                scene.add(labelObj);
                state.pathMeasurementLabels.push(labelObj);
                
                // Add to global measurement labels array for tracking
                measurementLabels.push(labelObj);
                
                // Update total distance
                state.pathTotalDistance += segmentDistance;
                
                // Update total label
                if (pathTotalLabel) {
                    pathTotalLabel.element.innerHTML = `Total: ${(state.pathTotalDistance * state.currentUnit).toFixed(2)} ${state.unitLabel}`;
                    pathTotalLabel.position.copy(currentPoint);
                    pathTotalLabel.visible = true;
                }
            }
            
            state.needsRender = true;
        }

        // Enhanced function to clear all measurements with proper disposal
        function clearAllMeasurements() {
            // Clear regular measurements
            for (const measurement of state.measurements) {
                // Properly dispose geometries and materials
                if (measurement.line) {
                    if (measurement.line.geometry) measurement.line.geometry.dispose();
                    if (measurement.line.material) measurement.line.material.dispose();
                    measurementGroup.remove(measurement.line);
                }
                
                if (measurement.bgLine) {
                    if (measurement.bgLine.geometry) measurement.bgLine.geometry.dispose();
                    if (measurement.bgLine.material) measurement.bgLine.material.dispose();
                    measurementGroup.remove(measurement.bgLine);
                }
                
                if (measurement.label) {
                    scene.remove(measurement.label);
                }
            }
            state.measurements = [];
            state.measurementPoints = [];
            
            // Clear measurement labels array
            measurementLabels = [];
            
            // Clear path measurements
            for (const { line, bgLine } of state.pathMeasurementLines) {
                if (line) {
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                    measurementGroup.remove(line);
                }
                
                if (bgLine) {
                    if (bgLine.geometry) bgLine.geometry.dispose();
                    if (bgLine.material) bgLine.material.dispose();
                    measurementGroup.remove(bgLine);
                }
            }
            
            for (const label of state.pathMeasurementLabels) {
                scene.remove(label);
            }
            
            // Clear preview elements
            cleanupPreviewElements();
            
            if (pathTotalLabel) {
                pathTotalLabel.visible = false;
            }
            
            // Reset state
            state.pathMeasurementPoints = [];
            state.pathMeasurementLines = [];
            state.pathMeasurementLabels = [];
            state.pathTotalDistance = 0;
            
            // Clear measurement points from the scene
            measurementGroup.children = measurementGroup.children.filter(child => {
                if (child.isMesh && child.geometry.type === 'SphereGeometry') {
                    child.geometry.dispose();
                    child.material.dispose();
                    return false;
                }
                return true;
            });
            
            // Update UI
            updateMeasurementsDisplay();
            
            state.needsRender = true;
        }

        // Function to update measurements display in the UI
        function updateMeasurementsDisplay() {
            const container = document.getElementById('measurements-container');
            if (!container) return;
            
            if (state.measurements.length === 0) {
                container.innerHTML = 'No measurements yet';
                return;
            }
            
            let html = '<ul style="list-style-type: none; padding-left: 0; margin-top: 5px;">';
            state.measurements.forEach((measurement, index) => {
                html += `<li style="margin-bottom: 5px;">
                    <span style="display: inline-block; width: 18px; height: 18px; background-color: #4caf50; 
                           border-radius: 50%; text-align: center; color: white; font-size: 10px; line-height: 18px; 
                           margin-right: 5px;">${index + 1}</span>
                    <span>${measurement.distance.toFixed(2)} ${state.unitLabel}</span>
                    <button class="delete-measurement" data-index="${index}" style="background: none; border: none; 
                             color: #f44336; cursor: pointer; font-size: 16px; float: right; padding: 0;">×</button>
                </li>`;
            });
            html += '</ul>';
            
            container.innerHTML = html;
            
            // Add event listeners for delete buttons
            document.querySelectorAll('.delete-measurement').forEach(button => {
                button.addEventListener('click', (event) => {
                    const index = parseInt(event.target.dataset.index);
                    if (index >= 0 && index < state.measurements.length) {
                        const measurement = state.measurements[index];
                        measurementGroup.remove(measurement.line);
                        measurementGroup.remove(measurement.bgLine);
                        scene.remove(measurement.label);
                        state.measurements.splice(index, 1);
                        updateMeasurementsDisplay();
                        state.needsRender = true;
                    }
                });
            });
        }

        // Mouse click handler for measurements with improved error handling
        renderer.domElement.addEventListener('click', function(event) {
            // Only proceed if in measure mode
            if (!state.isMeasureMode && !state.isPathMeasureMode) return;
            
            // Skip point placement if rotation key is pressed
            if (isRotationKeyPressed) return;
            
            event.preventDefault();
            
            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update the raycaster with the mouse position and camera
            raycaster.setFromCamera(mouse, camera);
            
            // If the current mesh exists, raycast against it
            if (state.currentMesh) {
                // Find all intersected objects
                const intersects = raycaster.intersectObject(state.currentMesh, true);
                
                // If we found an intersection
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    
                    // For regular measurements
                    if (state.isMeasureMode) {
                        addMeasurementPoint(intersect.point);
                    }
                    
                    // For path measurements
                    if (state.isPathMeasureMode) {
                        addPathMeasurementPoint(intersect.point);
                    }
                } else {
                    // No intersection found
                    showToast('No valid surface found at this point');
                }
            } else {
                showToast('No model loaded');
            }
        });

        // Mouse move handler for measurement preview
        renderer.domElement.addEventListener('mousemove', function(event) {
            // Only proceed if in measure mode and we have at least one point
            if ((!state.isMeasureMode || state.measurementPoints.length !== 1) && 
                (!state.isPathMeasureMode || state.pathMeasurementPoints.length === 0)) return;

            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Clear any existing raycast timeout
            if (raycastDebounce) clearTimeout(raycastDebounce);
            
            // Debounce raycasting for better performance
            raycastDebounce = setTimeout(() => {
                // Update the raycaster with the mouse position and camera
                raycaster.setFromCamera(mouse, camera);
                
                // Raycast against the current mesh
                if (state.currentMesh) {
                    const intersects = raycaster.intersectObject(state.currentMesh, true);
                    
                    if (intersects.length > 0) {
                        const hoverPoint = intersects[0].point;
                        
                        // For regular measurements - update preview line
                        if (state.isMeasureMode && state.measurementPoints.length === 1) {
                            const startPoint = state.measurementPoints[0];
                            
                            // Create or update preview line
                            if (!previewLine) {
                                const lineGeometry = new THREE.BufferGeometry().setFromPoints([startPoint, hoverPoint]);
                                const lineMaterial = new THREE.LineDashedMaterial({ 
                                    color: 0x4caf50, 
                                    dashSize: 0.2, 
                                    gapSize: 0.1 
                                });
                                previewLine = new THREE.Line(lineGeometry, lineMaterial);
                                previewLine.computeLineDistances();
                                
                                // Create background line for better visibility
                                const bgLineMaterial = new THREE.LineDashedMaterial({ 
                                    color: 0x000000, 
                                    dashSize: 0.2, 
                                    gapSize: 0.1,
                                    linewidth: 3
                                });
                                previewBackgroundLine = new THREE.Line(lineGeometry.clone(), bgLineMaterial);
                                previewBackgroundLine.computeLineDistances();
                                
                                measurementGroup.add(previewBackgroundLine);
                                measurementGroup.add(previewLine);
                            } else {
                                // Update existing line geometry
                                const positions = new Float32Array([
                                    startPoint.x, startPoint.y, startPoint.z,
                                    hoverPoint.x, hoverPoint.y, hoverPoint.z
                                ]);
                                previewLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                                previewLine.geometry.computeBoundingSphere();
                                previewLine.computeLineDistances();
                                
                                previewBackgroundLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions.slice(), 3));
                                previewBackgroundLine.geometry.computeBoundingSphere();
                                previewBackgroundLine.computeLineDistances();
                            }
                            
                            // Calculate and update distance label
                            const distance = startPoint.distanceTo(hoverPoint) * state.currentUnit;
                            
                            if (!previewLabel) {
                                const labelDiv = document.createElement('div');
                                labelDiv.className = 'distance-label';
                                labelDiv.style.padding = '2px 6px';
                                labelDiv.style.borderRadius = '2px';
                                labelDiv.style.background = 'rgba(76,175,80,0.7)';
                                labelDiv.style.color = 'white';
                                labelDiv.style.fontFamily = 'Arial, sans-serif';
                                labelDiv.style.fontSize = '12px';
                                labelDiv.style.fontWeight = 'bold';
                                labelDiv.textContent = `${distance.toFixed(2)} ${state.unitLabel}`;
                                labelDiv.style.whiteSpace = 'nowrap';
                                
                                previewLabel = new CSS2DObject(labelDiv);
                                scene.add(previewLabel);
                            } else {
                                previewLabel.element.textContent = `${distance.toFixed(2)} ${state.unitLabel}`;
                            }
                            
                            // Position label at midpoint
                            const midpoint = new THREE.Vector3().addVectors(startPoint, hoverPoint).multiplyScalar(0.5);
                            previewLabel.position.copy(midpoint);
                        }
                        
                        // For path measurements - update preview line
                        if (state.isPathMeasureMode && state.pathMeasurementPoints.length > 0) {
                            const lastPoint = state.pathMeasurementPoints[state.pathMeasurementPoints.length - 1];
                            
                            // Create or update preview line
                            if (!previewLine) {
                                const lineGeometry = new THREE.BufferGeometry().setFromPoints([lastPoint, hoverPoint]);
                                const lineMaterial = new THREE.LineDashedMaterial({ 
                                    color: 0xe91e63, 
                                    dashSize: 0.2, 
                                    gapSize: 0.1 
                                });
                                previewLine = new THREE.Line(lineGeometry, lineMaterial);
                                previewLine.computeLineDistances();
                                
                                // Create background line for better visibility
                                const bgLineMaterial = new THREE.LineDashedMaterial({ 
                                    color: 0x000000, 
                                    dashSize: 0.2, 
                                    gapSize: 0.1,
                                    linewidth: 3
                                });
                                previewBackgroundLine = new THREE.Line(lineGeometry.clone(), bgLineMaterial);
                                previewBackgroundLine.computeLineDistances();
                                
                                measurementGroup.add(previewBackgroundLine);
                                measurementGroup.add(previewLine);
                            } else {
                                // Update existing line geometry
                                const positions = new Float32Array([
                                    lastPoint.x, lastPoint.y, lastPoint.z,
                                    hoverPoint.x, hoverPoint.y, hoverPoint.z
                                ]);
                                previewLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                                previewLine.geometry.computeBoundingSphere();
                                previewLine.computeLineDistances();
                                
                                previewBackgroundLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions.slice(), 3));
                                previewBackgroundLine.geometry.computeBoundingSphere();
                                previewBackgroundLine.computeLineDistances();
                            }
                            
                            // Calculate and update distance label
                            const segmentDistance = lastPoint.distanceTo(hoverPoint) * state.currentUnit;
                            const totalDistance = (state.pathTotalDistance + lastPoint.distanceTo(hoverPoint)) * state.currentUnit;
                            
                            if (!previewLabel) {
                                const labelDiv = document.createElement('div');
                                labelDiv.className = 'distance-label';
                                labelDiv.style.padding = '2px 6px';
                                labelDiv.style.borderRadius = '2px';
                                labelDiv.style.background = 'rgba(233,30,99,0.7)';
                                labelDiv.style.color = 'white';
                                labelDiv.style.fontFamily = 'Arial, sans-serif';
                                labelDiv.style.fontSize = '10px';
                                labelDiv.textContent = `${segmentDistance.toFixed(2)} ${state.unitLabel}`;
                                labelDiv.style.whiteSpace = 'nowrap';
                                
                                previewLabel = new CSS2DObject(labelDiv);
                                scene.add(previewLabel);
                            } else {
                                previewLabel.element.textContent = `${segmentDistance.toFixed(2)} ${state.unitLabel}`;
                            }
                            
                            // Position label at midpoint
                            const midpoint = new THREE.Vector3().addVectors(lastPoint, hoverPoint).multiplyScalar(0.5);
                            previewLabel.position.copy(midpoint);
                            
                            // Update total label
                            if (pathTotalLabel) {
                                pathTotalLabel.element.innerHTML = `Total: ${totalDistance.toFixed(2)} ${state.unitLabel} (preview)`;
                                pathTotalLabel.position.copy(hoverPoint);
                                pathTotalLabel.visible = true;
                            }
                        }
                        
                        state.needsRender = true;
                    }
                }
            }, 16); // ~60fps target
        });
        
        // Add toast notification function
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.position = 'fixed';
            toast.style.bottom = '20px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            toast.style.color = 'white';
            toast.style.padding = '10px 20px';
            toast.style.borderRadius = '5px';
            toast.style.zIndex = '2000';
            toast.style.transition = 'opacity 0.3s ease-in-out';
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        document.body.removeChild(toast);
                    }
                }, 300);
            }, 2000);
        }

        // Initialize cameras
        setupCameras();

        // Add function to create hierarchy tree
        function createHierarchyTree(object, level = 0) {
            let html = '';
            const indent = '&nbsp;'.repeat(level * 4);
            
            // Create node with name and type
            const nodeName = object.name || 'Unnamed';
            const nodeType = object.type || 'Object';
            const isMesh = object.isMesh;
            const isGroup = object.isGroup;
            
            // Count children for this node
            const childCount = object.children ? object.children.length : 0;
            const childCountText = childCount > 0 ? ` [${childCount} children]` : '';
            
            html += `<div class="hierarchy-node" style="margin-left: ${level * 10}px; padding: 2px 0;">
                <span style="color: ${isMesh ? '#4CAF50' : isGroup ? '#2196F3' : '#FFC107'}">
                    ${indent}${nodeName} (${nodeType})${childCountText}
                </span>
            </div>`;
            
            // Recursively add children
            if (object.children && object.children.length > 0) {
                object.children.forEach(child => {
                    html += createHierarchyTree(child, level + 1);
                });
            }
            
            return html;
        }

        // Add function to update hierarchy display
        function updateHierarchyDisplay() {
            if (!state.currentMesh) return;
            
            const hierarchyContainer = document.getElementById('hierarchy-tree');
            const objectCountElement = document.getElementById('object-count');
            if (!hierarchyContainer || !objectCountElement) return;
            
            // Count total objects
            const totalObjects = countObjects(state.currentMesh);
            objectCountElement.textContent = `(${totalObjects} objects)`;
            
            // Update hierarchy tree
            hierarchyContainer.innerHTML = createHierarchyTree(state.currentMesh);
        }

        // Add function to count objects
        function countObjects(object) {
            let count = 1; // Count this object
            
            if (object.children && object.children.length > 0) {
                object.children.forEach(child => {
                    count += countObjects(child);
                });
            }
            
            return count;
        }

        // Add styles for hierarchy viewer
        const style = document.createElement('style');
        style.textContent = `
            .hierarchy-node {
                font-family: monospace;
                font-size: 12px;
                line-height: 1.4;
                cursor: pointer;
                transition: background-color 0.2s;
            }
            
            .hierarchy-node:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }
            
            #hierarchy-container {
                font-family: monospace;
                font-size: 12px;
                color: #fff;
            }
            
            #hierarchy-container::-webkit-scrollbar {
                width: 8px;
            }
            
            #hierarchy-container::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 4px;
            }
            
            #hierarchy-container::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }
            
            #hierarchy-container::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        `;
        document.head.appendChild(style);

        // Add click handler for hierarchy nodes
        document.addEventListener('click', (event) => {
            const node = event.target.closest('.hierarchy-node');
            if (node) {
                const nodeName = node.textContent.trim().split(' (')[0];
                // Find the object in the scene
                state.currentMesh.traverse((object) => {
                    if (object.name === nodeName) {
                        // Highlight the object
                        if (object.isMesh) {
                            const originalMaterial = object.material;
                            object.material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                wireframe: true
                            });
                            setTimeout(() => {
                                object.material = originalMaterial;
                            }, 1000);
                        }
                    }
                });
            }
        });
    </script>
</body>
</html> 