{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model Viewer (SIGMA VERSION)</title>
    <!-- Force high-performance GPU on dual-GPU systems -->
    <meta http-equiv="hardware-accelerated" content="true">
    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <!-- Add GPU preference in multiple ways -->
    <canvas id="gpu-preference" style="display:none"></canvas>
    <script>
        // Try to force high-performance GPU before any other code runs
        try {
            const canvas = document.getElementById('gpu-preference');
            const gl = canvas.getContext('webgl', {powerPreference: 'high-performance', failIfMajorPerformanceCaveat: true});
            console.log("Initialized preference GPU context:", gl ? "success" : "failed");
        } catch(e) {
            console.warn("Could not initialize preference GPU context:", e);
        }
    </script>
    <!-- Fix CORS issues by adding proper crossorigin attributes -->
    <link rel="preload" href="https://deepgis.org/static/deepgis/models/gltf/navagunjara-reborn-digital-twin-propane-and-solar-v2.glb" as="fetch" crossorigin="anonymous">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/build/three.module.js" as="script" crossorigin="anonymous">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js" as="script" crossorigin="anonymous">
    <link rel="preload" href="https://unpkg.com/three@0.158.0/examples/jsm/loaders/DRACOLoader.js" as="script" crossorigin="anonymous">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .loading-progress {
            width: 100%;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            margin-top: 10px;
        }
        .loading-bar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        .controls-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(40, 40, 40, 0.85);
            padding: 20px 15px;
            box-shadow: -2px 0 15px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            width: 250px;
            z-index: 100;
            color: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        /* Same CSS as in original file... */
        /* (CSS is kept identical to the original file) */
    </style>
    <!-- Add responsive CSS for debug console and toggle button -->
    <style>
        @media (max-width: 768px) {
            #debug-console {
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                top: auto !important;
                width: 100vw !important;
                max-width: 100vw !important;
                max-height: 45vh !important;
                border-radius: 12px 12px 0 0 !important;
                font-size: 15px !important;
                padding: 18px 10px 10px 10px !important;
                z-index: 2000 !important;
                box-shadow: 0 -2px 12px rgba(0,0,0,0.25);
                overflow-y: auto !important;
                display: none;
                background: rgba(20,20,20,0.97) !important;
            }
            #debug-toggle-btn {
                position: fixed;
                right: 18px;
                bottom: 18px;
                z-index: 2100;
                background: #673ab7;
                color: #fff;
                border: none;
                border-radius: 50%;
                width: 54px;
                height: 54px;
                font-size: 18px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.18);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: background 0.2s;
            }
            #debug-toggle-btn.active {
                background: #311b92;
            }
        }
    </style>
</head>
<body>
    <canvas id="viewer"></canvas>
    <div id="loading">
        Loading 3D model...
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div id="loadingDetails">Initializing...</div>
    </div>
    
    <div style="position: absolute; top: 10px; left: 10px; background-color: #9c27b0; color: white; padding: 5px 10px; border-radius: 5px; font-weight: bold; font-family: Arial, sans-serif; z-index: 1000;" class="sigma-indicator">
        SIGMA VERSION
    </div>
    
    <!-- Rest of UI elements remain the same -->
    <div class="controls-overlay">
        <h3>3D Model Controls (Sigma)</h3>
        <div id="modelInfo">
            <div id="modelName">Loading model...</div>
            <div id="modelDimensions">Dimensions: -- × -- × -- m</div>
            <div id="modelCalibration">Calibration: loading...</div>
        </div>
        
        <div class="control-group">
            <button id="toggleViewMode" class="control-button">Toggle View Mode</button>
            <button id="toggleAxes" class="control-button">Toggle Axes</button>
            <button id="toggleOrtho" class="control-button">Toggle Orthographic</button>
        </div>
        
        <div class="control-group">
            <button id="viewTop" class="control-button view-button">Top View</button>
            <button id="viewFront" class="control-button view-button">Front View</button>
            <button id="viewLeft" class="control-button view-button">Left View</button>
            <button id="viewIso" class="control-button view-button">Isometric</button>
        </div>
        
        <div class="control-group">
            <button id="measureMode" class="control-button">Measure Distance</button>
            <button id="pathMeasureMode" class="control-button">Measure Path</button>
            <button id="clearMeasurements" class="control-button">Clear Measurements</button>
        </div>
        
        <div id="measurementsList">
            <h4>Measurements</h4>
            <div id="measurements-container">No measurements yet</div>
        </div>
    </div>

    <div class="keyboard-shortcuts">
        <!-- Same shortcuts as original file -->
    </div>

    <div id="annotations">
        <!-- Same annotations as original file -->
    </div>

    <!-- Import maps polyfill for browsers without native support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // Create debugConsole and debugToggleBtn at the top so they are available everywhere
        const debugConsole = document.createElement('div');
        debugConsole.id = 'debug-console';
        debugConsole.style.position = 'absolute';
        debugConsole.style.left = '10px';
        debugConsole.style.bottom = '10px';
        debugConsole.style.maxWidth = '350px';
        debugConsole.style.maxHeight = '350px';
        debugConsole.style.overflow = 'auto';
        debugConsole.style.background = 'rgba(0,0,0,0.85)';
        debugConsole.style.color = 'white';
        debugConsole.style.padding = '10px';
        debugConsole.style.fontFamily = 'monospace';
        debugConsole.style.fontSize = '12px';
        debugConsole.style.zIndex = '1000';
        debugConsole.style.borderRadius = '6px';
        document.body.appendChild(debugConsole);

        const debugToggleBtn = document.createElement('button');
        debugToggleBtn.id = 'debug-toggle-btn';
        debugToggleBtn.innerHTML = 'Debug';
        debugToggleBtn.style.display = 'none'; // Only show on mobile
        debugToggleBtn.style.position = 'fixed';
        debugToggleBtn.style.right = '18px';
        debugToggleBtn.style.bottom = '18px';
        debugToggleBtn.style.zIndex = '2100';
        debugToggleBtn.style.background = '#673ab7';
        debugToggleBtn.style.color = '#fff';
        debugToggleBtn.style.border = 'none';
        debugToggleBtn.style.borderRadius = '50%';
        debugToggleBtn.style.width = '54px';
        debugToggleBtn.style.height = '54px';
        debugToggleBtn.style.fontSize = '18px';
        debugToggleBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.18)';
        debugToggleBtn.style.display = 'none';
        debugToggleBtn.style.alignItems = 'center';
        debugToggleBtn.style.justifyContent = 'center';
        debugToggleBtn.style.cursor = 'pointer';
        debugToggleBtn.style.transition = 'background 0.2s';
        document.body.appendChild(debugToggleBtn);

        // Add state management class
        class ViewerState {
            constructor() {
                this.isMeasureMode = false;
                this.isPathMeasureMode = false;
                this.currentMesh = null;
                this.needsRender = false;
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
                this.isHighPerformanceMode = true;
                this.viewMode = 1; // 0: solid, 1: transparent, 2: wireframe
                this.isOrthographic = false;
                this.isAxesVisible = true;
                this.measurementPoints = [];
                this.pathMeasurementPoints = [];
                this.pathMeasurementLines = [];
                this.pathMeasurementLabels = [];
                this.pathTotalDistance = 0;
                this.inPredefinedView = false;
            }

            toggleMeasureMode() {
                if (this.isPathMeasureMode) {
                    this.togglePathMeasureMode();
                }
                this.isMeasureMode = !this.isMeasureMode;
                this.needsRender = true;
            }

            togglePathMeasureMode() {
                if (this.isMeasureMode) {
                    this.toggleMeasureMode();
                }
                this.isPathMeasureMode = !this.isPathMeasureMode;
                this.needsRender = true;
            }
        }

        // Initialize state at the very top before any function uses it
        const state = new ViewerState();

        // Configure Three.js to allow software rendering fallback
        // This is needed for machines where hardware acceleration is not available
        window.THREE_ALLOW_SOFTWARE_RENDERER = true;

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        
        /**
         * SIGMA VERSION - Server-Side Optimizations
         * This version includes server-side optimizations for GLTF loading:
         * 1. Using GLB binary format instead of GLTF
         * 2. Implementing Draco mesh compression
         * 3. Utilizing HTTP/2 for efficient loading
         * 4. Resource preloading with <link rel="preload">
         * 5. Properly configured caching headers (set on server)
         * 6. Progress tracking for model loading
         * 7. Model splitting for progressive loading
         */

        // Scene setup
        const scene = new THREE.Scene();
        
        // Check if device is mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Try to detect NVIDIA GPU specifically before renderer creation
        let hasNvidiaGPU = false;
        try {
            const testCanvas = document.createElement('canvas');
            const testContext = testCanvas.getContext('webgl', {powerPreference: 'high-performance'});
            if (testContext) {
                const debugInfo = testContext.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const renderer = testContext.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    hasNvidiaGPU = renderer && (renderer.toLowerCase().includes('nvidia') || 
                                               renderer.toLowerCase().includes('geforce') || 
                                               renderer.toLowerCase().includes('quadro'));
                    console.log("GPU detection:", renderer, hasNvidiaGPU ? "NVIDIA detected" : "NVIDIA not detected");
                }
            }
        } catch (e) {
            console.warn("Error during pre-renderer GPU detection:", e);
        }
        
        // Unit for measurements - with calibration for real-world units
        let currentUnit = 1.0; // Will be adjusted after model loading
        let unitLabel = "m"; // Display label in meters
        let calibrationHeight = 4.28; // Assumed height in meters
        
        // Control states
        let isOrthographic = false;
        
        // Measurement control states
        let isMeasureMode = false;
        let isPathMeasureMode = false;
        let pathMeasurementPoints = [];
        let pathMeasurementLines = [];
        let pathMeasurementLabels = [];
        let pathTotalDistance = 0;
        let pathTotalLabel = null;
        
        // Set up both cameras
        const perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const orthographicCamera = new THREE.OrthographicCamera(
            window.innerWidth / -100, 
            window.innerWidth / 100, 
            window.innerHeight / 100, 
            window.innerHeight / -100, 
            0.1, 
            1000
        );
        
        // Start with perspective camera
        let camera = perspectiveCamera;
        
        // Create renderer with strong hints for high-performance GPU
        const rendererOptions = {
            canvas: document.getElementById('viewer'), 
            antialias: true,
            alpha: true,
            powerPreference: 'high-performance',
            failIfMajorPerformanceCaveat: false, // Allow fallback to software rendering
            preserveDrawingBuffer: true
        };
        
        // If we know we have NVIDIA, add more aggressive settings
        if (hasNvidiaGPU) {
            console.log("Using aggressive settings for NVIDIA GPU");
            rendererOptions.precision = 'highp';
        }
        
        let renderer;
        
        // Try to create WebGL2 renderer first
        try {
            console.log("Attempting to create WebGL2 renderer");
            renderer = new THREE.WebGLRenderer({
                ...rendererOptions,
                context: document.getElementById('viewer').getContext('webgl2', { 
                    powerPreference: 'high-performance',
                    failIfMajorPerformanceCaveat: false,
                })
            });
            console.log("Successfully created WebGL2 renderer");
        } catch (e) {
            console.warn("Could not create WebGL2 renderer, falling back to WebGL1:", e);
            try {
                // Fall back to WebGL1
                renderer = new THREE.WebGLRenderer(rendererOptions);
                console.log("Successfully created WebGL1 renderer");
            } catch (e2) {
                console.error("Failed to create any WebGL renderer:", e2);
                // Show a friendly error message
                const errorDiv = document.createElement('div');
                errorDiv.style.position = 'absolute';
                errorDiv.style.top = '50%';
                errorDiv.style.left = '50%';
                errorDiv.style.transform = 'translate(-50%, -50%)';
                errorDiv.style.background = 'rgba(220,0,0,0.8)';
                errorDiv.style.color = 'white';
                errorDiv.style.padding = '20px';
                errorDiv.style.borderRadius = '5px';
                errorDiv.style.maxWidth = '400px';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.zIndex = '2000';
                errorDiv.innerHTML = `
                    <h3>WebGL Not Available</h3>
                    <p>Your browser does not support WebGL or it is disabled.</p>
                    <p>Please try a different browser or enable WebGL in your browser settings.</p>
                    <p>For Chrome: chrome://settings/system → Use hardware acceleration when available</p>
                    <p>For Firefox: about:config → webgl.force-enabled = true</p>
                `;
                document.body.appendChild(errorDiv);
                throw new Error("WebGL not available, stopping script execution.");
            }
        }
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x303040);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Force renderer to use all available functionality
        renderer.outputEncoding = THREE.sRGBEncoding;
        // Reduce precision if we're in software mode for better performance
        if (renderer.capabilities.precision === 'lowp') {
            renderer.precision = 'lowp';
        }
        
        // Check GPU and renderer info
        const gl = renderer.getContext();
        
        // Create GPU info section
        const gpuInfoSection = document.createElement('div');
        gpuInfoSection.id = 'gpu-info-section';
        debugConsole.appendChild(gpuInfoSection);

        // Create hierarchy section
        const hierarchySection = document.createElement('div');
        hierarchySection.id = 'hierarchy-section';
        hierarchySection.style.marginTop = '12px';
        debugConsole.appendChild(hierarchySection);
        
        // Function to get GPU info (update gpuInfoSection instead of gpuInfoDisplay)
        function getGPUInfo() {
            let renderer, vendor, unmaskedRenderer, unmaskedVendor;
            try {
                renderer = gl.getParameter(gl.RENDERER);
                vendor = gl.getParameter(gl.VENDOR);
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    unmaskedRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    unmaskedVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                }
                const isSoftwareRendering = 
                    (unmaskedRenderer && (
                        unmaskedRenderer.includes('SwiftShader') || 
                        unmaskedRenderer.includes('llvmpipe') ||
                        unmaskedRenderer.includes('Software') ||
                        unmaskedRenderer.includes('Microsoft Basic Render')
                    )) ||
                    (renderer && (
                        renderer.includes('SwiftShader') ||
                        renderer.includes('llvmpipe') ||
                        renderer.includes('Software') ||
                        renderer.includes('Microsoft Basic Render')
                    ));
                const isAccelerated = !isSoftwareRendering;
                const isWebGL2 = gl instanceof WebGL2RenderingContext;
                const glVersion = gl.getParameter(gl.VERSION);
                const glslVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
                const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                const anisotropic = gl.getExtension('EXT_texture_filter_anisotropic');
                const maxAnisotropy = anisotropic ? 
                    gl.getParameter(anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 'Not supported';
                const gpuInfoHTML = `
                    <div style="color:${isAccelerated ? '#4caf50' : '#ff5252'}">
                        <strong>${isAccelerated ? '✓ GPU ACCELERATED' : '✗ SOFTWARE RENDERING'}</strong>
                    </div>
                    <div>Renderer: ${unmaskedRenderer || renderer || 'Unknown'}</div>
                    <div>Vendor: ${unmaskedVendor || vendor || 'Unknown'}</div>
                    <div>WebGL: ${isWebGL2 ? '2.0' : '1.0'} (${glVersion})</div>
                    <div>GLSL: ${glslVersion}</div>
                    <div>Max Texture: ${maxTextureSize}px</div>
                    <div>Anisotropy: ${maxAnisotropy}</div>
                `;
                gpuInfoSection.innerHTML = `<div style='font-weight:bold;margin-bottom:4px;'>GPU Debug Info</div>` + gpuInfoHTML;
                
                // Log detailed info to console for debugging
                console.log('GPU INFO:', {
                    renderer, vendor, unmaskedRenderer, unmaskedVendor,
                    isAccelerated, isSoftwareRendering,
                    webglVersion: isWebGL2 ? '2.0' : '1.0',
                    glVersion, glslVersion,
                    maxTextureSize,
                    extensions: gl.getSupportedExtensions()
                });
                
                // Check specifically for NVIDIA GPU
                const hasNvidiaGPU = (unmaskedRenderer && (
                    unmaskedRenderer.toLowerCase().includes('nvidia') ||
                    unmaskedRenderer.toLowerCase().includes('geforce') ||
                    unmaskedRenderer.toLowerCase().includes('quadro')
                ));
                
                // Show NVIDIA-specific guidance if we have Intel but NVIDIA should be available
                if (!hasNvidiaGPU && unmaskedRenderer && 
                    (unmaskedRenderer.toLowerCase().includes('intel') || 
                     unmaskedVendor && unmaskedVendor.toLowerCase().includes('intel'))) {
                    
                    // Create NVIDIA hint panel
                    const nvidiaHintPanel = document.createElement('div');
                    nvidiaHintPanel.style.position = 'absolute';
                    nvidiaHintPanel.style.top = '90px';
                    nvidiaHintPanel.style.left = '10px';
                    nvidiaHintPanel.style.background = '#673ab7';
                    nvidiaHintPanel.style.color = 'white';
                    nvidiaHintPanel.style.padding = '10px';
                    nvidiaHintPanel.style.borderRadius = '5px';
                    nvidiaHintPanel.style.maxWidth = '300px';
                    nvidiaHintPanel.style.zIndex = '1001';
                    nvidiaHintPanel.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                    
                    // Different instructions based on platform
                    const isWindows = navigator.platform.indexOf('Win') > -1;
                    const isLinux = navigator.platform.indexOf('Linux') > -1;
                    
                    if (isLinux) {
                        // Ubuntu/Linux specific instructions
                        nvidiaHintPanel.innerHTML = `
                            <strong>NVIDIA GPU Not Used (Ubuntu)</strong>
                            <div style="margin-top:5px;font-size:11px">To use NVIDIA GPU on Ubuntu:</div>
                            <ul style="margin:5px 0 0 15px;padding:0;font-size:11px;line-height:1.3">
                                <li>For one-time use: <code style="background:#444;padding:1px 3px;border-radius:2px">__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia google-chrome</code></li>
                                <li>Or create a launcher with: <code style="background:#444;padding:1px 3px;border-radius:2px">prime-run google-chrome</code> (if prime-run installed)</li>
                            </ul>
                            <div style="font-size:11px;margin-top:5px">For permanent browser setup:</div>
                            <ul style="margin:5px 0 0 15px;padding:0;font-size:11px;line-height:1.3">
                                <li>Edit <code style="background:#444;padding:1px 3px;border-radius:2px">~/.local/share/applications/google-chrome.desktop</code></li>
                                <li>Change <code>Exec=</code> lines to include: <code style="background:#444;padding:1px 3px;border-radius:2px">__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia</code></li>
                                <li>For Firefox, edit <code style="background:#444;padding:1px 3px;border-radius:2px">firefox.desktop</code> similarly</li>
                            </ul>
                            <div style="font-size:11px;margin-top:5px">Check NVIDIA Offloading:</div>
                            <ul style="margin:5px 0 0 15px;padding:0;font-size:11px;line-height:1.3">
                                <li>Run: <code style="background:#444;padding:1px 3px;border-radius:2px">nvidia-settings</code></li>
                                <li>Verify PRIME Profiles is set to NVIDIA On-Demand</li>
                                <li>Test: <code style="background:#444;padding:1px 3px;border-radius:2px">__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia glxinfo | grep "OpenGL renderer"</code></li>
                            </ul>
                        `;
                    } else if (isWindows) {
                        // Windows specific instructions
                        nvidiaHintPanel.innerHTML = `
                            <strong>NVIDIA GPU Not Used</strong>
                            <div style="margin-top:5px;font-size:11px">To use NVIDIA GPU instead of Intel:</div>
                            <ul style="margin:5px 0 0 15px;padding:0;font-size:11px;line-height:1.3">
                                <li>Right-click browser shortcut</li>
                                <li>Select "Run with graphics processor"</li>
                                <li>Choose "High-performance NVIDIA processor"</li>
                            </ul>
                            <div style="font-size:11px;margin-top:5px">Or in NVIDIA Control Panel:</div>
                            <ul style="margin:5px 0 0 15px;padding:0;font-size:11px;line-height:1.3">
                                <li>3D Settings > Program Settings</li>
                                <li>Add your browser</li>
                                <li>Set to "High-performance NVIDIA processor"</li>
                            </ul>
                        `;
                    } else {
                        // Generic instructions
                        nvidiaHintPanel.innerHTML = `
                            <strong>NVIDIA GPU Not Used</strong>
                            <div style="margin-top:5px;font-size:11px">To use NVIDIA GPU instead of Intel:</div>
                            <ul style="margin:5px 0 0 15px;padding:0;font-size:11px;line-height:1.3">
                                <li>Check your GPU driver settings</li>
                                <li>Select your browser</li>
                                <li>Force it to use the high-performance GPU</li>
                            </ul>
                        `;
                    }
                    
                    document.body.appendChild(nvidiaHintPanel);
                }
                
                return {
                    renderer: unmaskedRenderer || renderer,
                    vendor: unmaskedVendor || vendor,
                    isAccelerated,
                    webglVersion: isWebGL2 ? '2.0' : '1.0',
                    maxTextureSize,
                    maxAnisotropy,
                    hasNvidiaGPU
                };
            } catch (err) {
                console.error('Error getting GPU info:', err);
                gpuInfoSection.innerHTML = `<div style='color:#ff5252'>Could not detect GPU: ${err.message}</div>`;
                return null;
            }
        }
        
        // Run GPU detection
        const gpuInfo = getGPUInfo();
        
        // Show warning if software rendering is detected
        if (gpuInfo && !gpuInfo.isAccelerated) {
            const warningDiv = document.createElement('div');
            warningDiv.style.position = 'absolute';
            warningDiv.style.top = '50%';
            warningDiv.style.left = '50%';
            warningDiv.style.transform = 'translate(-50%, -50%)';
            warningDiv.style.background = 'rgba(255,82,82,0.9)';
            warningDiv.style.color = 'white';
            warningDiv.style.padding = '20px';
            warningDiv.style.borderRadius = '5px';
            warningDiv.style.zIndex = '2000';
            warningDiv.style.maxWidth = '400px';
            warningDiv.style.textAlign = 'center';
            warningDiv.innerHTML = `
                <h3 style="margin-top:0">Software Rendering Detected</h3>
                <p>Your browser is using software rendering instead of GPU acceleration.
                This will result in poor performance when viewing 3D models.</p>
                <p>Try updating your graphics drivers or using a different browser.</p>
                <button id="dismissWarning" style="padding:8px 16px;background:#fff;color:#f44336;
                border:none;border-radius:4px;cursor:pointer;font-weight:bold;margin-top:10px">
                Dismiss</button>
            `;
            document.body.appendChild(warningDiv);
            
            document.getElementById('dismissWarning').addEventListener('click', function() {
                warningDiv.style.display = 'none';
            });
        }
        
        // Label renderer
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);
        
        // Remove all previous lighting setup
        // Add only a single basic ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        // Add a sun (directional light) in addition to the ambient light
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);
        
        // Add orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        setupControls();
        
        // Model bounds for orthographic sizing
        let modelSize = new THREE.Vector3(10, 10, 10);
        let modelCenter = new THREE.Vector3(0, 0, 0);

        // Add visual helpers
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // UI Controls
        let currentMesh = null;
        let isWireframe = false;
        let isAxesVisible = true;
        let viewMode = 1; // 0: solid, 1: transparent, 2: wireframe - default to transparent
        
        // Performance options
        let isHighPerformanceMode = true; // Start in high performance mode
        let showBoundingBox = false;
        let boxHelper = null;
        let enableDynamicLighting = false; // Disable dynamic lighting by default for performance
        let hierarchyContainer = null; // Declare at global scope
        
        // Add performance control button
        const perfModeBtn = document.createElement('button');
        perfModeBtn.textContent = 'High Performance';
        perfModeBtn.style.position = 'absolute';
        perfModeBtn.style.top = '50px';
        perfModeBtn.style.left = '10px';
        perfModeBtn.style.padding = '5px 10px';
        perfModeBtn.style.backgroundColor = '#4CAF50';
        perfModeBtn.style.color = 'white';
        perfModeBtn.style.border = 'none';
        perfModeBtn.style.borderRadius = '3px';
        perfModeBtn.style.cursor = 'pointer';
        perfModeBtn.style.zIndex = '1000';
        document.body.appendChild(perfModeBtn);
        
        perfModeBtn.addEventListener('click', () => {
            isHighPerformanceMode = !isHighPerformanceMode;
            perfModeBtn.textContent = isHighPerformanceMode ? 'High Performance' : 'High Quality';
            perfModeBtn.style.backgroundColor = isHighPerformanceMode ? '#4CAF50' : '#ff9800';
            
            // Apply performance optimizations
            applyPerformanceSettings();
        });
        
        function applyPerformanceSettings() {
            if (isHighPerformanceMode) {
                // High performance settings
                renderer.setPixelRatio(1); // Lower pixel ratio
                if (boxHelper) boxHelper.visible = false;
                if (hierarchyContainer) hierarchyContainer.style.display = 'none';
                
                // Simplify materials for better performance
                if (currentMesh) {
                    currentMesh.traverse(function(obj) {
                        if (obj.isMesh && obj.material) {
                            const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                            materials.forEach(material => {
                                // Use simpler materials for better performance
                                material.flatShading = true;
                                material.needsUpdate = true;
                            });
                        }
                    });
                }
            } else {
                // High quality settings
                renderer.setPixelRatio(window.devicePixelRatio);
                if (boxHelper) boxHelper.visible = showBoundingBox;
                
                // Restore materials
                if (currentMesh) {
                    currentMesh.traverse(function(obj) {
                        if (obj.isMesh && obj.material) {
                            const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                            materials.forEach(material => {
                                material.flatShading = false;
                                material.needsUpdate = true;
                            });
                        }
                    });
                }
            }
        }
        
        // Raycaster and mouse position tracking with debounce for better performance
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let raycastDebounce = null;
        
        // Measurement variables
        let measurementGroup = new THREE.Group();
        scene.add(measurementGroup);
        let measurements = [];
        let measurementPoints = [];
        let measurementLabels = [];
        let previewLine = null;
        let previewBackgroundLine = null;
        let previewLabel = null;
        
        // Debug visualization
        let rayVisualization = null;

        /**
         * Function to update orthographic camera settings
         * This was missing and causing the ReferenceError
         */
        function updateOrthographicCamera() {
            if (!modelSize) return;
            
            const aspect = window.innerWidth / window.innerHeight;
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            const padding = 1.2; // Add some padding around the model
            
            // Set the orthographic camera dimensions based on model size
            orthographicCamera.left = -maxDim * padding * aspect;
            orthographicCamera.right = maxDim * padding * aspect;
            orthographicCamera.top = maxDim * padding;
            orthographicCamera.bottom = -maxDim * padding;
            
            // Update near and far planes based on model position
            orthographicCamera.near = 0.01;
            orthographicCamera.far = maxDim * 10;
            
            orthographicCamera.updateProjectionMatrix();
        }
        
        /**
         * Function to set different standard views
         */
        function setViewTop() {
            const distance = Math.max(modelSize.x, modelSize.z) * 1.5;
            camera.position.set(0, distance, 0);
            camera.up.set(0, 0, -1);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }
        
        function setViewFront() {
            const distance = Math.max(modelSize.x, modelSize.y) * 1.5;
            camera.position.set(0, 0, distance);
            camera.up.set(0, 1, 0);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }
        
        function setViewLeft() {
            const distance = Math.max(modelSize.y, modelSize.z) * 1.5;
            camera.position.set(distance, 0, 0);
            camera.up.set(0, 1, 0);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }
        
        function setViewIso() {
            const distance = Math.max(modelSize.x, modelSize.y, modelSize.z) * 1.5;
            camera.position.set(distance, distance, distance);
            camera.up.set(0, 1, 0);
            camera.lookAt(modelCenter);
            controls.update();
            inPredefinedView = true;
        }

        /**
         * Optimized GLTF Loading Function
         * Server-side optimizations:
         * 1. Using GLB binary format instead of GLTF
         * 2. Implementing Draco mesh compression
         * 3. Adding progress tracking
         * 4. Model caching for subsequent loads
         */
        async function loadGLTFModel() {
            try {
                cleanupResources(); // Clean up before loading new model
                
            document.getElementById('loadingDetails').textContent = 'Initializing loaders...';
            document.getElementById('loadingBar').style.width = '5%';
            
                const dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://unpkg.com/three@0.158.0/examples/jsm/libs/draco/');
                dracoLoader.setDecoderConfig({ type: 'js' });
                
                const loader = new GLTFLoader();
                loader.setCrossOrigin('anonymous');
                loader.setDRACOLoader(dracoLoader);
                
                document.getElementById('loadingDetails').textContent = 'Fetching optimized GLB model...';
                document.getElementById('loadingBar').style.width = '10%';
                
                const modelPath = 'https://deepgis.org/static/deepgis/models/gltf/navagunjara-reborn-digital-twin-propane-and-solar-v2.glb';
                
                const modelResponse = await fetch(modelPath, { 
                    credentials: 'omit',
                    mode: 'cors' 
                });
                
                if (!modelResponse.ok) {
                    throw new Error(`Failed to fetch model: ${modelResponse.status} ${modelResponse.statusText}`);
                }
                
                const modelData = await modelResponse.arrayBuffer();
                
                const gltf = await new Promise((resolve, reject) => {
                    loader.parse(
                        modelData,
                        '',
                        resolve,
                        reject
                    );
                });
                
                document.getElementById('loadingDetails').textContent = 'Processing model...';
                document.getElementById('loadingBar').style.width = '95%';
                
                const mesh = gltf.scene;
                if (!mesh) {
                    throw new Error('No objects found in GLTF model scene');
                }
                
                state.currentMesh = mesh;
                scene.add(mesh);
                
                // Compute bounding box and center
                const boundingBox = new THREE.Box3().setFromObject(mesh);
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const center = new THREE.Vector3();
                boundingBox.getCenter(center);
                
                modelSize = size.clone();
                modelCenter = center.clone();
                
                // Update camera and controls
                updateOrthographicCamera();
                controls.target.copy(modelCenter);
                controls.update();

                // Update UI to show only dimensions
                const dimensionsText = `Dimensions: ${size.x.toFixed(2)} × ${size.y.toFixed(2)} × ${size.z.toFixed(2)} meters`;
                document.getElementById('modelDimensions').textContent = dimensionsText;
                document.getElementById('modelCalibration').textContent = '';

                // For measurements, use 1:1 (no calibration)
                currentUnit = 1.0;
                unitLabel = 'm';

                // Complete loading
                        document.getElementById('loadingBar').style.width = '100%';
                document.getElementById('loading').style.display = 'none';
                
                state.needsRender = true;

            } catch (error) {
                console.error('Error loading GLTF model:', error);
                document.getElementById('loadingDetails').textContent = 'Error loading model. Please try refreshing.';
                document.getElementById('loadingBar').style.backgroundColor = '#f44336';
                showErrorToUser('Failed to load 3D model. Please refresh the page.');
                cleanupResources();
            }
        }

        // Initialize the viewer
        loadGLTFModel();
        animate();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            cleanupResources();
            window.removeEventListener('resize', boundResizeHandler);
            window.removeEventListener('orientationchange', boundResizeHandler);
        });

        // Resource cleanup function
        function cleanupResources() {
            if (state.currentMesh) {
                scene.remove(state.currentMesh);
                state.currentMesh.traverse((object) => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            // Clean up measurement resources
            if (measurementGroup) {
                measurementGroup.traverse((object) => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                    if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                    } else {
                            object.material.dispose();
                    }
                }
            });
                scene.remove(measurementGroup);
            }

            // Clean up renderer
            if (renderer) {
                renderer.dispose();
            }

            // Reset state
            state.measurementPoints = [];
            state.pathMeasurementPoints = [];
            state.pathMeasurementLines = [];
            state.pathMeasurementLabels = [];
            state.pathTotalDistance = 0;
        }

        // Safe render function with error handling
        function safeRender() {
            try {
                if (state.needsRender) {
                    renderer.render(scene, camera);
                    if (measurementLabels.length > 0) {
                        labelRenderer.render(scene, camera);
                    }
                    state.needsRender = false;
                }
            } catch (error) {
                console.error('Render error:', error);
                showErrorToUser('Rendering error occurred. Please refresh the page.');
            }
        }

        // Improved animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.enabled) {
                controls.update();
            }
            
            safeRender();
        }

        // Improved mobile support
        function handleOrientationChange() {
            const isLandscape = window.innerWidth > window.innerHeight;
            state.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
            
            // Update UI for mobile
            if (state.isMobile) {
                debugConsole.style.display = 'none';
                debugToggleBtn.style.display = 'flex';
            } else {
                debugConsole.style.display = 'block';
                debugToggleBtn.style.display = 'none';
            }
            
            // Update camera and renderer
            updateOrthographicCamera();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            
            state.needsRender = true;
        }

        // Add proper event listener cleanup
        const boundResizeHandler = handleOrientationChange.bind(this);
        window.addEventListener('resize', boundResizeHandler);
        window.addEventListener('orientationchange', boundResizeHandler);

        // Improved measurement point validation
        function validatePoint(point) {
            if (!point || !(point instanceof THREE.Vector3)) {
                console.error('Invalid point provided');
                return false;
            }
            
            // Check if point is within reasonable bounds
            const maxDistance = 1000; // Adjust based on your scene size
            if (Math.abs(point.x) > maxDistance || 
                Math.abs(point.y) > maxDistance || 
                Math.abs(point.z) > maxDistance) {
                console.error('Point is too far from origin');
                return false;
            }
            
            return true;
        }

        // Improved measurement point addition
        function addMeasurementPoint(point) {
            if (!validatePoint(point)) {
                showErrorToUser('Invalid measurement point');
                return;
            }
            
            // Add point marker
            const markerGroup = new THREE.Group();
            markerGroup.position.copy(point);
            
            // Create marker geometry
            const markerSize = 0.08;
            const markerGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-markerSize, 0, 0),
                new THREE.Vector3(markerSize, 0, 0),
                new THREE.Vector3(0, -markerSize, 0),
                new THREE.Vector3(0, markerSize, 0),
                new THREE.Vector3(0, 0, -markerSize),
                new THREE.Vector3(0, 0, markerSize)
            ]);
            
            const markerMaterial = new THREE.LineBasicMaterial({ color: 0x4caf50 });
            const marker = new THREE.LineSegments(markerGeometry, markerMaterial);
            markerGroup.add(marker);
            
            measurementGroup.add(markerGroup);
            state.measurementPoints.push(point);
            
            if (state.measurementPoints.length === 2) {
                createMeasurement(state.measurementPoints[0], state.measurementPoints[1]);
                state.measurementPoints = [];
            }
            
            state.needsRender = true;
        }

        // Error display function
        function showErrorToUser(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.position = 'fixed';
            errorDiv.style.top = '20px';
            errorDiv.style.left = '50%';
            errorDiv.style.transform = 'translateX(-50%)';
            errorDiv.style.backgroundColor = 'rgba(244, 67, 54, 0.9)';
            errorDiv.style.color = 'white';
            errorDiv.style.padding = '10px 20px';
            errorDiv.style.borderRadius = '5px';
            errorDiv.style.zIndex = '2000';
            errorDiv.textContent = message;
            
            document.body.appendChild(errorDiv);
            
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    document.body.removeChild(errorDiv);
                }
            }, 5000);
        }

        // Add setupControls function
        function setupControls() {
            try {
                // Orbit controls settings
                controls.enableDamping = true;
                controls.dampingFactor = 0.15;
                controls.screenSpacePanning = true;
                controls.minDistance = 0.5;
                controls.maxDistance = 100;
                controls.rotateSpeed = 0.8;
                controls.zoomSpeed = 1.0;
                controls.panSpeed = 0.8;
                controls.enableTouch = true;
                
                // Use standard orbit control configuration for Y-up world
                controls.minPolarAngle = 0;
                controls.maxPolarAngle = Math.PI;
                
                // Set mouse buttons
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.PAN,
                    RIGHT: THREE.MOUSE.PAN
                };
                
                controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                
                // Add events to detect when user starts rotating
                controls.addEventListener('start', handleControlsStart);

                // Add error handling for control updates
                const originalUpdate = controls.update;
                controls.update = function() {
                    try {
                        originalUpdate.call(this);
                    } catch (error) {
                        console.error('Error updating controls:', error);
                        showErrorToUser('Error updating camera controls. Please refresh the page.');
                    }
                };

                // Add error handling for control changes
                controls.addEventListener('change', () => {
                    state.needsRender = true;
                });

                console.log('Controls setup complete');
            } catch (error) {
                console.error('Error setting up controls:', error);
                showErrorToUser('Error setting up camera controls. Please refresh the page.');
            }
        }

        // Add handleControlsStart function
        function handleControlsStart() {
            try {
                // If in orthographic mode with aligned grid, reset when user starts manual control
                if (state.isOrthographic && state.inPredefinedView) {
                    state.inPredefinedView = false;
                }
            } catch (error) {
                console.error('Error handling control start:', error);
            }
        }

        // Initialize the viewer
        loadGLTFModel();
        animate();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            cleanupResources();
            window.removeEventListener('resize', boundResizeHandler);
            window.removeEventListener('orientationchange', boundResizeHandler);
        });
    </script>
</body>
</html> 