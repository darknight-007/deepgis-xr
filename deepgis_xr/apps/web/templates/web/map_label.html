<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DeepGIS Map</title>
    
    <!-- Core Dependencies -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw-src.css" crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.css" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #map {
            position: absolute;
            top: 0;
            right: 300px;
            bottom: 0;
            left: 0;
            width: auto;
            height: 100%;
            z-index: 1;
        }

        #sidebar-wrapper {
            width: 300px;
            position: fixed;
            height: 100%;
            z-index: 1000;
            top: 0;
            right: 0;
            background: white;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            transform: translateX(0);
        }

        #wrapper.show-sidebar #sidebar-wrapper {
            transform: translateX(0);
        }

        .mobile-toggle {
            position: fixed;
            top: 10px;
            right: 310px;
            z-index: 2000;
            background: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: none;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        .layer-item:hover {
            background: #f8f9fa;
        }

        .layer-controls {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
        }

        .layer-group {
            margin-bottom: 15px;
        }

        .layer-group-title {
            font-weight: bold;
            margin-bottom: 8px;
        }

        /* Vector tile specific styles */
        .vector-layer-legend {
            padding: 10px;
            background: #fff;
            border-radius: 4px;
            margin: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .vector-style-control {
            margin-top: 10px;
        }

        /* Error handling styles */
        .tile-error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid red;
        }

        @media (max-width: 768px) {
            .mobile-toggle {
                display: block;
                right: 10px;
            }

            #sidebar-wrapper {
                transform: translateX(100%);
                width: 80%;
                max-width: 300px;
            }

            #map {
                right: 0;
            }

            #wrapper.show-sidebar #sidebar-wrapper {
                transform: translateX(0);
            }
        }

        #histogram {
            width: 100%;
            height: 200px;
            max-width: 800px;
            max-height: 400px;
        }

        .chart-container {
            position: relative;
            height: 200px;
            width: 100%;
        }

        .circle-diameter-tooltip {
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: white;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .leaflet-tooltip-center:before {
            display: none;
        }
    </style>
</head>

<body>
    <button class="mobile-toggle" id="sidebarToggle">
        <i class="fa fa-bars"></i>
    </button>

    <div id="wrapper">
        <div id="sidebar-wrapper">
            <div class="sidebar-content">
                <div class="sidebar-header p-3 bg-light">
                    <h5 class="m-0"><i class="fas fa-globe"></i> DeepGIS</h5>
                </div>
                
                <div class="layer-controls">
                    <div class="layer-group">
                        <div class="layer-group-title">
                            <i class="fa fa-calendar"></i> Available Dates
                        </div>
                        <div class="form-group mb-3">
                            <select class="form-select" id="dateSelect">
                                <!-- Will be populated dynamically -->
                            </select>
                        </div>
                    </div>

                    <div class="layer-group">
                        <div class="layer-group-title">
                            <i class="fa fa-layer-group"></i> Layer Types
                        </div>
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" id="rasterLayerToggle" checked>
                            <label class="form-check-label" for="rasterLayerToggle">Raster Layer</label>
                        </div>
                        <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="vectorLayerToggle" checked>
                            <label class="form-check-label" for="vectorLayerToggle">Vector Layer</label>
                        </div>
                    </div>

                    <div class="layer-group">
                        <div class="layer-group-title">
                            <i class="fa fa-map"></i> Base Map
                        </div>
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" id="baseMapToggle" checked>
                            <label class="form-check-label" for="baseMapToggle">Hide Base Map</label>
                        </div>
                    </div>
                </div>

                <div class="layer-controls">
                    <h6><i class="fa fa-chart-bar"></i> Statistics</h6>
                    <div class="chart-container">
                        <canvas id="histogram"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="map"></div>
    
    <!-- Scripts - Load in correct order -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
    <!-- Leaflet and its plugins - order matters -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
    <script src="https://deepgis.org/static/deepgis/scripts/vendor/leaflet.geometryutil.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure@3.1.0/dist/leaflet-measure.min.js" crossorigin="anonymous"></script>
    <script src="https://deepgis.org/static/deepgis/scripts/vendor/Leaflet.VectorGrid.bundled.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" crossorigin="anonymous"></script>

    <script>
        // Improved event handling for Leaflet
        if (!L.DomEvent.fakeStop) {
            L.DomEvent.fakeStop = function(e) {
                // More reliable event stopping
                e.preventDefault ? e.preventDefault() : e.returnValue = false;
                e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
                return this;
            };
        }
        
        if (!L.DomEvent.takeStop) {
            L.DomEvent.takeStop = function(e) {
                // More reliable event stopping
                e.preventDefault ? e.preventDefault() : e.returnValue = false;
                e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
                return this;
            };
        }

        // Global state for histogram and map management
        window.globals = {
            drawnItems: null,
            histogram_chart: null,
            map: null,  // Add map to globals for access across functions
            currentLayers: {
                raster: null,
                vector: null
            },
            layersReady: false,
            markerCounter: 0,  // Counter for sequential marker numbering
            markers: []        // Array to store all markers for distance calculations
        };

        // Helper function to show notifications
        function showSnackBar(message) {
            const snackbar = document.createElement('div');
            snackbar.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background-color: #333;
                color: white;
                padding: 12px 24px;
                border-radius: 4px;
                z-index: 1000;
                min-width: 250px;
                text-align: center;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            `;
            snackbar.textContent = message;
            document.body.appendChild(snackbar);
            setTimeout(() => snackbar.remove(), 3000);
        }

        // Wait for all scripts to load
        function waitForDependencies() {
            return new Promise((resolve, reject) => {
                const checkDependencies = () => {
                    if (typeof L !== 'undefined' && 
                        typeof L.map !== 'undefined' && 
                        typeof L.tileLayer !== 'undefined' &&
                        typeof L.vectorGrid !== 'undefined') {
                        resolve();
                    } else {
                        setTimeout(checkDependencies, 100);
                    }
                };
                setTimeout(() => reject(new Error('Dependencies failed to load')), 10000);
                checkDependencies();
            });
        }

        // Initialize histogram chart
        function initializeHistogram() {
            const ctx = document.getElementById('histogram').getContext('2d');
            window.globals.histogram_chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Vector Shape Areas',
                        data: [],
                        backgroundColor: 'rgba(255, 99, 132, 0.5)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Area (m²)'
                            }
                        }
                    }
                }
            });
        }

        // Get number of bins for histogram
        function getBinsValue() {
            // Default to 10 bins, can be adjusted based on data distribution
            return 10;
        }

        // Calculate area of a vector shape
        function calculateShapeArea(layer) {
            try {
                if (!layer) return 0;
                
                // Handle different shape types
                if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
                    const latlngs = layer.getLatLngs();
                    if (!latlngs || !latlngs.length) return 0;
                    
                    // Handle nested arrays for complex polygons
                    const flattenLatLngs = (arr) => {
                        return arr.reduce((flat, item) => {
                            return flat.concat(Array.isArray(item) && item[0] instanceof L.LatLng ? 
                                flattenLatLngs(item) : item);
                        }, []);
                    };
                    
                    const points = flattenLatLngs(latlngs);
                    if (!points || !points.length) return 0;
                    
                    // Calculate area using Leaflet's geodesic area calculation
                    return Math.abs(L.GeometryUtil.geodesicArea(points));
                }
                return 0;
            } catch (error) {
                console.warn('Error calculating shape area:', error);
                return 0;
            }
        }

        // Get all vector shapes currently in view
        async function getVectorShapesInView() {
            try {
                const shapes = [];
                let totalFeatures = 0;
                
                // Get shapes from drawn items
                if (window.globals.drawnItems) {
                    window.globals.drawnItems.eachLayer(layer => {
                        if (layer instanceof L.Polygon || layer instanceof L.Rectangle) {
                            shapes.push(layer);
                            totalFeatures++;
                        }
                    });
                }
                
                // Get shapes from active vector layers
                const vectorLayerToggle = document.getElementById('vectorLayerToggle');
                if (vectorLayerToggle && vectorLayerToggle.checked && window.globals.map) {
                    const processVectorLayers = [];
                    
                    window.globals.map.eachLayer(layer => {
                        if (layer instanceof L.VectorGrid.Protobuf) {
                            processVectorLayers.push(
                                new Promise(resolve => {
                                    const bounds = window.globals.map.getBounds();
                                    const features = new Map(); // Use Map to store unique features
                                    
                                    // Function to process a feature
                                    const processFeature = (feature) => {
                                        try {
                                            if (!feature?.properties?.id || !feature?.geometry?.coordinates) {
                                                return;
                                            }
                                            
                                            // Store feature by ID to prevent duplicates
                                            if (!features.has(feature.properties.id)) {
                                                if (feature.geometry.type === 'Polygon' || 
                                                    feature.geometry.type === 'MultiPolygon') {
                                                    
                                                    let coords;
                                                    try {
                                                        if (feature.geometry.type === 'Polygon') {
                                                            coords = feature.geometry.coordinates[0].map(coord => {
                                                                if (!Array.isArray(coord) || coord.length < 2) {
                                                                    throw new Error('Invalid coordinate format');
                                                                }
                                                                return L.latLng(coord[1], coord[0]);
                                                            });
                                                        } else { // MultiPolygon
                                                            coords = feature.geometry.coordinates[0][0].map(coord => {
                                                                if (!Array.isArray(coord) || coord.length < 2) {
                                                                    throw new Error('Invalid coordinate format');
                                                                }
                                                                return L.latLng(coord[1], coord[0]);
                                                            });
                                                        }
                                                        
                                                        // Create a proper Leaflet polygon for the feature
                                                        const featurePolygon = L.polygon(coords, {
                                                            id: feature.properties.id,
                                                            weight: 2,
                                                            color: '#475569',
                                                            fillColor: '#64748B',
                                                            fillOpacity: 0.6
                                                        });
                                                        
                                                        // Only include if it's in the current view
                                                        if (bounds.intersects(featurePolygon.getBounds())) {
                                                            features.set(feature.properties.id, featurePolygon);
                                                            totalFeatures++;
                                                        }
                                                    } catch (coordError) {
                                                        console.warn('Error processing coordinates:', coordError);
                                                    }
                                                }
                                            }
                                        } catch (featureError) {
                                            console.warn('Error processing feature:', featureError);
                                        }
                                    };

                                    // Process features in the current view
                                    if (layer.eachFeatureInScreenBounds) {
                                        layer.eachFeatureInScreenBounds(bounds, processFeature);
                                    }
                                    
                                    // Add processed features to shapes array
                                    shapes.push(...features.values());
                                    
                                    // Update stats display
                                    const statsElement = document.querySelector('.layer-controls h6');
                                    if (statsElement) {
                                        statsElement.innerHTML = `<i class="fa fa-chart-bar"></i> Statistics (${totalFeatures} features in view)`;
                                    }
                                    
                                    resolve();
                                })
                            );
                        }
                    });
                    
                    // Wait for all vector layers to be processed
                    await Promise.all(processVectorLayers);
                }
                
                return shapes;
            } catch (error) {
                console.warn('Error getting vector shapes:', error);
                return [];
            }
        }

        // Update histogram with areas
        async function updateHistogramWithAreas() {
            try {
                const shapes = await getVectorShapesInView();
                console.log('Processing shapes for histogram...');
                
                const areas = shapes.map(shape => {
                    const area = calculateShapeArea(shape);
                    console.log('Calculated area:', area);
                    return area;
                }).filter(area => area > 0);
                
                console.log('Valid areas:', areas.length);
                
                if (!areas.length) {
                    // No shapes or areas to display
                    if (window.globals.histogram_chart) {
                        window.globals.histogram_chart.data.labels = [];
                        window.globals.histogram_chart.data.datasets[0].data = [];
                        window.globals.histogram_chart.update();
                    }
                    return;
                }
                
                // Calculate histogram bins
                const bins = getBinsValue();
                const minArea = Math.min(...areas);
                const maxArea = Math.max(...areas);
                const binWidth = (maxArea - minArea) / bins;
                
                // Create bin ranges and counts
                const binRanges = [];
                const binCounts = new Array(bins).fill(0);
                
                for (let i = 0; i < bins; i++) {
                    const start = minArea + (i * binWidth);
                    const end = start + binWidth;
                    binRanges.push(`${Math.round(start)}-${Math.round(end)}`);
                    
                    // Count areas in this bin
                    areas.forEach(area => {
                        if (area >= start && (i === bins - 1 ? area <= end : area < end)) {
                            binCounts[i]++;
                        }
                    });
                }
                
                console.log('Bin ranges:', binRanges);
                console.log('Bin counts:', binCounts);
                
                // Update chart
                if (window.globals.histogram_chart) {
                    window.globals.histogram_chart.data.labels = binRanges;
                    window.globals.histogram_chart.data.datasets[0].data = binCounts;
                    window.globals.histogram_chart.options.scales.x.title.text = 'Area (m²)';
                    window.globals.histogram_chart.options.scales.y.title.text = 'Count';
                    window.globals.histogram_chart.data.datasets[0].label = 'Vector Shape Areas';
                    window.globals.histogram_chart.update();
                    
                    // Make sure the histogram is visible
                    const content = document.querySelector('.histogram-content');
                    if (content) {
                        content.style.display = 'block';
                    }
                }
            } catch (error) {
                console.warn('Error updating histogram:', error);
            }
        }

        // Initialize everything when the document is ready
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Keep touch events enabled for better mobile support
                // L.Browser.touch = false; 
                // L.Browser.pointer = false;

                // Initialize with sidebar shown
                document.getElementById('wrapper').classList.add('show-sidebar');

                // Wait for dependencies
                await waitForDependencies();

                // Initialize map
                window.globals.map = L.map('map', {
                    zoomControl: true,
                    attributionControl: true,
                    zoom: 22,
                    maxZoom: 24,
                    preferCanvas: true
                }).setView([33.78202, -111.26536], 22);

                // Initialize histogram
                initializeHistogram();

                // Add event listeners for histogram updates - with debouncing
                let updateTimeout;
                const debouncedUpdate = () => {
                    clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(() => {
                        updateHistogramWithAreas().catch(error => {
                            console.warn('Error updating histogram:', error);
                        });
                    }, 300); // Wait 300ms after last event before updating
                };

                window.globals.map.on('moveend zoomend', debouncedUpdate);

                // Initialize the drawn items layer separately and ensure it's on top
                window.globals.drawnItems = new L.FeatureGroup().addTo(window.globals.map);
                
                // Ensure draw events work properly
                window.globals.map.on(L.Draw.Event.CREATED, (e) => {
                    console.log('Draw created:', e.layerType);
                    try {
                        const layer = e.layer;
                        
                        // Add appropriate tooltips based on shape type
                        if (e.layerType === 'circle') {
                            attachCircleDiameterTooltip(layer);
                        } else if (e.layerType === 'rectangle') {
                            attachRectangleDimensionsTooltip(layer);
                        } else if (e.layerType === 'polygon') {
                            attachPolygonMeasurementsTooltip(layer);
                        } else if (e.layerType === 'polyline') {
                            attachPolylineLengthTooltip(layer);
                        } else if (e.layerType === 'marker') {
                            attachMarkerInfoTooltip(layer);
                        }
                        
                        // Add layer to the drawnItems group
                        window.globals.drawnItems.addLayer(layer);
                        // Force drawnItems to top of layer stack
                        window.globals.drawnItems.bringToFront();
                        // Trigger update of statistics
                        debouncedUpdate();
                    } catch (error) {
                        console.error('Error adding drawn layer:', error);
                    }
                });
                
                // Update tooltips when shapes are edited
                window.globals.map.on(L.Draw.Event.EDITED, (e) => {
                    const layers = e.layers;
                    layers.eachLayer(function(layer) {
                        if (layer instanceof L.Circle) {
                            attachCircleDiameterTooltip(layer);
                        } else if (layer instanceof L.Rectangle) {
                            attachRectangleDimensionsTooltip(layer);
                        } else if (layer instanceof L.Polygon) {
                            attachPolygonMeasurementsTooltip(layer);
                        } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                            attachPolylineLengthTooltip(layer);
                        } else if (layer instanceof L.Marker) {
                            // For markers, just update distances since position might have changed
                            updateAllMarkerDistances();
                        }
                    });
                    debouncedUpdate();
                });
                
                // Handle marker deletion to update distances
                window.globals.map.on(L.Draw.Event.DELETED, (e) => {
                    const layers = e.layers;
                    layers.eachLayer(function(layer) {
                        if (layer instanceof L.Marker) {
                            // Remove marker from global array
                            const index = window.globals.markers.indexOf(layer);
                            if (index > -1) {
                                window.globals.markers.splice(index, 1);
                            }
                        }
                    });
                    // Update distances for remaining markers
                    updateAllMarkerDistances();
                    debouncedUpdate();
                });

                // Update map view events to refresh marker distances and bearings
                window.globals.map.on('moveend zoomend', () => {
                    updateAllMarkerDistances();
                    debouncedUpdate();
                });

                // Update when vector layer visibility changes
                const vectorLayerToggle = document.getElementById('vectorLayerToggle');
                if (vectorLayerToggle) {
                    vectorLayerToggle.addEventListener('change', debouncedUpdate);
                }

                // Global variables
                const MBTILES_SERVER = window.location.protocol === 'https:' ? 
                    'https://mbtiles.deepgis.org' : 
                    'http://mbtiles.deepgis.org';

                // Function to normalize tile URLs to use mbtiles.deepgis.org
                function normalizeTileUrl(url) {
                    // Replace localhost:8091 with mbtiles.deepgis.org
                    return url.replace(/https?:\/\/localhost:8091/, 'https://mbtiles.deepgis.org');
                }

                // Function to fetch layer metadata from mbtiles.json
                async function fetchLayerMetadata(layerId) {
                    try {
                        const response = await fetch(`${MBTILES_SERVER}/data/${layerId}.json`);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        const metadata = await response.json();
                        
                        // Normalize all tile URLs in the metadata
                        if (metadata.tiles) {
                            metadata.tiles = metadata.tiles.map(normalizeTileUrl);
                        }
                        
                        return metadata;
                    } catch (error) {
                        console.warn(`Error fetching metadata for ${layerId}:`, error);
                        return null;
                    }
                }

                // Function to normalize layer name and get correct mbtiles ID
                function getMbtilesId(layerName) {
                    // Remove any file extensions
                    let id = layerName.replace(/\.mbtiles$/, '');
                    
                    // Handle special cases from the config
                    const specialCases = {
                        'BF_12-20-2020': 'bf_dec_2020',
                        'bf_dec_2020_vector': 'bf_dec_2020',
                        'bf_dec_2020_alt': 'bf_dec_2020'
                    };
                    
                    return specialCases[id] || id;
                }

                // Drawing tools - improved implementation
                const drawControl = new L.Control.Draw({
                    edit: {
                        featureGroup: window.globals.drawnItems,
                        edit: {
                            selectedPathOptions: {
                                maintainColor: true,
                                opacity: 0.7,
                                dashArray: '10, 10'
                            }
                        }
                    },
                    draw: {
                        polygon: {
                            allowIntersection: false,
                            showArea: true,
                            drawError: {
                                color: '#e1e100',
                                message: '<strong>Cannot draw that shape!</strong>'
                            },
                            shapeOptions: {
                                color: '#ff0000',
                                fillOpacity: 0.3
                            }
                        },
                        rectangle: {
                            shapeOptions: {
                                color: '#ff0000',
                                fillOpacity: 0.3
                            }
                        },
                        circle: {
                            shapeOptions: {
                                color: '#ff0000',
                                fillOpacity: 0.3
                            },
                            showRadius: true
                        },
                        circlemarker: false,
                        marker: true,
                        polyline: {
                            shapeOptions: {
                                color: '#3388ff',
                                weight: 4
                            }
                        }
                    }
                });
                window.globals.map.addControl(drawControl);

                // Handle loading order of layers
                async function initializeMap() {
                    try {
                        // Fetch available layers
                        const response = await fetch(`${MBTILES_SERVER}/data.json`);
                        if (!response.ok) throw new Error('Failed to fetch layers');
                        const data = await response.json();

                        // Log available layers
                        console.group('Available Layers');
                        console.log('Total layers:', Object.keys(data).length);

                        // Group layers by date
                        const layersByDate = {};
                        Object.entries(data).forEach(([id, info]) => {
                            if (!info || typeof info !== 'object') return;
                            
                            // Extract date from layer name (assuming format: BF_MM-DD-YYYY or bf_aug_2020)
                            let date = 'Unknown';
                            const dateMatch = info.name.match(/BF_(\d{2}-\d{2}-\d{4})/);
                            const altDateMatch = info.name.match(/bf_(\w+)_(\d{4})/);
                            
                            if (dateMatch) {
                                date = dateMatch[1];
                            } else if (altDateMatch) {
                                const month = altDateMatch[1];
                                const year = altDateMatch[2];
                                date = `${month}-${year}`;
                            }
                            
                            if (!layersByDate[date]) {
                                layersByDate[date] = {
                                    raster: null,
                                    vector: null
                                };
                            }

                            const layerInfo = {
                                id,
                                name: info.name,
                                format: info.format,
                                minzoom: info.minzoom,
                                maxzoom: info.maxzoom,
                                bounds: info.bounds,
                                center: info.center
                            };

                            if (info.format === 'pbf') {
                                layersByDate[date].vector = layerInfo;
                            } else {
                                layersByDate[date].raster = layerInfo;
                            }
                        });

                        // Populate date select
                        const dateSelect = document.getElementById('dateSelect');
                        let dates = Object.keys(layersByDate).sort((a, b) => {
                            if (a === 'Unknown') return 1;
                            if (b === 'Unknown') return -1;
                            return b.localeCompare(a); // Simple string comparison for mixed date formats
                        });

                        dates.forEach(date => {
                            const option = document.createElement('option');
                            option.value = date;
                            option.textContent = date;
                            dateSelect.appendChild(option);
                        });

                        // Initialize with OpenStreetMap and Google Satellite
                        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '© OpenStreetMap contributors'
                        });

                        const googleSatellite = L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                            maxZoom: 24,
                            subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                            attribution: '© Google Maps',
                            zIndex: -1
                        }).addTo(window.globals.map);
                        googleSatellite.bringToBack();

                        // Set up layer toggles
                        const rasterLayerToggle = document.getElementById('rasterLayerToggle');
                        const vectorLayerToggle = document.getElementById('vectorLayerToggle');
                        const baseMapToggle = document.getElementById('baseMapToggle');

                        let currentLayers = {
                            raster: null,
                            vector: null
                        };

                        // Load layers for selected date with proper ordering
                        async function loadLayersForDate(date) {
                            window.globals.layersReady = false;
                            const layers = layersByDate[date];
                            if (!layers) return;

                            // Remove current layers
                            if (window.globals.currentLayers.raster) {
                                window.globals.map.removeLayer(window.globals.currentLayers.raster);
                                window.globals.currentLayers.raster = null;
                            }
                            if (window.globals.currentLayers.vector) {
                                window.globals.map.removeLayer(window.globals.currentLayers.vector);
                                window.globals.currentLayers.vector = null;
                            }

                            // Load vector layer
                            if (layers.vector) {
                                try {
                                    const mbtilesId = getMbtilesId(layers.vector.name);
                                    const metadata = await fetchLayerMetadata(mbtilesId);
                                    
                                    if (!metadata || !metadata.tiles || metadata.tiles.length === 0) {
                                        throw new Error('No valid tile URLs in metadata');
                                    }

                                    // Use the first valid HTTPS URL from metadata, or construct one
                                    let tileUrl = metadata.tiles.find(url => url.startsWith('https://mbtiles.deepgis.org'));
                                    if (!tileUrl) {
                                        // Construct a URL using the standard format
                                        tileUrl = `https://mbtiles.deepgis.org/data/${mbtilesId}/{z}/{x}/{y}.pbf`;
                                    }

                                    console.log('Loading vector layer:', {
                                        name: layers.vector.name,
                                        mbtilesId,
                                        tileUrl,
                                        metadata
                                    });

                                    // Create vector layer with metadata properties
                                    window.globals.currentLayers.vector = L.vectorGrid.protobuf(tileUrl, {
                                        minZoom: metadata.minzoom || 0,
                                        maxZoom: metadata.maxzoom || 22,
                                        bounds: metadata.bounds ? L.latLngBounds([
                                            [metadata.bounds[1], metadata.bounds[0]],
                                            [metadata.bounds[3], metadata.bounds[2]]
                                        ]) : null,
                                        vectorTileLayerStyles: {
                                            '*': function(properties, zoom) {
                                                return {
                                                    weight: 2,
                                                    color: '#475569',
                                                    fillColor: '#64748B',
                                                    fillOpacity: 0.6,
                                                    fill: true
                                                };
                                            }
                                        },
                                        interactive: true,
                                        getFeatureId: function(f) {
                                            return f.properties.id || `${f.geometry.type}_${JSON.stringify(f.geometry.coordinates)}`;
                                        },
                                        rendererFactory: L.canvas.tile,
                                        maxNativeZoom: metadata.maxzoom || 22,
                                        tolerance: 5,
                                        buffer: 128
                                    });

                                    // Ensure vector layer has proper z-index positioning
                                    if (window.globals.currentLayers.vector) {
                                        window.globals.currentLayers.vector.setZIndex(10);
                                        
                                        // Add vector layer event handlers with error protection
                                        window.globals.currentLayers.vector.on('load', () => {
                                            console.log('Vector tiles loaded, updating features...');
                                            try {
                                                // Ensure drawn items are on top
                                                if (window.globals.drawnItems) {
                                                    window.globals.drawnItems.bringToFront();
                                                }
                                                debouncedUpdate();
                                            } catch (error) {
                                                console.warn('Error in vector load handler:', error);
                                            }
                                        });

                                        window.globals.currentLayers.vector.on('tileerror', (error) => {
                                            console.warn('Vector tile error:', error);
                                            showSnackBar('Error loading vector tile data');
                                        });

                                        if (vectorLayerToggle.checked) {
                                            window.globals.currentLayers.vector.addTo(window.globals.map);
                                        }
                                    }

                                    vectorLayerToggle.disabled = false;
                                    vectorLayerToggle.checked = true;

                                } catch (error) {
                                    console.warn('Error loading vector layer:', error);
                                    vectorLayerToggle.disabled = true;
                                    vectorLayerToggle.checked = false;
                                    showSnackBar('Error loading vector layer. Will retry on next selection.');
                                }
                            }

                            // Load raster layer
                            if (layers.raster) {
                                try {
                                    const mbtilesId = getMbtilesId(layers.raster.name);
                                    const metadata = await fetchLayerMetadata(mbtilesId);
                                    
                                    if (!metadata || !metadata.tiles || metadata.tiles.length === 0) {
                                        throw new Error('No valid tile URLs in metadata');
                                    }

                                    // Use the first valid HTTPS URL from metadata, or construct one
                                    let tileUrl = metadata.tiles.find(url => url.startsWith('https://mbtiles.deepgis.org'));
                                    if (!tileUrl) {
                                        // Construct a URL using the standard format
                                        tileUrl = `https://mbtiles.deepgis.org/data/${mbtilesId}/{z}/{x}/{y}.png`;
                                    }

                                    console.log('Loading raster layer:', {
                                        name: layers.raster.name,
                                        mbtilesId,
                                        tileUrl,
                                        metadata
                                    });

                                    window.globals.currentLayers.raster = L.tileLayer(tileUrl, {
                                        minZoom: metadata.minzoom || 0,
                                        maxZoom: metadata.maxzoom || 22,
                                        bounds: metadata.bounds ? L.latLngBounds([
                                            [metadata.bounds[1], metadata.bounds[0]],
                                            [metadata.bounds[3], metadata.bounds[2]]
                                        ]) : null
                                    });

                                    // Ensure raster layer has proper z-index positioning
                                    if (window.globals.currentLayers.raster) {
                                        window.globals.currentLayers.raster.setZIndex(5);
                                        
                                        // Add load event to ensure proper layer ordering
                                        window.globals.currentLayers.raster.on('load', () => {
                                            try {
                                                // Ensure raster is behind vector
                                                if (window.globals.currentLayers.vector) {
                                                    window.globals.currentLayers.vector.bringToFront();
                                                }
                                                // Ensure drawn items are on top
                                                if (window.globals.drawnItems) {
                                                    window.globals.drawnItems.bringToFront();
                                                }
                                            } catch (error) {
                                                console.warn('Error in raster load handler:', error);
                                            }
                                        });
                                        
                                        if (rasterLayerToggle.checked) {
                                            window.globals.currentLayers.raster.addTo(window.globals.map);
                                        }
                                    }

                                } catch (error) {
                                    console.warn('Error loading raster layer:', error);
                                    showSnackBar('Error loading raster layer. Will retry on next selection.');
                                }
                            }
                            
                            // Set layers as ready after all loading is complete
                            setTimeout(() => {
                                window.globals.layersReady = true;
                                // Final check to ensure drawn items are on top
                                if (window.globals.drawnItems) {
                                    window.globals.drawnItems.bringToFront();
                                }
                            }, 500);
                        }

                        // Set up event listeners
                        dateSelect.addEventListener('change', (e) => {
                            // Reset vector layer toggle state
                            vectorLayerToggle.disabled = false;
                            vectorLayerToggle.checked = true;
                            loadLayersForDate(e.target.value);
                        });

                        rasterLayerToggle.addEventListener('change', (e) => {
                            if (window.globals.currentLayers.raster) {
                                if (e.target.checked) {
                                    window.globals.currentLayers.raster.addTo(window.globals.map);
                                    // Fix layer ordering
                                    if (window.globals.currentLayers.vector && vectorLayerToggle.checked) {
                                        window.globals.currentLayers.vector.bringToFront();
                                    }
                                    if (window.globals.drawnItems) {
                                        window.globals.drawnItems.bringToFront();
                                    }
                                } else {
                                    window.globals.map.removeLayer(window.globals.currentLayers.raster);
                                }
                            }
                        });

                        vectorLayerToggle.addEventListener('change', (e) => {
                            if (window.globals.currentLayers.vector) {
                                if (e.target.checked) {
                                    window.globals.currentLayers.vector.addTo(window.globals.map);
                                    // Fix layer ordering
                                    if (window.globals.drawnItems) {
                                        window.globals.drawnItems.bringToFront();
                                    }
                                } else {
                                    window.globals.map.removeLayer(window.globals.currentLayers.vector);
                                }
                                // Update histogram after layer visibility changes
                                debouncedUpdate();
                            }
                        });

                        baseMapToggle.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                window.globals.map.removeLayer(googleSatellite);
                            } else {
                                googleSatellite.addTo(window.globals.map);
                                googleSatellite.bringToBack();
                            }
                        });

                        // Load initial layers
                        if (dates.length > 0) {
                            loadLayersForDate(dates[0]);
                        }

                    } catch (error) {
                        console.error('Error initializing map:', error);
                        showSnackBar('Error loading layers. Please try refreshing the page.');
                    }
                }

                // Initialize map and add event listeners after map is ready
                await initializeMap();

                // Add resize handler to update map when sidebar toggles
                function updateMapSize() {
                    if (window.globals.map) window.globals.map.invalidateSize();
                }

                // UI Controls with map resize
                document.getElementById('sidebarToggle').addEventListener('click', () => {
                    const wrapper = document.getElementById('wrapper');
                    wrapper.classList.toggle('show-sidebar');
                    setTimeout(updateMapSize, 300); // Wait for transition to complete
                });

                // Add helper function to calculate circle diameter in meters
                function calculateCircleDiameter(circle) {
                    const radius = circle.getRadius();
                    return (radius * 2).toFixed(2);
                }
                
                // Add helper function to calculate circle area in square meters
                function calculateCircleArea(circle) {
                    const radius = circle.getRadius();
                    const area = Math.PI * radius * radius;
                    return area.toFixed(2);
                }
                
                // Helper function to convert distance from meters to multiple units with smart formatting
                function formatDistanceUnits(distanceInM) {
                    const distance = parseFloat(distanceInM);
                    
                    // Conversion factors
                    const toCm = distance * 100;
                    const toInches = distance * 39.3701;
                    const toFeet = distance * 3.28084;
                    const toYards = distance * 1.09361;
                    
                    // Smart unit selection based on distance size for usability
                    let formattedDistance = `${distance.toFixed(2)} m`;
                    
                    if (distance < 0.1) { // < 10 cm
                        formattedDistance = `${toCm.toFixed(1)} cm`;
                        if (toCm > 2.54) { // > 1 inch
                            formattedDistance += ` (${toInches.toFixed(1)} in)`;
                        }
                    } else if (distance < 1) { // 10 cm to 1 m
                        formattedDistance = `${toCm.toFixed(0)} cm`;
                        formattedDistance += ` (${toInches.toFixed(1)} in)`;
                        if (toFeet >= 1) {
                            formattedDistance += ` (${toFeet.toFixed(1)} ft)`;
                        }
                    } else if (distance < 3) { // 1 m to 3 m
                        formattedDistance = `${distance.toFixed(2)} m`;
                        formattedDistance += ` (${toFeet.toFixed(1)} ft)`;
                        if (toYards >= 1) {
                            formattedDistance += ` (${toYards.toFixed(1)} yd)`;
                        }
                    } else if (distance < 100) { // 3 m to 100 m
                        formattedDistance = `${distance.toFixed(1)} m`;
                        formattedDistance += ` (${toFeet.toFixed(0)} ft)`;
                        formattedDistance += ` (${toYards.toFixed(1)} yd)`;
                    } else { // > 100 m
                        formattedDistance = `${distance.toFixed(0)} m`;
                        formattedDistance += ` (${toYards.toFixed(0)} yd)`;
                    }
                    
                    return formattedDistance;
                }
                
                // Helper function to format GPS coordinates
                function formatGPSCoordinates(latlng) {
                    const lat = latlng.lat.toFixed(6);
                    const lng = latlng.lng.toFixed(6);
                    const latDir = lat >= 0 ? 'N' : 'S';
                    const lngDir = lng >= 0 ? 'E' : 'W';
                    return `${Math.abs(lat)}°${latDir}, ${Math.abs(lng)}°${lngDir}`;
                }
                
                // Helper function to copy text to clipboard with fallback
                async function copyToClipboard(text) {
                    try {
                        // Try modern Clipboard API first
                        if (navigator.clipboard && window.isSecureContext) {
                            await navigator.clipboard.writeText(text);
                            return true;
                        } else {
                            // Fallback for older browsers
                            const textArea = document.createElement('textarea');
                            textArea.value = text;
                            textArea.style.position = 'fixed';
                            textArea.style.left = '-999999px';
                            textArea.style.top = '-999999px';
                            document.body.appendChild(textArea);
                            textArea.focus();
                            textArea.select();
                            const result = document.execCommand('copy');
                            document.body.removeChild(textArea);
                            return result;
                        }
                    } catch (error) {
                        console.warn('Failed to copy to clipboard:', error);
                        return false;
                    }
                }
                
                // Helper function to show copy feedback
                function showCopyFeedback() {
                    showSnackBar('Dimensions copied to clipboard!');
                }
                
                // Helper function to add click-to-copy functionality to tooltips
                function makeTooltipCopyable(layer, textContent) {
                    // Create clean text version (remove HTML tags)
                    const cleanText = textContent.replace(/<br>/g, '\n').replace(/<[^>]*>/g, '');
                    
                    // Add click event to the tooltip
                    layer.on('tooltipopen', function(e) {
                        const tooltip = e.tooltip.getElement();
                        if (tooltip) {
                            tooltip.style.cursor = 'pointer';
                            tooltip.title = 'Click to copy dimensions';
                            
                            // Remove any existing click handlers
                            tooltip.onclick = null;
                            
                            tooltip.onclick = async function() {
                                const success = await copyToClipboard(cleanText);
                                if (success) {
                                    showCopyFeedback();
                                } else {
                                    showSnackBar('Failed to copy to clipboard');
                                }
                            };
                        }
                    });
                }
                
                // Helper function to get timezone information (approximate)
                function getTimezoneInfo(latlng) {
                    // This is a simplified timezone calculation based on longitude
                    // For production, you'd want to use a proper timezone API
                    const utcOffset = Math.round(latlng.lng / 15);
                    const adjustedOffset = Math.max(-12, Math.min(12, utcOffset));
                    const offsetStr = adjustedOffset >= 0 ? `+${adjustedOffset}` : `${adjustedOffset}`;
                    return `UTC${offsetStr}`;
                }
                
                // Helper function to calculate distance between two points
                function calculateDistanceBetweenMarkers(marker1, marker2) {
                    return marker1.getLatLng().distanceTo(marker2.getLatLng());
                }
                
                // Helper function to get nearest marker distance
                function getNearestMarkerDistance(currentMarker) {
                    if (window.globals.markers.length === 0) return null;
                    
                    let minDistance = Infinity;
                    let nearestMarker = null;
                    
                    window.globals.markers.forEach(marker => {
                        if (marker !== currentMarker) {
                            const distance = calculateDistanceBetweenMarkers(currentMarker, marker);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearestMarker = marker;
                            }
                        }
                    });
                    
                    return nearestMarker ? minDistance : null;
                }
                
                // Helper function to calculate bearing between two points
                function calculateBearing(from, to) {
                    const lat1 = from.lat * Math.PI / 180;
                    const lat2 = to.lat * Math.PI / 180;
                    const deltaLng = (to.lng - from.lng) * Math.PI / 180;
                    
                    const y = Math.sin(deltaLng) * Math.cos(lat2);
                    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
                    
                    let bearing = Math.atan2(y, x) * 180 / Math.PI;
                    bearing = (bearing + 360) % 360;
                    
                    return bearing.toFixed(1);
                }
                
                // Helper function to get cardinal direction from bearing
                function getCardinalDirection(bearing) {
                    const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                    const index = Math.round(bearing / 22.5) % 16;
                    return directions[index];
                }
                
                // Custom marker handler to display comprehensive information
                function attachMarkerInfoTooltip(marker) {
                    // Increment marker counter
                    window.globals.markerCounter++;
                    const markerNumber = window.globals.markerCounter;
                    
                    // Get basic location info
                    const latlng = marker.getLatLng();
                    const coords = formatGPSCoordinates(latlng);
                    const timezone = getTimezoneInfo(latlng);
                    const timestamp = new Date().toLocaleString();
                    
                    // Calculate distance to map center
                    const mapCenter = window.globals.map.getCenter();
                    const distanceToCenter = formatDistanceUnits(latlng.distanceTo(mapCenter).toFixed(2));
                    
                    // Calculate distance to nearest marker
                    const nearestDistance = getNearestMarkerDistance(marker);
                    const nearestDistanceText = nearestDistance ? 
                        formatDistanceUnits(nearestDistance.toFixed(2)) : 'No other markers';
                    
                    // Calculate bearing from map center
                    const bearing = calculateBearing(mapCenter, latlng);
                    const direction = getCardinalDirection(parseFloat(bearing));
                    
                    // Get current zoom level
                    const zoomLevel = window.globals.map.getZoom();
                    
                    // Build comprehensive tooltip content
                    let tooltipContent = `<strong>Marker #${markerNumber}</strong><br>`;
                    tooltipContent += `Location: ${coords}<br>`;
                    tooltipContent += `Timezone: ${timezone}<br>`;
                    tooltipContent += `Placed: ${timestamp}<br>`;
                    tooltipContent += `Distance to center: ${distanceToCenter}<br>`;
                    tooltipContent += `Bearing: ${bearing}° (${direction})<br>`;
                    tooltipContent += `Nearest marker: ${nearestDistanceText}<br>`;
                    tooltipContent += `Zoom level: ${zoomLevel}<br>`;
                    tooltipContent += `<em>Click to copy info</em>`;
                    
                    marker.bindTooltip(tooltipContent, {
                        permanent: true,
                        direction: 'top',
                        className: 'marker-info-tooltip'
                    }).openTooltip();
                    
                    // Add click-to-copy functionality
                    makeTooltipCopyable(marker, tooltipContent);
                    
                    // Store marker properties
                    marker.markerNumber = markerNumber;
                    marker.placedAt = timestamp;
                    marker.timezone = timezone;
                    marker.bearingFromCenter = bearing;
                    marker.direction = direction;
                    
                    // Add marker to global array for distance calculations
                    window.globals.markers.push(marker);
                    
                    // Update all existing markers with new nearest distances
                    updateAllMarkerDistances();
                }
                
                // Function to update nearest distances for all markers
                function updateAllMarkerDistances() {
                    window.globals.markers.forEach(marker => {
                        const nearestDistance = getNearestMarkerDistance(marker);
                        const nearestDistanceText = nearestDistance ? 
                            formatDistanceUnits(nearestDistance.toFixed(2)) : 'No other markers';
                        
                        // Update the tooltip content
                        const latlng = marker.getLatLng();
                        const coords = formatGPSCoordinates(latlng);
                        const timezone = getTimezoneInfo(latlng);
                        
                        const mapCenter = window.globals.map.getCenter();
                        const distanceToCenter = formatDistanceUnits(latlng.distanceTo(mapCenter).toFixed(2));
                        const bearing = calculateBearing(mapCenter, latlng);
                        const direction = getCardinalDirection(parseFloat(bearing));
                        const zoomLevel = window.globals.map.getZoom();
                        
                        let tooltipContent = `<strong>Marker #${marker.markerNumber}</strong><br>`;
                        tooltipContent += `Location: ${coords}<br>`;
                        tooltipContent += `Timezone: ${timezone}<br>`;
                        tooltipContent += `Placed: ${marker.placedAt}<br>`;
                        tooltipContent += `Distance to center: ${distanceToCenter}<br>`;
                        tooltipContent += `Bearing: ${bearing}° (${direction})<br>`;
                        tooltipContent += `Nearest marker: ${nearestDistanceText}<br>`;
                        tooltipContent += `Zoom level: ${zoomLevel}<br>`;
                        tooltipContent += `<em>Click to copy info</em>`;
                        
                        // Update tooltip
                        marker.setTooltipContent(tooltipContent);
                        makeTooltipCopyable(marker, tooltipContent);
                    });
                }
                
                // Helper function to get center coordinates for different shape types
                function getShapeCenter(layer) {
                    if (layer instanceof L.Circle) {
                        return layer.getLatLng();
                    } else if (layer instanceof L.Rectangle) {
                        return layer.getBounds().getCenter();
                    } else if (layer instanceof L.Polygon) {
                        // Calculate centroid of polygon
                        const latlngs = layer.getLatLngs();
                        let points = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
                        
                        if (points.length === 0) return null;
                        
                        let latSum = 0, lngSum = 0;
                        points.forEach(point => {
                            latSum += point.lat;
                            lngSum += point.lng;
                        });
                        
                        return L.latLng(latSum / points.length, lngSum / points.length);
                    } else if (layer instanceof L.Polyline) {
                        // Calculate center point of polyline
                        const latlngs = layer.getLatLngs();
                        if (latlngs.length === 0) return null;
                        
                        const midIndex = Math.floor(latlngs.length / 2);
                        return latlngs[midIndex];
                    }
                    return null;
                }
                
                // Helper function to convert area from m² to multiple units
                function formatAreaUnits(areaInM2) {
                    const area = parseFloat(areaInM2);
                    
                    // Conversion factors
                    const toKm2 = area * 0.000001;
                    const toMi2 = area * 0.000000386102;
                    const toHectares = area * 0.0001;
                    const toAcres = area * 0.000247105;
                    
                    // Format based on area size for readability
                    let formattedArea = `${area.toFixed(2)} m²`;
                    
                    if (area >= 10000) { // >= 1 hectare
                        formattedArea += `<br>${toKm2.toFixed(6)} km²`;
                        formattedArea += `<br>${toHectares.toFixed(4)} hectares`;
                        formattedArea += `<br>${toAcres.toFixed(4)} acres`;
                        formattedArea += `<br>${toMi2.toFixed(6)} mi²`;
                    } else if (area >= 1000) { // >= 1000 m²
                        formattedArea += `<br>${toHectares.toFixed(4)} hectares`;
                        formattedArea += `<br>${toAcres.toFixed(4)} acres`;
                    }
                    
                    return formattedArea;
                }
                
                // Custom circle handler to display diameter and area
                function attachCircleDiameterTooltip(circle) {
                    const diameterValue = calculateCircleDiameter(circle);
                    const areaValue = calculateCircleArea(circle);
                    const formattedDiameter = formatDistanceUnits(diameterValue);
                    const formattedArea = formatAreaUnits(areaValue);
                    const center = getShapeCenter(circle);
                    const centerCoords = center ? formatGPSCoordinates(center) : 'N/A';
                    const tooltipContent = `Diameter: ${formattedDiameter}<br>Area: ${formattedArea}<br>Center: ${centerCoords}`;
                    
                    circle.bindTooltip(tooltipContent, {
                        permanent: true,
                        direction: 'bottomleft',
                        className: 'dimension-tooltip'
                    }).openTooltip();
                    
                    // Add click-to-copy functionality
                    makeTooltipCopyable(circle, tooltipContent);
                    
                    // Store the measurements as properties of the circle
                    circle.diameter = diameterValue;
                    circle.area = areaValue;
                    circle.center = centerCoords;
                }
                
                // Helper function to calculate rectangle dimensions and area in meters
                function calculateRectangleDimensions(rectangle) {
                    const bounds = rectangle.getBounds();
                    const northEast = bounds.getNorthEast();
                    const southWest = bounds.getSouthWest();
                    
                    // Calculate the corners
                    const northWest = L.latLng(northEast.lat, southWest.lng);
                    const southEast = L.latLng(southWest.lat, northEast.lng);
                    
                    // Use Leaflet's built-in distance calculation method
                    // Width: distance from northwest to northeast (horizontal)
                    const width = northWest.distanceTo(northEast).toFixed(2);
                    // Height: distance from northwest to southwest (vertical)  
                    const height = northWest.distanceTo(southWest).toFixed(2);
                    
                    // Calculate area
                    const area = (parseFloat(width) * parseFloat(height)).toFixed(2);
                    
                    return { width, height, area };
                }
                
                // Custom rectangle handler to display dimensions and area
                function attachRectangleDimensionsTooltip(rectangle) {
                    const dimensions = calculateRectangleDimensions(rectangle);
                    const formattedWidth = formatDistanceUnits(dimensions.width);
                    const formattedHeight = formatDistanceUnits(dimensions.height);
                    const formattedArea = formatAreaUnits(dimensions.area);
                    const center = getShapeCenter(rectangle);
                    const centerCoords = center ? formatGPSCoordinates(center) : 'N/A';
                    const tooltipContent = `Width: ${formattedWidth}<br>Height: ${formattedHeight}<br>Area: ${formattedArea}<br>Center: ${centerCoords}`;
                    
                    rectangle.bindTooltip(tooltipContent, {
                        permanent: true,
                        direction: 'bottomleft',
                        className: 'dimension-tooltip'
                    }).openTooltip();
                    
                    // Add click-to-copy functionality
                    makeTooltipCopyable(rectangle, tooltipContent);
                    
                    // Store the dimensions as properties of the rectangle
                    rectangle.width = dimensions.width;
                    rectangle.height = dimensions.height;
                    rectangle.area = dimensions.area;
                    rectangle.center = centerCoords;
                }
                
                // Helper function to calculate polygon perimeter and area
                function calculatePolygonMeasurements(polygon) {
                    const latlngs = polygon.getLatLngs();
                    let points = [];
                    
                    // Handle nested arrays for complex polygons
                    if (Array.isArray(latlngs[0])) {
                        points = latlngs[0]; // Use outer ring for measurements
                    } else {
                        points = latlngs;
                    }
                    
                    if (points.length < 3) return { perimeter: 0, area: 0 };
                    
                    // Calculate perimeter
                    let perimeter = 0;
                    for (let i = 0; i < points.length; i++) {
                        const nextIndex = (i + 1) % points.length;
                        perimeter += points[i].distanceTo(points[nextIndex]);
                    }
                    
                    // Calculate area using geodesic area calculation
                    let area = 0;
                    if (typeof L.GeometryUtil !== 'undefined' && L.GeometryUtil.geodesicArea) {
                        area = Math.abs(L.GeometryUtil.geodesicArea(points));
                    }
                    
                    return {
                        perimeter: perimeter.toFixed(2),
                        area: area.toFixed(2)
                    };
                }
                
                // Custom polygon handler to display perimeter and area
                function attachPolygonMeasurementsTooltip(polygon) {
                    const measurements = calculatePolygonMeasurements(polygon);
                    const formattedPerimeter = formatDistanceUnits(measurements.perimeter);
                    const formattedArea = formatAreaUnits(measurements.area);
                    const center = getShapeCenter(polygon);
                    const centerCoords = center ? formatGPSCoordinates(center) : 'N/A';
                    const tooltipContent = `Perimeter: ${formattedPerimeter}<br>Area: ${formattedArea}<br>Center: ${centerCoords}`;
                    
                    polygon.bindTooltip(tooltipContent, {
                        permanent: true,
                        direction: 'bottomleft',
                        className: 'dimension-tooltip'
                    }).openTooltip();
                    
                    // Add click-to-copy functionality
                    makeTooltipCopyable(polygon, tooltipContent);
                    
                    // Store the measurements as properties of the polygon
                    polygon.perimeter = measurements.perimeter;
                    polygon.area = measurements.area;
                    polygon.center = centerCoords;
                }
                
                // Helper function to calculate polyline length
                function calculatePolylineLength(polyline) {
                    const latlngs = polyline.getLatLngs();
                    
                    if (latlngs.length < 2) return 0;
                    
                    let totalLength = 0;
                    for (let i = 0; i < latlngs.length - 1; i++) {
                        totalLength += latlngs[i].distanceTo(latlngs[i + 1]);
                    }
                    
                    return totalLength.toFixed(2);
                }
                
                // Custom polyline handler to display length
                function attachPolylineLengthTooltip(polyline) {
                    const length = calculatePolylineLength(polyline);
                    const formattedLength = formatDistanceUnits(length);
                    const center = getShapeCenter(polyline);
                    const centerCoords = center ? formatGPSCoordinates(center) : 'N/A';
                    const tooltipContent = `Length: ${formattedLength}<br>Center: ${centerCoords}`;
                    
                    polyline.bindTooltip(tooltipContent, {
                        permanent: true,
                        direction: 'bottomleft',
                        className: 'dimension-tooltip'
                    }).openTooltip();
                    
                    // Add click-to-copy functionality
                    makeTooltipCopyable(polyline, tooltipContent);
                    
                    // Store the length as a property of the polyline
                    polyline.length = length;
                    polyline.center = centerCoords;
                }

                // Add custom styles for the dimension tooltips
                const customStyles = document.createElement('style');
                customStyles.textContent = `
                    .dimension-tooltip {
                        background: rgba(0, 0, 0, 0.7);
                        border: none;
                        color: white;
                        font-weight: bold;
                        padding: 4px 8px;
                        border-radius: 4px;
                        font-size: 12px;
                        cursor: pointer;
                        user-select: none;
                        transition: background-color 0.2s ease;
                    }
                    .dimension-tooltip:hover {
                        background: rgba(0, 0, 0, 0.9);
                    }
                    .marker-info-tooltip {
                        background: rgba(0, 51, 102, 0.9);
                        border: 2px solid #007acc;
                        color: white;
                        font-weight: bold;
                        padding: 8px 12px;
                        border-radius: 8px;
                        font-size: 11px;
                        cursor: pointer;
                        user-select: none;
                        transition: all 0.2s ease;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        max-width: 250px;
                        line-height: 1.3;
                    }
                    .marker-info-tooltip:hover {
                        background: rgba(0, 51, 102, 1);
                        border-color: #0099ff;
                    }
                `;
                document.head.appendChild(customStyles);
            } catch (error) {
                console.error('Error initializing document:', error);
                showSnackBar('Error initializing document. Please try refreshing the page.');
            }
        });
    </script>
</body>

</html>
