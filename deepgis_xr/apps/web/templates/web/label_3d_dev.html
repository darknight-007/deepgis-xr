{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model Viewer (DEV VERSION)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .controls-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            max-width: 220px;
            z-index: 100;
        }
        .controls-overlay button {
            display: block;
            margin: 5px 0;
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            font-size: 14px;
        }
        .controls-overlay button:hover {
            background: #45a049;
        }
        .controls-overlay button.active {
            background: #ff4444;
        }
        .button-group {
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .button-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .button-group h3 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #333;
        }
        .view-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 6px;
            margin-bottom: 6px;
        }
        .view-buttons button {
            flex: 0 0 calc(33% - 5px);
            margin: 0;
            padding: 5px;
            font-size: 12px;
        }
        .view-buttons button.camera-mode {
            flex: 0 0 100%;
            margin-top: 5px;
            font-weight: bold;
        }
        .control-mode-label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }
        .model-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }
        .model-info h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .model-info p {
            margin: 5px 0;
            font-size: 14px;
        }
        .keyboard-shortcuts {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        .keyboard-shortcuts h3 {
            margin: 0 0 10px 0;
        }
        .keyboard-shortcuts ul {
            margin: 0;
            padding-left: 20px;
        }
        #annotations {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }
        #annotations h3 {
            margin: 0 0 10px 0;
        }
        #annotations ul {
            margin: 0;
            padding-left: 20px;
        }
        #annotations li {
            margin-bottom: 5px;
        }
        #annotations li.path-measurement {
            color: #FF6600;
            font-weight: bold;
        }
        #annotations li.path-segment {
            color: #FF6600;
            margin-left: 15px;
            font-size: 0.9em;
        }
        .annotation-label {
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        
        /* Path measurement styles */
        .path-point-indicator {
            color: white;
            background-color: rgba(255, 165, 0, 0.8);
            padding: 4px 6px;
            border-radius: 50%;
            font-size: 10px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        .path-total-label {
            color: white;
            background-color: rgba(255, 69, 0, 0.8);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            border: 2px solid white;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .controls-overlay {
                top: 70px;
                left: 10px;
                right: auto;
                bottom: auto;
                max-width: 55px;
                padding: 8px;
                max-height: calc(100vh - 140px);
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                align-items: center;
                background: rgba(40, 40, 40, 0.8);
                border-radius: 10px;
            }
            
            .button-group {
                margin-bottom: 10px;
                padding-bottom: 10px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.2);
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .button-group h3 {
                display: none;
            }
            
            .view-buttons {
                display: flex;
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }
            
            .controls-overlay button,
            .view-buttons button {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                padding: 0;
                margin: 4px 0;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0;
                position: relative;
            }

            .view-buttons button.camera-mode {
                width: 40px;
                flex: 0 0 40px;
                margin: 4px 0;
            }
            
            /* Icons for buttons */
            .btn-icon::before {
                font-family: Arial, sans-serif;
                font-size: 20px;
                display: block;
            }
            
            /* View direction icons */
            #viewFront::before { content: "‚¨ÖÔ∏è"; }
            #viewBack::before { content: "‚û°Ô∏è"; }
            #viewLeft::before { content: "üëÅÔ∏è"; }
            #viewRight::before { content: "üëÅÔ∏è"; }
            #viewTop::before { content: "‚¨áÔ∏è"; }
            #viewBottom::before { content: "‚¨ÜÔ∏è"; }
            
            /* Camera and view mode icons */
            #toggleCameraMode::before { content: "üîç"; }
            #toggleViewMode::before { content: "üëÅÔ∏è"; }
            
            /* Measurement icons */
            #measureMode::before { content: "üìè"; }
            #clearMeasurements::before { content: "üóëÔ∏è"; }
            
            /* Tooltip for mobile buttons */
            .tooltip-text {
                position: absolute;
                left: 50px;
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                white-space: nowrap;
                visibility: hidden;
                opacity: 0;
                transition: opacity 0.3s;
                pointer-events: none;
            }
            
            .controls-overlay button:hover .tooltip-text,
            .controls-overlay button:active .tooltip-text {
                visibility: visible;
                opacity: 1;
            }
            
            /* Model info panel on mobile */
            .model-info {
                display: none;
                position: fixed;
                bottom: 70px;
                left: 10px;
                background: rgba(40, 40, 40, 0.8);
                color: white;
                padding: 10px;
                border-radius: 8px;
                max-width: 200px;
                margin: 0;
                border-top: none;
            }
            
            .model-info p {
                font-size: 12px;
                color: white;
                margin: 3px 0;
            }
            
            #mobileInfo {
                display: block;
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: #3498db;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-top: 10px;
                font-size: 20px;
                cursor: pointer;
            }
            
            /* Mobile floating action buttons - only showing the main one now */
            .mobile-fab {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: #4CAF50;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 30px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                z-index: 200;
            }
            
            /* Special controls for measure mode on mobile */
            .measure-mobile-active .mobile-fab {
                background: #ff4444;
            }
            
            /* Dev indicator */
            .dev-indicator {
                top: 10px !important;
                left: 10px !important;
                padding: 6px 12px !important;
                font-size: 14px !important;
            }
            
            /* Loading indicator */
            #loading {
                font-size: 22px;
                padding: 25px;
            }
            
            /* Annotations panel on mobile */
            #annotations {
                left: 80px;
                right: 20px;
                max-width: calc(100% - 100px);
                bottom: 20px;
                transform: none;
                max-height: 150px;
                background: rgba(40, 40, 40, 0.8);
                color: white;
            }
            
            #annotations h3 {
                font-size: 16px;
                color: white;
                display: none; /* Hide the "Measurements" heading in mobile view */
            }
            
            #annotations li {
                font-size: 14px;
                margin-bottom: 8px;
                color: white;
            }
            
            /* Explicitly hide keyboard shortcuts on mobile */
            .keyboard-shortcuts {
                display: none !important;
            }
            
            /* Larger clear measurements button for mobile */
            #clearMeasurements {
                width: 48px;
                height: 48px;
                background: #ff4444;
                margin: 8px 0;
            }
            
            #clearMeasurements::before {
                font-size: 24px;
            }

            /* Hide the entire measurements button group on mobile */
            .button-group.measurements-group {
                display: none;
            }

            /* Floating action buttons for mobile path measure */
            .mobile-path-fab {
                position: fixed;
                bottom: 20px;
                left: 20px;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: #FF6600;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                z-index: 200;
                display: none; /* Hidden by default */
            }
            
            /* Special controls for path measure mode on mobile */
            .path-measure-mobile-active .mobile-path-fab {
                background: #FF4500;
            }
        }
    </style>
</head>
<body>
    <canvas id="viewer"></canvas>
    <div id="loading">Loading 3D model...</div>
    
    <div style="position: absolute; top: 10px; left: 10px; background-color: #ff4444; color: white; padding: 5px 10px; border-radius: 5px; font-weight: bold; font-family: Arial, sans-serif; z-index: 1000;" class="dev-indicator">
        DEV VERSION
    </div>
    
    <!-- Mobile floating action button (only shows on mobile) -->
    <div class="mobile-fab" id="mobileMeasure" style="display: none;">
        <span>üìè</span>
    </div>
    
    <!-- Mobile floating action button for path measure (only shows on mobile) -->
    <div class="mobile-path-fab" id="mobilePathMeasure" style="display: none;">
        <span>üìç</span>
    </div>
    
    <div class="controls-overlay">
        <div class="button-group">
            <h3>View Controls</h3>
            <div class="view-buttons">
                <button id="viewFront" class="btn-icon">Front<span class="tooltip-text">Front View</span></button>
                <button id="viewBack" class="btn-icon">Back<span class="tooltip-text">Back View</span></button>
                <button id="viewLeft" class="btn-icon">Left<span class="tooltip-text">Left View</span></button>
                <button id="viewRight" class="btn-icon">Right<span class="tooltip-text">Right View</span></button>
                <button id="viewTop" class="btn-icon">Top<span class="tooltip-text">Top View</span></button>
                <button id="viewBottom" class="btn-icon">Bottom<span class="tooltip-text">Bottom View</span></button>
                <button id="toggleCameraMode" class="camera-mode btn-icon">Perspective<span class="tooltip-text">Camera Mode</span></button>
                <button id="toggleViewMode" class="camera-mode btn-icon">View Mode: Transparent<span class="tooltip-text">View Mode</span></button>
            </div>
        </div>
        
        <div class="button-group measurements-group">
            <h3>Measurement</h3>
            <button id="measureMode" class="btn-icon">Measure<span class="tooltip-text">Measure</span></button>
            <button id="clearMeasurements" class="btn-icon">Clear<span class="tooltip-text">Clear Measures</span></button>
            <button id="pathMeasureMode" class="btn-icon">Path Measure<span class="tooltip-text">Measure Along Path</span></button>
        </div>
        
        <!-- Info button for mobile -->
        <button id="mobileInfo" style="display: none;">‚ÑπÔ∏è</button>
        
        <div class="button-group model-info">
            <h3>Model Information</h3>
            <p id="modelName">Loading...</p>
            <p id="modelDimensions">Loading...</p>
            <p id="modelCalibration">Calibration: pending...</p>
        </div>
    </div>

    <div class="keyboard-shortcuts">
        <h3>Keyboard Shortcuts</h3>
        <ul>
            <li>M - Toggle Measure Mode</li>
            <li>C - Clear Measurements</li>
            <li>P - Toggle Camera Mode</li>
            <li>V - Toggle View Mode</li>
            <li>A - Toggle Path Measure Mode</li>
            <li>Space - Hold to rotate without adding points</li>
            <li>Escape - Cancel Current Measurement</li>
            <li>Left-drag - Rotate</li>
            <li>Middle-drag - Pan</li>
            <li>Scroll - Zoom</li>
            <li>Click - Place measurement point</li>
        </ul>
    </div>

    <div id="annotations">
        <h3>Measurements</h3>
        <ul id="measurementsList"></ul>
    </div>

    <!-- Import maps polyfill for browsers without native support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        
        // Check if device is mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Apply mobile-specific adjustments if needed
        if (isMobile) {
            document.getElementById('mobileMeasure').style.display = 'flex';
            document.getElementById('annotations').style.display = 'none'; // Hide initially on mobile
            document.getElementById('mobileInfo').style.display = 'block'; // Show the info button
            
            // Hide keyboard shortcuts on mobile
            const keyboardShortcuts = document.querySelector('.keyboard-shortcuts');
            if (keyboardShortcuts) {
                keyboardShortcuts.style.display = 'none';
            }
            
            // Optimize touch controls
            document.addEventListener('touchstart', function() {
                // Prevent zooming on double tap
                document.querySelector('meta[name="viewport"]').content = 
                    'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            }, {passive: false});
            
            // Add info button functionality
            document.getElementById('mobileInfo').addEventListener('click', function() {
                const modelInfo = document.querySelector('.model-info');
                if (modelInfo.style.display === 'block') {
                    modelInfo.style.display = 'none';
                } else {
                    modelInfo.style.display = 'block';
                }
            });
        }
        
        // Unit for measurements - inches by default
        let currentUnit = 0.0254; // Default unit is inches
        
        // Control states
        let isOrthographic = false;
        
        // Measurement control states
        let isMeasureMode = false;
        let isPathMeasureMode = false;
        let pathMeasurementPoints = [];
        let pathMeasurementLines = [];
        let pathMeasurementLabels = [];
        let pathTotalDistance = 0;
        let pathTotalLabel = null;
        let isRotationKeyPressed = false; // Flag to track if rotation key is pressed
        
        // Set up both cameras: perspective and orthographic
        const perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const orthographicCamera = new THREE.OrthographicCamera(
            window.innerWidth / -100, 
            window.innerWidth / 100, 
            window.innerHeight / 100, 
            window.innerHeight / -100, 
            0.1, 
            1000
        );
        
        // Start with perspective camera
        let camera = perspectiveCamera;
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('viewer'), 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x303040); // Darker blue-gray background for better contrast
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Label renderer
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);
        
        // Enhanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x404050, 1.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.5);
        mainLight.position.set(1, 1, 1);
        scene.add(mainLight);
        
        const secondaryLight = new THREE.DirectionalLight(0xffffff, 1.5);
        secondaryLight.position.set(-1, -1, -1);
        scene.add(secondaryLight);
        
        // Add rim light to enhance edges
        const rimLight = new THREE.DirectionalLight(0xaaccff, 1.0);
        rimLight.position.set(0, 0, -1);
        scene.add(rimLight);
        
        // Add orbit controls with improved configuration
        const controls = new OrbitControls(camera, renderer.domElement);
        setupControls();
        
        function setupControls() {
            // Orbit controls settings
        controls.enableDamping = true;
            controls.dampingFactor = 0.15;
        controls.screenSpacePanning = true;
        controls.minDistance = 0.5;
        controls.maxDistance = 100;
            controls.rotateSpeed = 0.8;
        controls.zoomSpeed = 1.0;
            controls.panSpeed = 0.8;
        controls.enableTouch = true;
            
            // Use standard orbit control configuration for Y-up world
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
            
            // Set mouse buttons
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.PAN,
                RIGHT: THREE.MOUSE.PAN
            };
            
        controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN
        };
        
            // Remove the listener that forces Z-up
            
            // Add events to detect when user starts rotating
            controls.addEventListener('start', handleControlsStart);
        }
        
        // Track if we're in a predefined view
        let inPredefinedView = false;
        
        function handleControlsStart() {
            // If in orthographic mode with aligned grid, reset when user starts manual control
            if (isOrthographic && inPredefinedView) {
                // No longer in a predefined view when user starts rotating manually
                inPredefinedView = false;
            }
        }

        // Model bounds for orthographic sizing
        let modelSize = new THREE.Vector3(10, 10, 10);
        let modelCenter = new THREE.Vector3(0, 0, 0);

        // Add visual helpers
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // UI Controls
        let currentMesh = null;
        let isWireframe = false;
        let isAxesVisible = true;
        let viewMode = 1; // 0: solid, 1: transparent, 2: wireframe - default to transparent
        
        // Measurement variables
        let measurementPoints = [];
        let measurementLine = null;
        let measurements = [];
        let measurementLabels = [];
        let previewLine = null; // For showing line before second point is clicked
        let previewLabel = null; // For showing distance before second point is clicked
        const raycaster = new THREE.Raycaster();
        raycaster.params.Line.threshold = 0.1; // Increase line detection threshold
        raycaster.params.Points.threshold = 0.1; // Increase point detection threshold
        const mouse = new THREE.Vector2();
        const measurementGroup = new THREE.Group();
        scene.add(measurementGroup);

        // Debug visualization for raycaster
        let rayVisualization = null;

        document.getElementById('measureMode').addEventListener('click', toggleMeasureMode);
        document.getElementById('clearMeasurements').addEventListener('click', clearMeasurements);
        document.getElementById('toggleViewMode').addEventListener('click', toggleViewMode);
        document.getElementById('pathMeasureMode').addEventListener('click', togglePathMeasureMode);

        // Enhanced keyboard controls
        document.addEventListener('keydown', (event) => {
            switch(event.key.toLowerCase()) {
                case 'm':
                    toggleMeasureMode();
                    break;
                case 'c':
                    clearMeasurements();
                    break;
                case 'p':
                    toggleCameraMode();
                    break;
                case 'v':
                    toggleViewMode();
                    break;
                case 'a':
                    togglePathMeasureMode();
                    break;
                case '2':
                    setViewBack();
                    break;
                case '3':
                    setViewLeft();
                    break;
                case '4':
                    setViewRight();
                    break;
                case '5':
                    setViewTop();
                    break;
                case '6':
                    setViewBottom();
                    break;

                case ' ': // Space key
                    // Allow rotation without adding points when space is pressed
                    isRotationKeyPressed = true;
                    // Prevent page scrolling with space
                    event.preventDefault();
                    break;
                case 'escape':
                    if (isPathMeasureMode && pathMeasurementPoints.length > 0) {
                        cancelPathMeasurement();
                    } else {
                        cancelCurrentMeasurement();
                    }
                    break;
            }
        });

        // Add keyup listener for rotation key
        document.addEventListener('keyup', (event) => {

            if (event.key === ' ') { // Space key
                isRotationKeyPressed = false;
            }
        });

        // Mouse event listeners for measurements
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        
        function onPointerDown(event) {
            if (!isMeasureMode && !isPathMeasureMode) return;
            
            // Skip point placement if rotation key is pressed
            if (isPathMeasureMode && isRotationKeyPressed) return;

            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray
            raycaster.setFromCamera(mouse, camera);
            
            // Visualize the ray for debugging (remove in production)
            visualizeRay(raycaster.ray);
            
            let intersectionPoint = null;

            // For path measurement, we always want to intersect with the model if possible
            if (isPathMeasureMode && currentMesh) {
                // Try to intersect directly with the mesh first
                const meshIntersects = raycaster.intersectObject(currentMesh, true);
                
                if (meshIntersects.length > 0) {
                    // We got a direct hit on the mesh
                    intersectionPoint = meshIntersects[0].point.clone();
                    console.log("Direct mesh hit at:", intersectionPoint);
                    
                    // Adjust point position for any model transformations
                    const modelWorldMatrix = new THREE.Matrix4();
                    currentMesh.updateMatrixWorld(true);
                    currentMesh.getWorldPosition(new THREE.Vector3()); // Force matrix update
                    
                    addPathMeasurementPoint(intersectionPoint);
                    return;
                }
                
                // If direct intersection failed, try all scene objects
                const sceneIntersects = raycaster.intersectObjects(scene.children, true);
                
                // Filter for valid mesh-related intersections
                const validIntersections = sceneIntersects.filter(hit => {
                    // Check if the hit object is the mesh, part of it, or a child
                    let current = hit.object;
                    while (current) {
                        if (current === currentMesh) return true;
                        current = current.parent;
                    }
                    return false;
                });
                
                if (validIntersections.length > 0) {
                    intersectionPoint = validIntersections[0].point.clone();
                    console.log("Scene hit on:", validIntersections[0].object.name || "unnamed object");
                    addPathMeasurementPoint(intersectionPoint);
                    return;
                } else {
                    console.log("No valid intersection found with mesh or its children");
                    return; // Don't add a point if we didn't hit the mesh
                }
            }
            
            // Existing regular measurement mode logic
            if (isMeasureMode) {
                // In orthographic mode, always place points on the orthographic plane
                if (isOrthographic) {
                    // Get the ray from the raycaster
                    const ray = raycaster.ray;
                    
                    // Find the center point of the scene
                    const sceneCenter = modelCenter ? modelCenter.clone() : new THREE.Vector3(0, 0, 0);
                    
                    // Project ray to the plane defined by sceneCenter and camera direction
                    const planeNormal = new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3()));
                    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, sceneCenter);
                    
                    // Find where the ray intersects this plane
                    intersectionPoint = new THREE.Vector3();
                    ray.intersectPlane(plane, intersectionPoint);
                    
                    // If for some reason we didn't get an intersection, fall back to model or default
                    if (!intersectionPoint) {
                        // Try model intersection
                        if (currentMesh) {
                            const modelIntersects = raycaster.intersectObject(currentMesh, true);
                            if (modelIntersects.length > 0) {
                                intersectionPoint = modelIntersects[0].point.clone();
                            }
                        }
                        
                        // If still no point, create one at a standard distance
                        if (!intersectionPoint) {
                            intersectionPoint = new THREE.Vector3();
                            intersectionPoint.copy(ray.origin);
                            intersectionPoint.addScaledVector(ray.direction, 10);
                        }
                    }
                } 
                // In perspective mode, check for model intersection first, then fall back to ray
                else {
                    // Try to find an intersection with the model first
                    if (currentMesh) {
                        const intersects = raycaster.intersectObject(currentMesh, true);
                        if (intersects.length > 0) {
                            intersectionPoint = intersects[0].point.clone();
                        }
                    }
                    
                    // If no intersection, create a point in 3D space at a reasonable distance
                    if (!intersectionPoint) {
                        const ray = raycaster.ray;
                        intersectionPoint = new THREE.Vector3();
                        intersectionPoint.copy(ray.origin);
                        intersectionPoint.addScaledVector(ray.direction, 10); // Standard distance
                    }
                }
                
                // Add the measurement point
                addMeasurementPoint(intersectionPoint);
            }
        }
        
        function onPointerMove(event) {
            if (!isMeasureMode || measurementPoints.length === 0) return;
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray
            raycaster.setFromCamera(mouse, camera);
            
            let intersectionPoint = null;
            
            // Same intersection logic as in onPointerDown
            if (isOrthographic) {
                const ray = raycaster.ray;
                const sceneCenter = modelCenter ? modelCenter.clone() : new THREE.Vector3(0, 0, 0);
                const planeNormal = new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3()));
                const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, sceneCenter);
                
                intersectionPoint = new THREE.Vector3();
                ray.intersectPlane(plane, intersectionPoint);
                
                if (!intersectionPoint) {
                    if (currentMesh) {
                        const modelIntersects = raycaster.intersectObject(currentMesh, true);
                        if (modelIntersects.length > 0) {
                            intersectionPoint = modelIntersects[0].point.clone();
                        }
                    }
                    
                    if (!intersectionPoint) {
                        intersectionPoint = new THREE.Vector3();
                        intersectionPoint.copy(ray.origin);
                        intersectionPoint.addScaledVector(ray.direction, 10);
                    }
                }
            } else {
                if (currentMesh) {
                    const intersects = raycaster.intersectObject(currentMesh, true);
                    if (intersects.length > 0) {
                        intersectionPoint = intersects[0].point.clone();
                    }
                }
                
                if (!intersectionPoint) {
                    const ray = raycaster.ray;
                    intersectionPoint = new THREE.Vector3();
                    intersectionPoint.copy(ray.origin);
                    intersectionPoint.addScaledVector(ray.direction, 10);
                }
            }
            
            // Update preview line
            updatePreviewLine(measurementPoints[0], intersectionPoint);
        }
        
        function updatePreviewLine(point1, point2) {
            // Remove existing preview if any
            if (previewLine) {
                measurementGroup.remove(previewLine);
                previewLine = null;
            }
            
            if (previewLabel) {
                measurementGroup.remove(previewLabel);
                previewLabel = null;
            }
            
            // Create a more visible preview line between points
            const material = new THREE.LineDashedMaterial({ 
                color: 0x3498db, // Light blue for preview
                dashSize: 0.12, 
                gapSize: 0.06,
                linewidth: 2
            });
            const geometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            previewLine = new THREE.Line(geometry, material);
            previewLine.computeLineDistances(); // Required for dashed lines
            measurementGroup.add(previewLine);
            
            // Calculate distance for preview
            const distance = point1.distanceTo(point2);
            
            // Calculate midpoint
            const midpoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
            
            // Calculate the direction vector of the line
            const direction = new THREE.Vector3().subVectors(point2, point1).normalize();
            
            // Calculate a perpendicular vector in the up direction to offset the label
            // Use world up vector and cross product to find perpendicular direction
            const worldUp = new THREE.Vector3(0, 1, 0);
            const perpendicular = new THREE.Vector3().crossVectors(direction, worldUp).normalize();
            
            // If perpendicular is too small (line is vertical), use a different axis
            if (perpendicular.length() < 0.1) {
                const worldRight = new THREE.Vector3(1, 0, 0);
                perpendicular.crossVectors(direction, worldRight).normalize();
            }
            
            // Apply a larger offset to position label above the line
            const labelOffset = 0.25; // Distance above the line
            const labelPosition = midpoint.clone().addScaledVector(perpendicular, labelOffset);
            
            // Create enhanced preview label
            const labelDiv = document.createElement('div');
            labelDiv.className = 'annotation-label';
            labelDiv.style.opacity = '0.9';
            labelDiv.style.padding = '3px 6px';
            labelDiv.style.fontSize = '13px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.backgroundColor = 'rgba(52, 152, 219, 0.7)'; // Light blue background
            labelDiv.style.border = '1px dashed rgba(255, 0, 0, 0.7)'; // Dashed red border
            labelDiv.textContent = getMeasurementText(distance);
            previewLabel = new CSS2DObject(labelDiv);
            previewLabel.position.copy(labelPosition);
            measurementGroup.add(previewLabel);
        }
        
        function addMeasurementPoint(point) {
            // Add a more prominent crosshair marker at the point
            const markerGroup = new THREE.Group();
            markerGroup.position.copy(point);
            
            // Create larger crosshair marker (three perpendicular lines)
            const markerSize = 0.08; // Increased size of the crosshair arms
            const primaryColor = 0x4caf50; // Light green (replacing red)
            const secondaryColor = 0x3498db; // Light blue
            
            // Primary color lines (light green)
            const primaryMaterial = new THREE.LineBasicMaterial({ color: primaryColor, linewidth: 3 });
            
            // X axis line (light green)
            const xGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-markerSize, 0, 0),
                new THREE.Vector3(markerSize, 0, 0)
            ]);
            const xLine = new THREE.Line(xGeometry, primaryMaterial);
            markerGroup.add(xLine);
            
            // Y axis line (light green)
            const yGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -markerSize, 0),
                new THREE.Vector3(0, markerSize, 0)
            ]);
            const yLine = new THREE.Line(yGeometry, primaryMaterial);
            markerGroup.add(yLine);
            
            // Z axis line (light green)
            const zGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -markerSize),
                new THREE.Vector3(0, 0, markerSize)
            ]);
            const zLine = new THREE.Line(zGeometry, primaryMaterial);
            markerGroup.add(zLine);
            
            // Secondary color lines (light blue) - slightly offset for visibility
            const secondaryMaterial = new THREE.LineBasicMaterial({ color: secondaryColor, linewidth: 1.5 });
            const offset = 0.01; // Small offset for the second set of lines
            
            // X axis line (light blue)
            const xGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-markerSize, offset, offset),
                new THREE.Vector3(markerSize, offset, offset)
            ]);
            const xLine2 = new THREE.Line(xGeometry2, secondaryMaterial);
            markerGroup.add(xLine2);
            
            // Y axis line (light blue)
            const yGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(offset, -markerSize, offset),
                new THREE.Vector3(offset, markerSize, offset)
            ]);
            const yLine2 = new THREE.Line(yGeometry2, secondaryMaterial);
            markerGroup.add(yLine2);
            
            // Z axis line (light blue)
            const zGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(offset, offset, -markerSize),
                new THREE.Vector3(offset, offset, markerSize)
            ]);
            const zLine2 = new THREE.Line(zGeometry2, secondaryMaterial);
            markerGroup.add(zLine2);
            
            // Sphere at center - make it larger and two-toned
            const sphereGeometry = new THREE.SphereGeometry(0.02);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: primaryColor });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            markerGroup.add(sphere);
            
            // Outer sphere (light blue halo)
            const outerSphereGeometry = new THREE.SphereGeometry(0.03);
            const outerSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: secondaryColor,
                transparent: true,
                opacity: 0.5
            });
            const outerSphere = new THREE.Mesh(outerSphereGeometry, outerSphereMaterial);
            markerGroup.add(outerSphere);
            
            measurementGroup.add(markerGroup);
            measurementPoints.push(point);
            
            // If we have two points, create a measurement and clean up preview
            if (measurementPoints.length === 2) {
                // Clean up preview
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                
                if (previewLabel) {
                    measurementGroup.remove(previewLabel);
                    previewLabel = null;
                }
                
                createMeasurement(measurementPoints[0], measurementPoints[1]);
                measurementPoints = []; // Reset for the next measurement
            }
        }
        
        function createMeasurement(point1, point2) {
            // Create a more prominent line between points with dual colors
            const primaryColor = 0x4caf50; // Light green (replacing red)
            const secondaryColor = 0x3498db; // Light blue
            
            // Create primary measurement line (light green)
            const primaryMaterial = new THREE.LineBasicMaterial({ 
                color: primaryColor, 
                linewidth: 3 
            });
            const geometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            const line = new THREE.Line(geometry, primaryMaterial);
            measurementGroup.add(line);
            
            // Create secondary line (light blue) with slight offset for visibility
            const offset = new THREE.Vector3(0.01, 0.01, 0.01);
            const secondaryMaterial = new THREE.LineBasicMaterial({ 
                color: secondaryColor, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            
            // Create slightly offset points for the secondary line
            const offsetPoint1 = point1.clone().add(offset);
            const offsetPoint2 = point2.clone().add(offset);
            
            const secondaryGeometry = new THREE.BufferGeometry().setFromPoints([offsetPoint1, offsetPoint2]);
            const secondaryLine = new THREE.Line(secondaryGeometry, secondaryMaterial);
            measurementGroup.add(secondaryLine);
            
            // Calculate distance (model units)
            const distance = point1.distanceTo(point2);
            
            // Calculate midpoint
            const midpoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
            
            // Calculate the direction vector of the line
            const direction = new THREE.Vector3().subVectors(point2, point1).normalize();
            
            // Calculate a perpendicular vector in the up direction to offset the label
            // Use world up vector and cross product to find perpendicular direction
            const worldUp = new THREE.Vector3(0, 1, 0);
            const perpendicular = new THREE.Vector3().crossVectors(direction, worldUp).normalize();
            
            // If perpendicular is too small (line is vertical), use a different axis
            if (perpendicular.length() < 0.1) {
                const worldRight = new THREE.Vector3(1, 0, 0);
                perpendicular.crossVectors(direction, worldRight).normalize();
            }
            
            // Apply a larger offset to position label well above the line
            const labelOffset = 0.25; // Distance above the line
            const labelPosition = midpoint.clone().addScaledVector(perpendicular, labelOffset);
            
            // Create enhanced label at offset position
            const labelDiv = document.createElement('div');
            labelDiv.className = 'annotation-label';
            labelDiv.style.padding = '5px 8px';
            labelDiv.style.fontSize = '14px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.color = 'white';
            labelDiv.style.textShadow = '1px 1px 1px rgba(0,0,0,0.5)';
            labelDiv.style.backgroundColor = 'rgba(52, 152, 219, 0.8)'; // Light blue with transparency
            labelDiv.style.border = '2px solid rgba(76, 175, 80, 0.7)'; // Light green border (replacing red)
            labelDiv.textContent = getMeasurementText(distance);
            const label = new CSS2DObject(labelDiv);
            label.position.copy(labelPosition);
            measurementGroup.add(label);
            measurementLabels.push(label);
            
            // Store the measurement with all components
            const measurementData = {
                point1: point1.clone(),
                point2: point2.clone(),
                distance: distance,
                line: line,
                secondaryLine: secondaryLine,
                label: label
            };
            measurements.push(measurementData);
            
            // Update the measurements list
            updateMeasurementsList();
        }
        
        function updateMeasurementsList() {
            const list = document.getElementById('measurementsList');
            list.innerHTML = '';
            
            // Add regular measurements
            measurements.forEach((measurement, index) => {
                const listItem = document.createElement('li');
                listItem.textContent = `Measurement ${index + 1}: ${getMeasurementText(measurement.distance)}`;
                list.appendChild(listItem);
            });
            
            // Add path measurement total if active
            if (pathMeasurementPoints.length > 1) {
                const listItem = document.createElement('li');
                listItem.className = 'path-measurement';
                listItem.textContent = `Path Total: ${getMeasurementText(pathTotalDistance)}`;
                list.appendChild(listItem);
                
                // Add segment measurements
                for (let i = 1; i < pathMeasurementPoints.length; i++) {
                    const segmentDistance = pathMeasurementPoints[i-1].distanceTo(pathMeasurementPoints[i]);
                    const segmentItem = document.createElement('li');
                    segmentItem.className = 'path-segment';
                    segmentItem.textContent = `Segment ${i}: ${getMeasurementText(segmentDistance)}`;
                    list.appendChild(segmentItem);
                }
            }
        }
        
        function clearMeasurements() {
            // Remove all measurement objects
            while (measurementGroup.children.length > 0) {
                const object = measurementGroup.children[0];
                measurementGroup.remove(object);
            }
            
            // Clear arrays
            measurements = [];
            measurementPoints = [];
            measurementLabels = [];
            
            // Clear path measurement arrays
            pathMeasurementPoints = [];
            pathMeasurementLines = [];
            pathMeasurementLabels = [];
            pathTotalDistance = 0;
            pathTotalLabel = null;
            
            // Clear preview variables
            previewLine = null;
            previewLabel = null;
            
            // Update UI
            updateMeasurementsList();
        }
        
        function cancelCurrentMeasurement() {
            // Only operate if in measure mode and there's an unfinished measurement
            // (i.e., exactly one point placed waiting for the second point)
            if (isMeasureMode && measurementPoints.length === 1) {
                // Remove just the first placed point (the unfinished endpoint)
                // Find the most recently added marker in the measurementGroup
                let markerIndex = -1;
                
                // Find the marker object - it should be the most recently added non-preview object
                for (let i = measurementGroup.children.length - 1; i >= 0; i--) {
                    const obj = measurementGroup.children[i];
                    if (obj !== previewLine && obj !== previewLabel) {
                        markerIndex = i;
                        break;
                    }
                }
                
                // If we found the marker, remove it
                if (markerIndex >= 0) {
                    measurementGroup.remove(measurementGroup.children[markerIndex]);
                }
                
                // Clear any preview
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                
                if (previewLabel) {
                    measurementGroup.remove(previewLabel);
                    previewLabel = null;
                }
                
                // Reset measurement points
                measurementPoints = [];
                
                console.log("Unfinished measurement cancelled");
            }
        }
        
        function toggleMeasureMode() {
            // If path measure mode is active, turn it off
            if (isPathMeasureMode) {
                togglePathMeasureMode();
            }

            isMeasureMode = !isMeasureMode;
            const measureButton = document.getElementById('measureMode');
            measureButton.classList.toggle('active', isMeasureMode);
            
            // Update mobile floating action button if on mobile
            if (isMobile) {
                document.getElementById('mobileMeasure').classList.toggle('measure-mobile-active', isMeasureMode);
                document.body.classList.toggle('measure-mobile-active', isMeasureMode);
                // Always show annotations in measure mode on mobile
                document.getElementById('annotations').style.display = isMeasureMode ? 'block' : 'none';
                
                // Show tooltip with instructions when entering measure mode
                if (isMeasureMode) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'mobile-tooltip';
                    tooltip.textContent = 'Double-tap to clear measurements';
                    tooltip.style.position = 'fixed';
                    tooltip.style.bottom = '85px';
                    tooltip.style.right = '20px';
                    tooltip.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    tooltip.style.color = 'white';
                    tooltip.style.padding = '8px 12px';
                    tooltip.style.borderRadius = '4px';
                    tooltip.style.fontSize = '14px';
                    tooltip.style.zIndex = '1000';
                    document.body.appendChild(tooltip);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        if (tooltip.parentNode) {
                            document.body.removeChild(tooltip);
                        }
                    }, 3000);
                }
            }
            
            if (isMeasureMode) {
                controls.enableRotate = false;
                measureButton.textContent = `Exit Measure Mode`;
            } else {
                controls.enableRotate = true;
                measureButton.textContent = 'Measure';
                
                // Clean up any in-progress measurements
                measurementPoints = [];
                
                // Clean up preview line if it exists
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                
                if (previewLabel) {
                    measurementGroup.remove(previewLabel);
                    previewLabel = null;
                }
            }
        }
        
        function getMeasurementText(distance) {
            // Convert to both inches and centimeters
            const inches = (distance / 0.0254).toFixed(2);
            const cm = (distance / 0.01).toFixed(2);
            
            // On mobile, make the text more concise
            if (isMobile) {
                return `${inches}"/${cm}cm`;
            }
            
            return `${inches} in / ${cm} cm`;
        }
        
        function resetCamera() {
            if (currentMesh) {
                const boundingBox = currentMesh.geometry.boundingBox;
                const maxDim = Math.max(
                    boundingBox.max.x - boundingBox.min.x,
                    boundingBox.max.y - boundingBox.min.y,
                    boundingBox.max.z - boundingBox.min.z
                );
                const distance = maxDim * 0.8;
                
                // Reset camera position with smooth transition
                const targetPosition = new THREE.Vector3(distance, -distance * 0.7, distance * 0.5);
                const targetLookAt = new THREE.Vector3(0, 0, 0);
                
                // Animate camera movement
                const duration = 1000; // 1 second
                const startTime = Date.now();
                const startPosition = camera.position.clone();
                const startLookAt = controls.target.clone();
                
                function animateCamera() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease in-out function
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    controls.target.lerpVectors(startLookAt, targetLookAt, easeProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    }
                    
                    camera.up.set(0, 0, 1);
                    controls.update();
                }
                
                animateCamera();
            }
        }

        function toggleViewMode() {
            if (!currentMesh) return;
            
            // Cycle through view modes: 0: solid, 1: transparent, 2: wireframe
            viewMode = (viewMode + 1) % 3;
            
            const modeButton = document.getElementById('toggleViewMode');
            
            switch(viewMode) {
                case 0: // Solid
                    currentMesh.material.wireframe = false;
                    currentMesh.material.transparent = true;
                    currentMesh.material.opacity = 0.95;
                    modeButton.textContent = "View Mode: Solid";
                    break;
                    
                case 1: // Transparent
                    currentMesh.material.wireframe = false;
                    currentMesh.material.transparent = true;
                    currentMesh.material.opacity = 0.5;
                    modeButton.textContent = "View Mode: Transparent";
                    break;
                    
                case 2: // Wireframe
                    currentMesh.material.wireframe = true;
                    currentMesh.material.transparent = true;
                    currentMesh.material.opacity = 0.7;
                    modeButton.textContent = "View Mode: Wireframe";
                    break;
            }
        }

        function toggleAxes() {
            isAxesVisible = !isAxesVisible;
            axesHelper.visible = isAxesVisible;
        }

        // Loading timeout
        const loadingTimeout = setTimeout(() => {
            if (document.getElementById('loading').style.display !== 'none') {
                document.getElementById('loading').textContent = 'Loading is taking longer than expected. Please try refreshing the page.';
            }
        }, 30000);

        // Load STL model
        const loader = new STLLoader();
        loader.load("{% static 'models/stl/navagunjara-reborn-gometric-analysis.stl' %}", function (geometry) {
            clearTimeout(loadingTimeout);
            document.getElementById('loading').style.display = 'none';
            
            // Compute vertex normals if they don't exist
            if (!geometry.hasAttribute('normal')) {
                geometry.computeVertexNormals();
            }
            
            // Ensure we have a bounding box
            geometry.computeBoundingBox();
            
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xdddddd, // Lighter color for the model
                specular: 0x444444, // More moderate specular highlights
                shininess: 40, // Less shiny for more diffuse appearance
                wireframe: false, // Default to solid mode instead of wireframe
                flatShading: false, // Enable smooth shading
                transparent: true, // Keep transparency
                opacity: 0.5, // Set to 50% transparent by default
                side: THREE.DoubleSide // Render both sides of faces
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = "MainModel"; // Name the mesh for debugging
            currentMesh = mesh;
            
            // Add edge highlighting for better visibility
            const edges = new THREE.EdgesGeometry(geometry, 30); // 30-degree threshold
            const edgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x222222, 
                linewidth: 1 
            });
            const wireframe = new THREE.LineSegments(edges, edgeMaterial);
            wireframe.name = "ModelEdges"; // Name for debugging
            mesh.add(wireframe);
            
            // Make sure the mesh is set up for raycasting
            mesh.geometry.computeBoundingSphere();
            mesh.geometry.computeVertexNormals();
            
            // Only compute tangents if we have all required attributes
            if (geometry.hasAttribute('position') && 
                geometry.hasAttribute('normal') && 
                geometry.hasAttribute('uv') && 
                geometry.index !== null) {
                mesh.geometry.computeTangents();
            }
            
            mesh.matrixAutoUpdate = true;
            mesh.updateMatrixWorld(true);
            
            // Center the model
            geometry.computeBoundingBox();
            const boundingBox = geometry.boundingBox;
            
            // In Y-up world, we need to transform the model
            // Rotate the model 90 degrees around X-axis to convert from Z-up to Y-up
            mesh.rotation.x = -Math.PI / 2;
            
            // Apply rotation to bounding box to get correct extents
            const rotatedHeight = boundingBox.max.y - boundingBox.min.y;
            const rotatedWidth = boundingBox.max.x - boundingBox.min.x;
            const rotatedDepth = boundingBox.max.z - boundingBox.min.z;
            
            // Force the mesh to update its world matrix to apply the rotation
            mesh.updateMatrixWorld(true);
            
            // Calculate the bounding box of the rotated model
            const rotatedBox = new THREE.Box3().setFromObject(mesh);
            
            // Get the center of the rotated bounding box
            const rotatedCenter = new THREE.Vector3();
            rotatedBox.getCenter(rotatedCenter);
            
            // Calculate the size of the rotated bounding box
            const rotatedSize = new THREE.Vector3();
            rotatedBox.getSize(rotatedSize);
            
            // Position the model so that:
            // 1. Its bottom is at y=0 (on the XZ plane)
            // 2. It's centered on the X and Z axes
            mesh.position.set(
                -rotatedCenter.x, 
                -rotatedBox.min.y,  // This places the bottom at y=0
                -rotatedCenter.z
            );
            
            // Force another update after repositioning
            mesh.updateMatrixWorld(true);
            
            // Calculate the final bounding box for verification
            const finalBox = new THREE.Box3().setFromObject(mesh);
            const finalCenter = new THREE.Vector3();
            finalBox.getCenter(finalCenter);
            
            // Store the model center for orbit controls
            modelCenter = new THREE.Vector3(0, finalBox.getSize(new THREE.Vector3()).y/2, 0);
            
            console.log("Initial bounding box:", boundingBox);
            console.log("Rotated bounding box:", rotatedBox);
            console.log("Final bounding box:", finalBox);
            console.log("Model centered at:", modelCenter);
            
            // Get the actual height of the model for scaling
            const modelHeight = rotatedSize.y;
            const targetHeight = 4.28; // Target height in meters
            const scaleFactor = targetHeight / modelHeight;
            
            // Apply scaling to the model to make it the correct height
            mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            
            // Store model size for orthographic camera (Y-up world, so Y is height)
            modelSize = new THREE.Vector3(
                (boundingBox.max.x - boundingBox.min.x) * scaleFactor,
                (boundingBox.max.y - boundingBox.min.y) * scaleFactor,
                (boundingBox.max.z - boundingBox.min.z) * scaleFactor
            );
            
            // Set unit to inches by default (we're calibrated to real-world meters)
            currentUnit = 0.0254; // Default to inches
            
            scene.add(mesh);
            
            // Update model information with scaled dimensions
            const dimensions = {
                x: ((boundingBox.max.x - boundingBox.min.x) * scaleFactor).toFixed(2),
                y: ((boundingBox.max.y - boundingBox.min.y) * scaleFactor).toFixed(2),
                z: ((boundingBox.max.z - boundingBox.min.z) * scaleFactor).toFixed(2)
            };
            
            document.getElementById('modelName').textContent = 'Navagunjara Reborn';
            
            // More concise text for mobile
            if (isMobile) {
                document.getElementById('modelDimensions').textContent = 
                    `Size: ${dimensions.x}√ó${dimensions.y}√ó${dimensions.z}m`;
                document.getElementById('modelCalibration').textContent = 
                    `Height: 4.28m (√ó${scaleFactor.toFixed(2)})`;
            } else {
                document.getElementById('modelDimensions').textContent = 
                    `Dimensions: ${dimensions.x} √ó ${dimensions.y} √ó ${dimensions.z} meters`;
                document.getElementById('modelCalibration').textContent = 
                    `Calibrated height: 4.28 meters (scale factor: ${scaleFactor.toFixed(4)})`;
            }
            
            // Adjust camera to fit the model (centered and fully visible)
            const size = new THREE.Vector3(
                (boundingBox.max.x - boundingBox.min.x) * scaleFactor,
                (boundingBox.max.y - boundingBox.min.y) * scaleFactor,
                (boundingBox.max.z - boundingBox.min.z) * scaleFactor
            );
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 0.5; // Reduced from 0.7 to 0.5 for extreme close-up
            
            // Camera position: standard position for Y-up world
            perspectiveCamera.position.set(distance, distance, distance);
            perspectiveCamera.up.set(0, 1, 0); // Standard Y-up
            perspectiveCamera.lookAt(modelCenter);
            
            updateOrthographicCamera();
            
            controls.target.copy(modelCenter);
            controls.update();
            
            // Initialize to left view (showing front of the object)
            setTimeout(() => {
                setViewLeft();
            }, 100); // Small delay to ensure everything is initialized
            
        }, 
        function(xhr) {
            if (xhr.lengthComputable) {
                const percent = Math.round((xhr.loaded / xhr.total) * 100);
                document.getElementById('loading').textContent = `Loading 3D model: ${percent}%`;
            }
        }, 
        function (error) {
            clearTimeout(loadingTimeout);
            document.getElementById('loading').textContent = 'Error loading model. Please try refreshing the page.';
            console.error('An error occurred loading the STL file:', error);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();

        // Handle window resize with better support for mobile devices
        window.addEventListener('resize', function() {
            const aspect = window.innerWidth / window.innerHeight;
            
            // Check if the device has switched between mobile and desktop view
            const nowMobile = window.innerWidth < 768;
            if (nowMobile !== isMobile) {
                location.reload(); // Reload the page to apply all mobile optimizations
                return;
            }
            
            // Update perspective camera
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();
            
            // Update orthographic camera
            updateOrthographicCamera();
            
            // Update renderers
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // View control functions
        function toggleCameraMode() {
            isOrthographic = !isOrthographic;
            
            if (isOrthographic) {
                // Switch to orthographic
                updateOrthographicCamera();
                camera = orthographicCamera;
                document.getElementById('toggleCameraMode').textContent = 'Orthographic';
            } else {
                // Switch to perspective
                camera = perspectiveCamera;
                document.getElementById('toggleCameraMode').textContent = 'Perspective';
            }
            
            // Update orbit controls
            controls.object = camera;
            controls.update();
        }
        
        function updateOrthographicCamera() {
            // Adjust orthographic camera based on model size and current view
            const aspect = window.innerWidth / window.innerHeight;
            const zoom = 0.5; // Reduced zoom from 0.7 to 0.5 for extreme close-up
            const largestDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            
            orthographicCamera.left = -largestDim * zoom * aspect;
            orthographicCamera.right = largestDim * zoom * aspect;
            orthographicCamera.top = largestDim * zoom;
            orthographicCamera.bottom = -largestDim * zoom;
            orthographicCamera.near = -1000;
            orthographicCamera.far = 1000;
            orthographicCamera.position.copy(perspectiveCamera.position);
            orthographicCamera.quaternion.copy(perspectiveCamera.quaternion);
            orthographicCamera.updateProjectionMatrix();
        }
        
        // Orthographic view functions - updated for object's actual orientation
        function setViewFront() {
            // Front view shows object's left side (from -X)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.z, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(-distance, modelCenter.y, 0);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewBack() {
            // Back view shows object's right side (from +X)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.z, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(distance, modelCenter.y, 0);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewLeft() {
            // Left view shows object's front (from +Z)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, modelCenter.y, distance);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewRight() {
            // Right view shows object's back (from -Z)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, modelCenter.y, -distance);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewTop() {
            // Top view looks at the model from +Y
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.z);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, distance, 0);
            const targetUp = new THREE.Vector3(0, 0, -1);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewBottom() {
            // Bottom view looks at the model from -Y
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.z);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, -distance, 0);
            const targetUp = new THREE.Vector3(0, 0, 1);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        // Helper function to get consistent model extents
        function getModelExtents() {
            if (!currentMesh) {
                return { x: 10, y: 10, z: 10 };
            }
            
            // Get the bounding box of the model
            currentMesh.geometry.computeBoundingBox();
            const boundingBox = currentMesh.geometry.boundingBox;
            
            // Account for the scaling and rotation
            const sx = currentMesh.scale.x;
            const sy = currentMesh.scale.y;
            const sz = currentMesh.scale.z;
            
            // Since we rotated 90 degrees around X-axis, the dimensions are transformed
            return {
                x: (boundingBox.max.x - boundingBox.min.x) * sx,
                y: (boundingBox.max.y - boundingBox.min.y) * sy,
                z: (boundingBox.max.z - boundingBox.min.z) * sz
            };
        }
        
        // Shared camera view setting function
        function setCameraView(position, target, up) {
            // Apply to both cameras
            perspectiveCamera.position.copy(position);
            perspectiveCamera.up.copy(up);
            perspectiveCamera.lookAt(target);
            
            orthographicCamera.position.copy(position);
            orthographicCamera.up.copy(up);
            orthographicCamera.lookAt(target);
            updateOrthographicCamera();
            
            // Update controls
            controls.target.copy(target);
            
            // Switch to orthographic mode for predefined views
            if (!isOrthographic) {
                toggleCameraMode(); // This will switch to orthographic
            }
            
            // Mark that we're in a predefined view
            inPredefinedView = true;
            
            controls.update();
        }

        // Add view button event listeners
        document.getElementById('viewFront').addEventListener('click', setViewFront);
        document.getElementById('viewBack').addEventListener('click', setViewBack);
        document.getElementById('viewLeft').addEventListener('click', setViewLeft);
        document.getElementById('viewRight').addEventListener('click', setViewRight);
        document.getElementById('viewTop').addEventListener('click', setViewTop);
        document.getElementById('viewBottom').addEventListener('click', setViewBottom);
        document.getElementById('toggleCameraMode').addEventListener('click', toggleCameraMode);

        // Mobile-specific event handlers
        if (isMobile) {
            document.getElementById('mobileMeasure').addEventListener('click', toggleMeasureMode);
            document.getElementById('mobilePathMeasure').addEventListener('click', togglePathMeasureMode);
            
            // Use the floating action button as the primary measure button on mobile
            const mobileMeasureBtn = document.getElementById('mobileMeasure');
            mobileMeasureBtn.style.display = 'flex';
            
            // Show the path measure button on mobile
            const mobilePathMeasureBtn = document.getElementById('mobilePathMeasure');
            mobilePathMeasureBtn.style.display = 'flex';
            
            // Add a double-tap functionality to the measure FAB for clearing measurements
            let lastTapTime = 0;
            mobileMeasureBtn.addEventListener('click', function(e) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap detected - clear measurements
                    clearMeasurements();
                    e.preventDefault();
                }
                
                lastTapTime = currentTime;
            });
            
            // Add the same double-tap functionality to the path measure FAB
            let lastPathTapTime = 0;
            mobilePathMeasureBtn.addEventListener('click', function(e) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastPathTapTime;
                
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap detected - clear path measurements
                    clearMeasurements();
                    e.preventDefault();
                }
                
                lastPathTapTime = currentTime;
            });
            
            // Show active state on the FAB when in measure mode
            if (isMeasureMode) {
                mobileMeasureBtn.classList.add('measure-mobile-active');
            }
            
            // Show active state on the path FAB when in path measure mode
            if (isPathMeasureMode) {
                mobilePathMeasureBtn.classList.add('path-measure-mobile-active');
            }
            
            // Add tap to show/hide annotations on mobile
            document.addEventListener('click', function(e) {
                // If we're in measure mode, keep annotations visible
                if (isMeasureMode) {
                    document.getElementById('annotations').style.display = 'block';
                } else {
                    // Toggle annotations based on tap position - if not tapping a control
                    if (!e.target.closest('.controls-overlay') && 
                        !e.target.closest('#annotations') && 
                        !e.target.closest('.mobile-fab')) {
                        const annotations = document.getElementById('annotations');
                        annotations.style.display = annotations.style.display === 'none' ? 'block' : 'none';
                    }
                }
            });
        }

        // Path measurement functions
        function togglePathMeasureMode() {
            // If regular measure mode is active, turn it off
            if (isMeasureMode) {
                toggleMeasureMode();
            }

            isPathMeasureMode = !isPathMeasureMode;
            const pathMeasureButton = document.getElementById('pathMeasureMode');
            pathMeasureButton.classList.toggle('active', isPathMeasureMode);
            
            // Update mobile floating action button if on mobile
            if (isMobile) {
                document.getElementById('mobilePathMeasure').classList.toggle('path-measure-mobile-active', isPathMeasureMode);
                document.body.classList.toggle('path-measure-mobile-active', isPathMeasureMode);
                // Always show annotations in path measure mode on mobile
                document.getElementById('annotations').style.display = isPathMeasureMode ? 'block' : 'none';
            }
            
            if (isPathMeasureMode) {
                controls.enableRotate = true; // Allow rotation in path measure mode
                pathMeasureButton.textContent = `Exit Path Measure`;
                
                // Create a small notification to instruct the user
                const notification = document.createElement('div');
                notification.style.position = 'fixed';
                notification.style.top = '50%';
                notification.style.left = '50%';
                notification.style.transform = 'translate(-50%, -50%)';
                notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                notification.style.color = 'white';
                notification.style.padding = '10px 15px';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                notification.style.fontFamily = 'Arial, sans-serif';
                notification.style.fontSize = '16px';
                notification.textContent = isMobile ? 
                    'Path Measure: Tap to add points, rotate to view, double-tap to clear' : 
                    'Path Measure Mode: Click to place points. Hold Space to rotate without adding points.';
                document.body.appendChild(notification);
                
                // Remove the notification after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 3000);
            } else {
                pathMeasureButton.textContent = 'Path Measure';
                
                // Clean up any in-progress path measurements
                cancelPathMeasurement();
            }
        }

        function addPathMeasurementPoint(point) {
            if (!isPathMeasureMode) return;
            
            // Add a marker at the clicked point
            const markerGroup = new THREE.Group();
            markerGroup.position.copy(point);
            
            // Create a more visible marker
            // Create a small sphere as a marker - using smaller size
            const sphereGeometry = new THREE.SphereGeometry(0.03);  // Reduced from 0.05
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF6600, 
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            markerGroup.add(sphere);
            
            // Add a wireframe sphere for better visibility from any angle - also smaller
            const wireframeGeometry = new THREE.SphereGeometry(0.035); // Reduced from 0.06
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            const wireframeSphere = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            markerGroup.add(wireframeSphere);
            
            // Add a number label to the point
            const labelDiv = document.createElement('div');
            labelDiv.className = 'path-point-indicator';
            labelDiv.textContent = pathMeasurementPoints.length + 1;
            const label = new CSS2DObject(labelDiv);
            label.position.set(0, 0.15, 0); // Position slightly above the point
            markerGroup.add(label);
            
            measurementGroup.add(markerGroup);
            pathMeasurementLabels.push(label);
            
            // Add the point to our array
            pathMeasurementPoints.push(point);
            
            // If this is not the first point, create a line to the previous point
            if (pathMeasurementPoints.length > 1) {
                const prevPoint = pathMeasurementPoints[pathMeasurementPoints.length - 2];
                const currentPoint = point;
                
                // Create a line between the points
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xFF6600, 
                    linewidth: 3 
                });
                const geometry = new THREE.BufferGeometry().setFromPoints([prevPoint, currentPoint]);
                const line = new THREE.Line(geometry, lineMaterial);
                measurementGroup.add(line);
                pathMeasurementLines.push(line);
                
                // Create a slightly thicker line for better visibility
                const thickLineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x000000, 
                    linewidth: 5,
                    transparent: true,
                    opacity: 0.3
                });
                const thickGeometry = new THREE.BufferGeometry().setFromPoints([prevPoint, currentPoint]);
                const thickLine = new THREE.Line(thickGeometry, thickLineMaterial);
                measurementGroup.add(thickLine);
                pathMeasurementLines.push(thickLine);
                
                // Calculate the distance between these two points
                const segmentDistance = prevPoint.distanceTo(currentPoint);
                pathTotalDistance += segmentDistance;
                
                // Create or update the total distance label
                updatePathTotalLabel();
                
                // Update the measurements list
                updateMeasurementsList();
            }
        }

        function updatePathTotalLabel() {
            // Remove existing total label if it exists
            if (pathTotalLabel) {
                measurementGroup.remove(pathTotalLabel);
            }
            
            // Only create a label if we have at least one line
            if (pathMeasurementPoints.length > 1) {
                // Create a label at the last point
                const lastPoint = pathMeasurementPoints[pathMeasurementPoints.length - 1];
                
                const labelDiv = document.createElement('div');
                labelDiv.className = 'path-total-label';
                labelDiv.textContent = `Total: ${getMeasurementText(pathTotalDistance)}`;
                pathTotalLabel = new CSS2DObject(labelDiv);
                
                // Position the label above the last point
                pathTotalLabel.position.copy(lastPoint);
                pathTotalLabel.position.y += 0.25; // Place it slightly above the point
                
                measurementGroup.add(pathTotalLabel);
            }
        }

        function cancelPathMeasurement() {
            // Clean up any path measurement visuals
            for (let i = measurementGroup.children.length - 1; i >= 0; i--) {
                const child = measurementGroup.children[i];
                
                // Check if this object is part of our path measurement
                let isPathObject = false;
                
                // Check if the object is a pathMeasurementLine
                for (let j = 0; j < pathMeasurementLines.length; j++) {
                    if (child === pathMeasurementLines[j]) {
                        isPathObject = true;
                        break;
                    }
                }
                
                // Check if the object contains a pathMeasurementLabel
                if (!isPathObject) {
                    for (let j = 0; j < pathMeasurementLabels.length; j++) {
                        if (child.children && child.children.includes(pathMeasurementLabels[j])) {
                            isPathObject = true;
                            break;
                        }
                    }
                }
                
                // Check if it's the total label
                if (!isPathObject && child === pathTotalLabel) {
                    isPathObject = true;
                }
                
                // Remove path measurement objects
                if (isPathObject) {
                    measurementGroup.remove(child);
                }
            }

            // Clear arrays
            pathMeasurementPoints = [];
            pathMeasurementLines = [];
            pathMeasurementLabels = [];
            
            // Remove the total label
            if (pathTotalLabel) {
                measurementGroup.remove(pathTotalLabel);
                pathTotalLabel = null;
            }
            
            // Reset total distance
            pathTotalDistance = 0;
            
            // Update the measurements list
            updateMeasurementsList();
        }

        // Debug function to visualize the ray being cast
        function visualizeRay(ray) {
            // Remove existing visualization
            if (rayVisualization) {
                scene.remove(rayVisualization);
                rayVisualization = null;
            }
            
            // Create line from ray origin extending in ray direction
            const rayLength = 1000;
            const endPoint = new THREE.Vector3().copy(ray.origin).addScaledVector(ray.direction, rayLength);
            const geometry = new THREE.BufferGeometry().setFromPoints([ray.origin, endPoint]);
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0xff00ff, 
                linewidth: 2,
                transparent: true,
                opacity: 0.6
            });
            
            rayVisualization = new THREE.Line(geometry, material);
            scene.add(rayVisualization);
            
            // Auto-remove after a short delay
            setTimeout(() => {
                if (rayVisualization) {
                    scene.remove(rayVisualization);
                    rayVisualization = null;
                }
            }, 1000);
        }
    </script>
</body>
</html>
