{% load static %}

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Model Viewer (DEV VERSION)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .controls-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(40, 40, 40, 0.85);
            padding: 20px 15px;
            box-shadow: -2px 0 15px rgba(0,0,0,0.2);
            font-family: Arial, sans-serif;
            width: 250px;
            z-index: 100;
            color: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .controls-overlay button {
            display: block;
            margin: 8px 0;
            padding: 10px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            border-left: 4px solid transparent;
            text-align: center;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls-overlay button:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        .controls-overlay button.active {
            background: #e53935;
            border-left: 4px solid #ffeb3b;
        }
        .button-group {
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding-bottom: 15px;
        }
        .button-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .button-group h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            position: relative;
            padding-bottom: 8px;
        }
        
        .button-group h3:after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 2px;
            background: #4CAF50;
        }
        
        /* Measurement subgroups styling */
        .measurement-subgroup {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed rgba(255,255,255,0.15);
        }
        
        .measurement-subgroup:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .measurement-subgroup h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #fff;
            font-weight: 600;
            text-align: center;
            background: rgba(0,0,0,0.2);
            padding: 6px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .measurement-btn, .utility-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            margin: 8px 0;
            padding: 12px;
            text-align: left;
            font-size: 14px;
            border-radius: 6px;
        }
        
        .measurement-icon {
            margin-right: 10px;
            font-size: 18px;
        }
        
        .btn-text {
            text-align: left;
            flex-grow: 1;
        }
        
        /* Color-coding measurement buttons */
        .measurement-btn {
            background: #43a047;
            border-left: 4px solid #1b5e20;
        }
        
        .utility-btn {
            background: #5c6bc0;
            border-left: 4px solid #3949ab;
        }
        
        /* Enhanced active state */
        .measurement-btn.active {
            background: #e53935;
            box-shadow: 0 0 8px rgba(0,0,0,0.4);
            position: relative;
            border-left: 4px solid #ffeb3b;
            transform: translateY(-1px);
        }
        
        .measurement-btn.active::after {
            content: "‚óè ACTIVE";
            position: absolute;
            top: -8px;
            right: 8px;
            font-size: 10px;
            background: #e53935;
            color: white;
            padding: 3px 6px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            font-weight: bold;
        }
        .view-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            margin-bottom: 15px;
        }
        .view-buttons button {
            margin: 0;
            padding: 12px 5px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 42px;
        }
        .view-buttons button.camera-mode {
            grid-column: 1 / span 3;
            margin-top: 10px;
            font-weight: bold;
            padding: 12px 5px;
            background: #3949ab;
        }
        .view-buttons button.camera-mode:hover {
            background: #303f9f;
        }
        .control-mode-label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }
        .model-info {
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.15);
            background: rgba(0,0,0,0.2);
            margin-left: -15px;
            margin-right: -15px;
            margin-bottom: -20px;
            padding: 15px;
        }
        .model-info h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .model-info p {
            margin: 8px 0;
            font-size: 14px;
            color: rgba(255,255,255,0.9);
            font-weight: 300;
        }
        .keyboard-shortcuts {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
        }
        .keyboard-shortcuts h3 {
            margin: 0 0 10px 0;
        }
        .keyboard-shortcuts ul {
            margin: 0;
            padding-left: 20px;
        }
        #annotations {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-family: Arial, sans-serif;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }
        #annotations h3 {
            margin: 0 0 10px 0;
        }
        #annotations ul {
            margin: 0;
            padding-left: 20px;
        }
        #annotations li {
            margin-bottom: 5px;
        }
        #annotations li.path-measurement {
            color: #FF6600;
            font-weight: bold;
        }
        #annotations li.path-segment {
            color: #FF6600;
            margin-left: 15px;
            font-size: 0.9em;
        }
        .annotation-label {
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        
        /* Path measurement styles */
        .path-point-indicator {
            color: white;
            background-color: rgba(255, 165, 0, 0.8);
            padding: 4px 6px;
            border-radius: 50%;
            font-size: 10px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        
        /* Combined marker style - number is part of the marker */
        .path-marker-label {
            color: white;
            background-color: rgba(255, 140, 0, 0.9);
            padding: 4px 6px;
            border-radius: 50%;
            font-size: 10px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            border: 1px solid rgba(255, 255, 255, 0.7);
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Preview marker style */
        .path-preview-marker {
            color: white;
            background-color: rgba(100, 200, 255, 0.8);
            padding: 4px 6px;
            border-radius: 50%;
            font-size: 10px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            border: 1px dashed rgba(255, 255, 255, 0.7);
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .path-total-label {
            color: white;
            background-color: rgba(255, 69, 0, 0.8);
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            border: 2px solid white;
        }
        
        /* Sidebar toggle button */
        .sidebar-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(40, 40, 40, 0.8);
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .sidebar-toggle {
                display: none;
            }
            
            /* Hide the desktop control panel completely */
            .controls-overlay {
                display: none;
            }
            
            /* Mobile floating controls */
            .mobile-floating-controls {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 100;
                pointer-events: none; /* Let touches pass through to the 3D viewer */
            }
            
            /* Main controls group (right side) */
            .mobile-controls-group {
                position: absolute;
                display: flex;
                flex-direction: column;
                gap: 16px; /* Increased gap for better touch separation */
                pointer-events: auto; /* Allow interacting with the buttons */
            }
            
            /* Position groups */
            .mobile-controls-right {
                top: 50%;
                right: 20px; /* Move further from edge for easier access */
                transform: translateY(-50%);
            }
            
            .mobile-controls-left {
                top: 50%;
                left: 20px; /* Move further from edge for easier access */
                transform: translateY(-50%);
            }
            
            .mobile-controls-bottom {
                bottom: 20px; /* Move further from edge */
                left: 50%;
                transform: translateX(-50%);
                flex-direction: row;
                gap: 16px; /* Increased horizontal gap */
            }
            
            .mobile-controls-top {
                top: 70px; /* Below the DEV indicator */
                left: 20px; /* Move further from edge */
            }
            
            /* Floating button style with enhanced touch area */
            .mobile-floating-btn {
                width: 56px; /* Larger size for better touch target */
                height: 56px;
                border-radius: 50%;
                background: rgba(0, 0, 0, 0.7); /* Darker for better contrast */
                border: 2px solid rgba(255, 255, 255, 0.6);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px; /* Larger icons */
                margin: 0;
                padding: 0;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* Enhanced shadow */
                transition: all 0.2s ease;
                position: relative; /* For badge positioning */
            }
            
            /* Fallback for browsers without backdrop-filter support */
            @supports (backdrop-filter: blur(4px)) {
                .mobile-floating-btn {
                    backdrop-filter: blur(4px);
                    background: rgba(0, 0, 0, 0.5);
                }
                
                .mobile-model-info, 
                .mobile-measurements-display, 
                .mobile-view-cube {
                    backdrop-filter: blur(4px);
                    background: rgba(0, 0, 0, 0.5);
                }
            }
            
            .mobile-floating-btn:active {
                transform: scale(0.92);
                background: rgba(0, 0, 0, 0.8);
            }
            
            .mobile-floating-btn.active {
                background: rgba(229, 57, 53, 0.9);
                border-color: rgba(255, 255, 255, 0.9);
                box-shadow: 0 0 16px rgba(229, 57, 53, 0.5);
            }
            
            /* Measurement results badge */
            .measurement-result-badge {
                position: absolute;
                top: -6px;
                right: -6px;
                background: #4CAF50;
                color: white;
                font-size: 14px; /* Larger text */
                width: 24px; /* Larger badge */
                height: 24px;
                border-radius: 50%;
                display: none;
                justify-content: center;
                align-items: center;
                font-weight: bold;
                border: 1px solid white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                z-index: 2; /* Ensure above button */
                pointer-events: auto; /* Ensure clickable */
            }
            
            .measurement-result-badge.active {
                display: flex;
            }
            
            /* Model info panel on mobile */
            .mobile-model-info {
                position: absolute;
                bottom: 20px;
                left: 20px;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 10px 14px;
                border-radius: 10px;
                font-size: 12px; /* Slightly larger */
                max-width: 150px;
                pointer-events: auto;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }
            
            .mobile-model-info p {
                margin: 4px 0; /* More space between lines */
                font-size: 12px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            /* Mobile measurements display */
            .mobile-measurements-display {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.9);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 18px;
                border-radius: 16px;
                font-size: 16px;
                max-height: 0;
                min-width: 250px;
                max-width: 85%;
                overflow: hidden;
                transition: all 0.3s ease-out;
                z-index: 200;
                opacity: 0;
                pointer-events: none; /* Initially can't be interacted with */
                border: 2px solid rgba(255, 255, 255, 0.3);
            }
            
            .mobile-measurements-display.active {
                max-height: 70vh; /* Limit height to 70% of viewport */
                overflow-y: auto;
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
                pointer-events: auto; /* Allow interaction when shown */
            }
            
            /* Add close button to measurements display */
            .mobile-measurements-display::before {
                content: "√ó";
                position: absolute;
                top: 8px;
                right: 12px;
                font-size: 24px;
                font-weight: bold;
                color: rgba(255, 255, 255, 0.8);
                cursor: pointer;
            }
            
            /* View cube for 3D navigation */
            .mobile-view-cube {
                position: absolute;
                bottom: 20px;
                right: 20px;
                width: 70px; /* Larger for easier tapping */
                height: 70px;
                background: rgba(0, 0, 0, 0.7); 
                border-radius: 12px;
                pointer-events: auto;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 1fr 1fr 1fr;
                gap: 4px;
                padding: 5px;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }
            
            .cube-face {
                width: auto;
                height: auto;
                background: rgba(255, 255, 255, 0.25);
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                font-weight: bold;
                cursor: pointer;
                color: white;
            }
            
            .cube-face:active {
                background: rgba(255, 255, 255, 0.5);
            }
            
            /* Grid positioning for cube faces */
            #mobileFront { grid-area: 2 / 2 / 3 / 3; }
            #mobileBack { grid-area: 2 / 3 / 3 / 4; }
            #mobileLeft { grid-area: 2 / 1 / 3 / 2; }
            #mobileRight { grid-area: 2 / 3 / 3 / 4; } /* This needs to be adjusted */
            #mobileTop { grid-area: 1 / 2 / 2 / 3; }
            #mobileBottom { grid-area: 3 / 2 / 4 / 3; }

            /* Fix overlap issue with back/right buttons */
            #mobileRight { grid-row: 1; grid-column: 3; }
            
            /* Hide keyboard shortcuts on mobile */
            .keyboard-shortcuts {
                display: none !important;
            }
            
            /* Ensure annotations are hidden */
            #annotations {
                display: none !important; 
            }
        }
    </style>
</head>
<body>
    <canvas id="viewer"></canvas>
    <div id="loading">Loading 3D model...</div>
    
    <!-- Remove this sidebar toggle button -->
    <button class="sidebar-toggle" id="sidebarToggle" style="display: none;">
        ‚ò∞
    </button>
    
    <div style="position: absolute; top: 10px; left: 10px; background-color: #ff4444; color: white; padding: 5px 10px; border-radius: 5px; font-weight: bold; font-family: Arial, sans-serif; z-index: 1000;" class="dev-indicator">
        DEV VERSION
    </div>
    
    <!-- Remove these mobile floating action buttons -->
    <!--
    <div class="mobile-fab" id="mobileMeasure" style="display: none;">
        <span>üìè</span>
    </div>
    
    <div class="mobile-path-fab" id="mobilePathMeasure" style="display: none;">
        <span>üìç</span>
    </div>
    
    <div class="mobile-path-complete-fab" id="mobileCompletePath" style="display: none; right: 90px; bottom: 20px;">
        <span>‚úîÔ∏è</span>
    </div>
    -->
    
    <!-- Mobile measurements display -->
    <div class="mobile-measurements-display" id="mobileMeasurementsDisplay">
        <div id="mobileMeasurementsList"></div>
    </div>
    
    <!-- Mobile floating controls - only visible on mobile -->
    <div class="mobile-floating-controls" id="mobileControls" style="display: none;">
        <!-- Right side controls - Measurement tools -->
        <div class="mobile-controls-group mobile-controls-right">
            <button id="mobileMeasureMode" class="mobile-floating-btn">üìè
                <span id="mobileMeasureBadge" class="measurement-result-badge">0</span>
            </button>
            <button id="mobilePathMeasureMode" class="mobile-floating-btn">üìç</button>
            <button id="mobileCompletePath" class="mobile-floating-btn">‚úì</button>
            <button id="mobileClearMeasurements" class="mobile-floating-btn">üóëÔ∏è</button>
        </div>
        
        <!-- Left side controls - View modes -->
        <div class="mobile-controls-group mobile-controls-left">
            <button id="mobileToggleViewMode" class="mobile-floating-btn">üëÅÔ∏è</button>
            <button id="mobileToggleCameraMode" class="mobile-floating-btn">üîç</button>
        </div>
        
        <!-- View cube for navigation -->
        <div class="mobile-view-cube">
            <div class="cube-face" id="mobileFront">F</div>
            <div class="cube-face" id="mobileBack">B</div>
            <div class="cube-face" id="mobileLeft">L</div>
            <div class="cube-face" id="mobileRight">R</div>
            <div class="cube-face" id="mobileTop">T</div>
            <div class="cube-face" id="mobileBottom">B</div>
        </div>
        
        <!-- Mobile model info -->
        <div class="mobile-model-info">
            <p id="mobileModelName">Loading...</p>
            <p id="mobileModelDimensions">Loading...</p>
        </div>
    </div>
    
    <div class="controls-overlay">
        <div class="mobile-toolbar-section views-section">
        <div class="button-group">
            <h3>View Controls</h3>
            <div class="view-buttons">
                <button id="viewFront" class="btn-icon"><span class="tooltip-text">Front</span></button>
                <button id="viewBack" class="btn-icon"><span class="tooltip-text">Back</span></button>
                <button id="viewLeft" class="btn-icon"><span class="tooltip-text">Left</span></button>
                <button id="viewRight" class="btn-icon"><span class="tooltip-text">Right</span></button>
                <button id="viewTop" class="btn-icon"><span class="tooltip-text">Top</span></button>
                <button id="viewBottom" class="btn-icon"><span class="tooltip-text">Bottom</span></button>
                <button id="toggleCameraMode" class="camera-mode btn-icon">Perspective<span class="tooltip-text">Camera</span></button>
                <button id="toggleViewMode" class="camera-mode btn-icon">Transparent<span class="tooltip-text">View</span></button>
                </div>
            </div>
        </div>
        
        <div class="mobile-toolbar-section measurements-section">
        <div class="button-group measurements-group">
            <h3>Measurement</h3>
            
            <!-- Point Measurement Group -->
            <div class="measurement-subgroup">
                <h4>Point-to-Point</h4>
                <button id="measureMode" class="btn-icon measurement-btn">
                    <span class="measurement-icon">üìè</span>
                    <span class="btn-text">Point Measure</span>
                    <span class="tooltip-text">Measure distance between two points</span>
                </button>
                <button id="clearMeasurements" class="btn-icon utility-btn">
                    <span class="measurement-icon">üóëÔ∏è</span>
                    <span class="btn-text">Clear All</span>
                    <span class="tooltip-text">Clear all measurements</span>
                </button>
                    
                    <!-- Measurement Results Badge -->
                    <span id="measurementResultsBadge" class="measurement-result-badge">0</span>
            </div>
            
            <!-- Path Measurement Group -->
            <div class="measurement-subgroup">
                <h4>Multi-Point Path</h4>
                <button id="pathMeasureMode" class="btn-icon measurement-btn">
                    <span class="measurement-icon">üìç</span>
                    <span class="btn-text">Path Measure</span>
                    <span class="tooltip-text">Measure along a path with multiple connected points</span>
                </button>
                <button id="completePath" class="btn-icon utility-btn">
                    <span class="measurement-icon">‚úì</span>
                    <span class="btn-text">Complete Path</span>
                    <span class="tooltip-text">Complete current path and start a new one</span>
                </button>
                </div>
            </div>
        </div>
        
        <!-- Info button for mobile -->
        <button id="mobileInfo" style="display: none;">‚ÑπÔ∏è</button>
        
        <div class="button-group model-info">
            <h3>Model Information</h3>
            <p id="modelName">Loading...</p>
            <p id="modelDimensions">Loading...</p>
            <p id="modelCalibration">Calibration: pending...</p>
        </div>
    </div>

    <div class="keyboard-shortcuts">
        <h3>Keyboard Shortcuts</h3>
        <ul>
            <li>M - Toggle Measure Mode</li>
            <li>C - Clear Measurements</li>
            <li>P - Toggle Camera Mode</li>
            <li>V - Toggle View Mode</li>
            <li>A - Toggle Path Measure Mode</li>
            <li>F - Complete Current Path</li>
            <li>2 - View Back</li>
            <li>3 - View Left</li>
            <li>4 - View Right</li>
            <li>5 - View Top</li>
            <li>6 - View Bottom</li>
            <li>Space - Hold to rotate without adding points</li>
            <li>Escape - Cancel Current Measurement</li>
            <li>Left-drag - Rotate</li>
            <li>Right-drag - Pan</li>
            <li>Scroll - Zoom</li>
            <li>Click - Place measurement point</li>
        </ul>
    </div>

    <div id="annotations">
        <h3>Measurements</h3>
        <ul id="measurementsList"></ul>
    </div>

    <!-- Import maps polyfill for browsers without native support -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        
        // Check if device is mobile
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // Apply mobile-specific adjustments if needed
        if (isMobile) {
            // Hide keyboard shortcuts on mobile
            const keyboardShortcuts = document.querySelector('.keyboard-shortcuts');
            if (keyboardShortcuts) {
                keyboardShortcuts.style.display = 'none';
            }
            
            // Optimize touch controls
            document.addEventListener('touchstart', function() {
                // Prevent zooming on double tap
                document.querySelector('meta[name="viewport"]').content = 
                    'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            }, {passive: false});
            
            // Show annotations in mobile view
            const annotations = document.getElementById('annotations');
            if (annotations) {
                annotations.style.display = 'block';
                }
        }
        
        // Unit for measurements - inches by default
        let currentUnit = 0.0254; // Default unit is inches
        
        // Control states
        let isOrthographic = false;
        
        // Measurement control states
        let isMeasureMode = false;
        let isPathMeasureMode = false;
        let pathMeasurementPoints = [];
        let pathMeasurementLines = [];
        let pathMeasurementLabels = [];
        let pathTotalDistance = 0;
        let pathTotalLabel = null;
        let isRotationKeyPressed = false; // Flag to track if rotation key is pressed
        let pathPreviewMarker = null; // Preview marker for potential intersection point
        
        // Add multi-path storage
        let completedPaths = []; // Array to store multiple completed paths
        let currentPathId = 0; // ID for the current path
        
        // Set up both cameras: perspective and orthographic
        const perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const orthographicCamera = new THREE.OrthographicCamera(
            window.innerWidth / -100, 
            window.innerWidth / 100, 
            window.innerHeight / 100, 
            window.innerHeight / -100, 
            0.1, 
            1000
        );
        
        // Start with perspective camera
        let camera = perspectiveCamera;
        
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('viewer'), 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x303040); // Darker blue-gray background for better contrast
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Label renderer
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);
        
        // Enhanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x404050, 1.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.5);
        mainLight.position.set(1, 1, 1);
        scene.add(mainLight);
        
        const secondaryLight = new THREE.DirectionalLight(0xffffff, 1.5);
        secondaryLight.position.set(-1, -1, -1);
        scene.add(secondaryLight);
        
        // Add rim light to enhance edges
        const rimLight = new THREE.DirectionalLight(0xaaccff, 1.0);
        rimLight.position.set(0, 0, -1);
        scene.add(rimLight);
        
        // Add orbit controls with improved configuration
        const controls = new OrbitControls(camera, renderer.domElement);
        setupControls();
        
        function setupControls() {
            // Orbit controls settings
        controls.enableDamping = true;
            controls.dampingFactor = 0.15;
        controls.screenSpacePanning = true;
        controls.minDistance = 0.5;
        controls.maxDistance = 100;
            controls.rotateSpeed = 0.8;
        controls.zoomSpeed = 1.0;
            controls.panSpeed = 0.8;
        controls.enableTouch = true;
            
            // Use standard orbit control configuration for Y-up world
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
            
            // Set mouse buttons
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.PAN,
                RIGHT: THREE.MOUSE.PAN
            };
            
        controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN
        };
        
            // Remove the listener that forces Z-up
            
            // Add events to detect when user starts rotating
            controls.addEventListener('start', handleControlsStart);
        }
        
        // Track if we're in a predefined view
        let inPredefinedView = false;
        
        function handleControlsStart() {
            // If in orthographic mode with aligned grid, reset when user starts manual control
            if (isOrthographic && inPredefinedView) {
                // No longer in a predefined view when user starts rotating manually
                inPredefinedView = false;
            }
        }

        // Model bounds for orthographic sizing
        let modelSize = new THREE.Vector3(10, 10, 10);
        let modelCenter = new THREE.Vector3(0, 0, 0);

        // Add visual helpers
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // UI Controls
        let currentMesh = null;
        let isWireframe = false;
        let isAxesVisible = true;
        let viewMode = 1; // 0: solid, 1: transparent, 2: wireframe - default to transparent
        
        // Measurement variables
        let measurementPoints = [];
        let measurementLine = null;
        let measurements = [];
        let measurementLabels = [];
        let previewLine = null; // For showing line before second point is clicked
        let previewLabel = null; // For showing distance before second point is clicked
        const raycaster = new THREE.Raycaster();
        raycaster.params.Line.threshold = 0.1; // Increase line detection threshold
        raycaster.params.Points.threshold = 0.1; // Increase point detection threshold
        const mouse = new THREE.Vector2();
        const measurementGroup = new THREE.Group();
        scene.add(measurementGroup);

        // Debug visualization for raycaster
        let rayVisualization = null;

        document.getElementById('measureMode').addEventListener('click', toggleMeasureMode);
        document.getElementById('clearMeasurements').addEventListener('click', clearMeasurements);
        document.getElementById('toggleViewMode').addEventListener('click', toggleViewMode);
        document.getElementById('pathMeasureMode').addEventListener('click', togglePathMeasureMode);
        document.getElementById('completePath').addEventListener('click', completeCurrentPath);

        // Enhanced keyboard controls
        document.addEventListener('keydown', (event) => {
            switch(event.key.toLowerCase()) {
                case 'm':
                    toggleMeasureMode();
                    break;
                case 'c':
                    clearMeasurements();
                    break;
                case 'p':
                    toggleCameraMode();
                    break;
                case 'v':
                    toggleViewMode();
                    break;
                case 'a':
                    togglePathMeasureMode();
                    break;
                case 'f':
                    completeCurrentPath();
                    break;
                case '2':
                    setViewBack();
                    break;
                case '3':
                    setViewLeft();
                    break;
                case '4':
                    setViewRight();
                    break;
                case '5':
                    setViewTop();
                    break;
                case '6':
                    setViewBottom();
                    break;

                case ' ': // Space key
                    // Allow rotation without adding points when space is pressed
                    isRotationKeyPressed = true;
                    // Prevent page scrolling with space
                    event.preventDefault();
                    break;
                case 'escape':
                    if (isPathMeasureMode && pathMeasurementPoints.length > 0) {
                        // Only cancel the in-progress path measurement but keep completed ones
                        cancelInProgressPathMeasurement();
                    } else {
                        cancelCurrentMeasurement();
                    }
                    break;
            }
        });

        // Add keyup listener for rotation key
        document.addEventListener('keyup', (event) => {

            if (event.key === ' ') { // Space key
                isRotationKeyPressed = false;
            }
        });

        // Mouse event listeners for measurements
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        
        function onPointerDown(event) {
            if (!isMeasureMode && !isPathMeasureMode) return;
            
            // Skip point placement if rotation key is pressed
            if (isPathMeasureMode && isRotationKeyPressed) return;

            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray
            raycaster.setFromCamera(mouse, camera);
            
            // Visualize the ray for debugging (remove in production)
            visualizeRay(raycaster.ray);
            
            let intersectionPoint = null;

            // For path measurement, we always want to intersect with the model if possible
            if (isPathMeasureMode && currentMesh) {
                // Ensure the mesh's matrix is up to date
                currentMesh.updateMatrixWorld(true);
                
                // Cast ray against the entire mesh hierarchy
                const meshIntersects = raycaster.intersectObject(currentMesh, true);
                
                if (meshIntersects.length > 0) {
                    // We got a direct hit on the mesh - use the closest hit point
                    const closestHit = meshIntersects[0];
                    intersectionPoint = closestHit.point.clone();
                    
                    // Debug log
                    console.log("Direct mesh hit at:", intersectionPoint, "on object:", closestHit.object.name || "unnamed");
                    
                    // Remove the preview marker after placing a point
                    removePathPreviewMarker();
                    
                    // Add the point directly - the point is already in world coordinates
                    addPathMeasurementPoint(intersectionPoint);
                    return;
                }
                
                // If direct intersection failed, we don't want to add a point
                console.log("No valid intersection found with mesh");
                return;
            }
            
            // Existing regular measurement mode logic
            if (isMeasureMode) {
                // In orthographic mode, always place points on the orthographic plane
                if (isOrthographic) {
                    // Get the ray from the raycaster
                    const ray = raycaster.ray;
                    
                    // Find the center point of the scene
                    const sceneCenter = modelCenter ? modelCenter.clone() : new THREE.Vector3(0, 0, 0);
                    
                    // Project ray to the plane defined by sceneCenter and camera direction
                    const planeNormal = new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3()));
                    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, sceneCenter);
                    
                    // Find where the ray intersects this plane
                    intersectionPoint = new THREE.Vector3();
                    ray.intersectPlane(plane, intersectionPoint);
                    
                    // If for some reason we didn't get an intersection, fall back to model or default
                    if (!intersectionPoint) {
                        // Try model intersection
                        if (currentMesh) {
                            const modelIntersects = raycaster.intersectObject(currentMesh, true);
                            if (modelIntersects.length > 0) {
                                intersectionPoint = modelIntersects[0].point.clone();
                            }
                        }
                        
                        // If still no point, create one at a standard distance
                        if (!intersectionPoint) {
                            intersectionPoint = new THREE.Vector3();
                            intersectionPoint.copy(ray.origin);
                            intersectionPoint.addScaledVector(ray.direction, 10);
                        }
                    }
                } 
                // In perspective mode, check for model intersection first, then fall back to ray
                else {
                    // Try to find an intersection with the model first
                    if (currentMesh) {
                        const intersects = raycaster.intersectObject(currentMesh, true);
                        if (intersects.length > 0) {
                            intersectionPoint = intersects[0].point.clone();
                        }
                    }
                    
                    // If no intersection, create a point in 3D space at a reasonable distance
                    if (!intersectionPoint) {
                        const ray = raycaster.ray;
                        intersectionPoint = new THREE.Vector3();
                        intersectionPoint.copy(ray.origin);
                        intersectionPoint.addScaledVector(ray.direction, 10); // Standard distance
                    }
                }
                
                // Add the measurement point
                addMeasurementPoint(intersectionPoint);
            }
        }
        
        function onPointerMove(event) {
            if (!isMeasureMode && !isPathMeasureMode) return;
            
            // Skip preview marker if rotation key is pressed in path measure mode
            if (isPathMeasureMode && isRotationKeyPressed) {
                removePathPreviewMarker();
                return;
            }
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray
            raycaster.setFromCamera(mouse, camera);
            
            // For regular measurement mode - show preview line
            if (isMeasureMode && measurementPoints.length === 1) {
                let intersectionPoint = null;
                
                // Same intersection logic as in onPointerDown
                if (isOrthographic) {
                    const ray = raycaster.ray;
                    const sceneCenter = modelCenter ? modelCenter.clone() : new THREE.Vector3(0, 0, 0);
                    const planeNormal = new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3()));
                    const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(planeNormal, sceneCenter);
                    
                    intersectionPoint = new THREE.Vector3();
                    ray.intersectPlane(plane, intersectionPoint);
                    
                    if (!intersectionPoint) {
                        if (currentMesh) {
                            const modelIntersects = raycaster.intersectObject(currentMesh, true);
                            if (modelIntersects.length > 0) {
                                intersectionPoint = modelIntersects[0].point.clone();
                            }
                        }
                        
                        if (!intersectionPoint) {
                            intersectionPoint = new THREE.Vector3();
                            intersectionPoint.copy(ray.origin);
                            intersectionPoint.addScaledVector(ray.direction, 10);
                        }
                    }
                } else {
                    if (currentMesh) {
                        const intersects = raycaster.intersectObject(currentMesh, true);
                        if (intersects.length > 0) {
                            intersectionPoint = intersects[0].point.clone();
                        }
                    }
                    
                    if (!intersectionPoint) {
                        const ray = raycaster.ray;
                        intersectionPoint = new THREE.Vector3();
                        intersectionPoint.copy(ray.origin);
                        intersectionPoint.addScaledVector(ray.direction, 10);
                    }
                }
                
                // Update preview line
                updatePreviewLine(measurementPoints[0], intersectionPoint);
            }
            
            // For path measurement mode - show preview marker at potential intersection point
            if (isPathMeasureMode && currentMesh) {
                // Ensure the mesh's world matrix is updated for accurate raycasting
                if (currentMesh.matrixAutoUpdate) {
                    currentMesh.updateMatrix();
                }
                currentMesh.updateMatrixWorld(true);
                
                // Set a lower precision threshold for raycasting
                raycaster.params.Line.threshold = 0.05;
                raycaster.params.Points.threshold = 0.05;
                
                // Cast ray against the entire mesh hierarchy
                const meshIntersects = raycaster.intersectObject(currentMesh, true);
                
                if (meshIntersects.length > 0) {
                    // We got a direct hit on the mesh - create/update preview marker
                    const intersectionPoint = meshIntersects[0].point.clone();
                    
                    // Store the exact mouse coordinates for this position
                    const screenX = event.clientX;
                    const screenY = event.clientY;
                    
                    // Debug the intersection
                    // console.log("Preview at:", intersectionPoint, "Mouse:", screenX, screenY);
                    
                    updatePathPreviewMarker(intersectionPoint, screenX, screenY);
                } else {
                    // No valid intersection - remove preview marker
                    removePathPreviewMarker();
                }
            }
        }
        
        // Store both the foreground and background preview lines for proper cleanup
        let previewBackgroundLine = null;
        
        function updatePreviewLine(point1, point2) {
            // Remove existing preview lines if any
            if (previewLine) {
                measurementGroup.remove(previewLine);
                previewLine = null;
            }
            
            if (previewBackgroundLine) {
                measurementGroup.remove(previewBackgroundLine);
                previewBackgroundLine = null;
            }
            
            if (previewLabel) {
                measurementGroup.remove(previewLabel);
                previewLabel = null;
            }
            
            // Create a white dashed preview line
            const material = new THREE.LineDashedMaterial({ 
                color: 0xFFFFFF, // White
                dashSize: 0.2, 
                gapSize: 0.1,
                linewidth: 3,
                transparent: true,
                opacity: 0.9 // Very minimal transparency
            });
            const geometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            previewLine = new THREE.Line(geometry, material);
            previewLine.computeLineDistances(); // Required for dashed lines
            
            // Create a green background line with different dash pattern
            const backgroundMaterial = new THREE.LineDashedMaterial({
                color: 0x00CC00, // Bright green
                linewidth: 4,
                transparent: true,
                opacity: 0.95, // Very minimal transparency
                dashSize: 0.05, // Short dashes
                gapSize: 0.15  // Longer gaps
            });
            const bgGeometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            previewBackgroundLine = new THREE.Line(bgGeometry, backgroundMaterial);
            previewBackgroundLine.computeLineDistances(); // Required for dashed lines
            
            // Add the green background line first
            measurementGroup.add(previewBackgroundLine);
            
            // Add the white dashed line on top
            measurementGroup.add(previewLine);
            
            // Calculate distance for preview
            const distance = point1.distanceTo(point2);
            
            // Calculate midpoint
            const midpoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
            
            // Calculate the direction vector of the line
            const direction = new THREE.Vector3().subVectors(point2, point1).normalize();
            
            // Calculate a perpendicular vector in the up direction to offset the label
            // Use world up vector and cross product to find perpendicular direction
            const worldUp = new THREE.Vector3(0, 1, 0);
            const perpendicular = new THREE.Vector3().crossVectors(direction, worldUp).normalize();
            
            // If perpendicular is too small (line is vertical), use a different axis
            if (perpendicular.length() < 0.1) {
                const worldRight = new THREE.Vector3(1, 0, 0);
                perpendicular.crossVectors(direction, worldRight).normalize();
            }
            
            // Apply a larger offset to position label above the line
            const labelOffset = 0.25; // Distance above the line
            const labelPosition = midpoint.clone().addScaledVector(perpendicular, labelOffset);
            
            // Create enhanced preview label
            const labelDiv = document.createElement('div');
            labelDiv.className = 'annotation-label';
            labelDiv.style.opacity = '0.9';
            labelDiv.style.padding = '3px 6px';
            labelDiv.style.fontSize = '13px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.backgroundColor = 'rgba(52, 152, 219, 0.7)'; // Light blue background
            labelDiv.style.border = '1px dashed rgba(255, 0, 0, 0.7)'; // Dashed red border
            labelDiv.textContent = getMeasurementText(distance);
            previewLabel = new CSS2DObject(labelDiv);
            previewLabel.position.copy(labelPosition);
            measurementGroup.add(previewLabel);
        }
        
        function addMeasurementPoint(point) {
            // Add a more prominent crosshair marker at the point
            const markerGroup = new THREE.Group();
            markerGroup.position.copy(point);
            
            // Create larger crosshair marker (three perpendicular lines)
            const markerSize = 0.08; // Increased size of the crosshair arms
            const primaryColor = 0x4caf50; // Light green (replacing red)
            const secondaryColor = 0x3498db; // Light blue
            
            // Primary color lines (light green)
            const primaryMaterial = new THREE.LineBasicMaterial({ color: primaryColor, linewidth: 3 });
            
            // X axis line (light green)
            const xGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-markerSize, 0, 0),
                new THREE.Vector3(markerSize, 0, 0)
            ]);
            const xLine = new THREE.Line(xGeometry, primaryMaterial);
            markerGroup.add(xLine);
            
            // Y axis line (light green)
            const yGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -markerSize, 0),
                new THREE.Vector3(0, markerSize, 0)
            ]);
            const yLine = new THREE.Line(yGeometry, primaryMaterial);
            markerGroup.add(yLine);
            
            // Z axis line (light green)
            const zGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -markerSize),
                new THREE.Vector3(0, 0, markerSize)
            ]);
            const zLine = new THREE.Line(zGeometry, primaryMaterial);
            markerGroup.add(zLine);
            
            // Secondary color lines (light blue) - slightly offset for visibility
            const secondaryMaterial = new THREE.LineBasicMaterial({ color: secondaryColor, linewidth: 1.5 });
            const offset = 0.01; // Small offset for the second set of lines
            
            // X axis line (light blue)
            const xGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-markerSize, offset, offset),
                new THREE.Vector3(markerSize, offset, offset)
            ]);
            const xLine2 = new THREE.Line(xGeometry2, secondaryMaterial);
            markerGroup.add(xLine2);
            
            // Y axis line (light blue)
            const yGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(offset, -markerSize, offset),
                new THREE.Vector3(offset, markerSize, offset)
            ]);
            const yLine2 = new THREE.Line(yGeometry2, secondaryMaterial);
            markerGroup.add(yLine2);
            
            // Z axis line (light blue)
            const zGeometry2 = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(offset, offset, -markerSize),
                new THREE.Vector3(offset, offset, markerSize)
            ]);
            const zLine2 = new THREE.Line(zGeometry2, secondaryMaterial);
            markerGroup.add(zLine2);
            
            // Sphere at center - make it larger and two-toned
            const sphereGeometry = new THREE.SphereGeometry(0.02);
            const sphereMaterial = new THREE.MeshBasicMaterial({ color: primaryColor });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            markerGroup.add(sphere);
            
            // Outer sphere (light blue halo)
            const outerSphereGeometry = new THREE.SphereGeometry(0.03);
            const outerSphereMaterial = new THREE.MeshBasicMaterial({ 
                color: secondaryColor,
                transparent: true,
                opacity: 0.5
            });
            const outerSphere = new THREE.Mesh(outerSphereGeometry, outerSphereMaterial);
            markerGroup.add(outerSphere);
            
            measurementGroup.add(markerGroup);
            measurementPoints.push(point);
            
            // If we have two points, create a measurement and clean up preview
            if (measurementPoints.length === 2) {
                // Clean up preview
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                
                if (previewBackgroundLine) {
                    measurementGroup.remove(previewBackgroundLine);
                    previewBackgroundLine = null;
                }
                
                if (previewLabel) {
                    measurementGroup.remove(previewLabel);
                    previewLabel = null;
                }
                
                createMeasurement(measurementPoints[0], measurementPoints[1]);
                measurementPoints = []; // Reset for the next measurement
            }
        }
        
        function createMeasurement(point1, point2) {
            // Create a more prominent line between points with white and green
            const primaryColor = 0xFFFFFF; // White
            const secondaryColor = 0x00CC00; // Bright green
            
            // Create primary measurement line (white)
            const primaryMaterial = new THREE.LineBasicMaterial({ 
                color: primaryColor, 
                linewidth: 4,
                transparent: false // No transparency
            });
            const geometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
            const line = new THREE.Line(geometry, primaryMaterial);
            measurementGroup.add(line);
            
            // Create secondary line (green) with slight offset and dashed pattern
            const offset = new THREE.Vector3(0.01, 0.01, 0.01);
            const secondaryMaterial = new THREE.LineDashedMaterial({ 
                color: secondaryColor, 
                linewidth: 3,
                transparent: true,
                opacity: 0.95, // Very little transparency
                dashSize: 0.15,
                gapSize: 0.05
            });
            
            // Create slightly offset points for the secondary line
            const offsetPoint1 = point1.clone().add(offset);
            const offsetPoint2 = point2.clone().add(offset);
            
            const secondaryGeometry = new THREE.BufferGeometry().setFromPoints([offsetPoint1, offsetPoint2]);
            const secondaryLine = new THREE.Line(secondaryGeometry, secondaryMaterial);
            secondaryLine.computeLineDistances(); // Required for dashed lines
            measurementGroup.add(secondaryLine);
            
            // Calculate distance (model units)
            const distance = point1.distanceTo(point2);
            
            // Calculate midpoint
            const midpoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
            
            // Calculate the direction vector of the line
            const direction = new THREE.Vector3().subVectors(point2, point1).normalize();
            
            // Calculate a perpendicular vector in the up direction to offset the label
            // Use world up vector and cross product to find perpendicular direction
            const worldUp = new THREE.Vector3(0, 1, 0);
            const perpendicular = new THREE.Vector3().crossVectors(direction, worldUp).normalize();
            
            // If perpendicular is too small (line is vertical), use a different axis
            if (perpendicular.length() < 0.1) {
                const worldRight = new THREE.Vector3(1, 0, 0);
                perpendicular.crossVectors(direction, worldRight).normalize();
            }
            
            // Apply a larger offset to position label well above the line
            const labelOffset = 0.25; // Distance above the line
            const labelPosition = midpoint.clone().addScaledVector(perpendicular, labelOffset);
            
            // Create enhanced label at offset position
            const labelDiv = document.createElement('div');
            labelDiv.className = 'annotation-label';
            labelDiv.style.padding = '5px 8px';
            labelDiv.style.fontSize = '14px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.color = 'white';
            labelDiv.style.textShadow = '1px 1px 1px rgba(0,0,0,0.5)';
            labelDiv.style.backgroundColor = 'rgba(52, 152, 219, 0.8)'; // Light blue with transparency
            labelDiv.style.border = '2px solid rgba(76, 175, 80, 0.7)'; // Light green border (replacing red)
            labelDiv.textContent = getMeasurementText(distance);
            const label = new CSS2DObject(labelDiv);
            label.position.copy(labelPosition);
            measurementGroup.add(label);
            measurementLabels.push(label);
            
            // Store the measurement with all components
            const measurementData = {
                point1: point1.clone(),
                point2: point2.clone(),
                distance: distance,
                line: line,
                secondaryLine: secondaryLine,
                label: label
            };
            measurements.push(measurementData);
            
            // Update the measurements list
            updateMeasurementsList();
        }
        
        // Function to update the measurements list
        function updateMeasurementsList() {
            const list = document.getElementById('measurementsList');
            const mobilelist = document.getElementById('mobileMeasurementsList');
            let measurementsCount = 0;
            
            // Clear existing lists
            if (list) list.innerHTML = '';
            if (mobilelist) mobilelist.innerHTML = '';
            
            // Add regular measurements
            measurements.forEach((measurement, index) => {
                measurementsCount++;
                // For regular list
                if (list) {
                const listItem = document.createElement('li');
                listItem.textContent = `Measurement ${index + 1}: ${getMeasurementText(measurement.distance)}`;
                list.appendChild(listItem);
                }
                
                // For mobile list
                if (mobilelist) {
                    const listItem = document.createElement('div');
                    listItem.style.margin = '8px 0';
                    listItem.style.padding = '8px 10px'; 
                    listItem.style.borderLeft = '3px solid #4CAF50';
                    listItem.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    listItem.style.borderRadius = '4px';
                    listItem.textContent = `Point ${index + 1}: ${getMeasurementText(measurement.distance)}`;
                    mobilelist.appendChild(listItem);
                }
            });
            
            // Add completed path measurements
            completedPaths.forEach((path, pathIndex) => {
                measurementsCount++;
                // For regular list
                if (list) {
                const listItem = document.createElement('li');
                listItem.className = 'path-measurement';
                listItem.textContent = `Path ${pathIndex + 1}: ${getMeasurementText(path.totalDistance)}`;
                list.appendChild(listItem);
                
                // Add segment measurements for completed paths if needed
                if (path.showSegments) {
                    for (let i = 1; i < path.points.length; i++) {
                        const segmentDistance = path.points[i-1].distanceTo(path.points[i]);
                        const segmentItem = document.createElement('li');
                        segmentItem.className = 'path-segment';
                        segmentItem.textContent = `Segment ${i}: ${getMeasurementText(segmentDistance)}`;
                        list.appendChild(segmentItem);
                        }
                    }
                }
                
                // For mobile list
                if (mobilelist) {
                    const listItem = document.createElement('div');
                    listItem.style.margin = '10px 0';
                    listItem.style.padding = '8px 10px';
                    listItem.style.borderLeft = '3px solid #FF6600';
                    listItem.style.backgroundColor = 'rgba(255, 102, 0, 0.1)';
                    listItem.style.borderRadius = '4px';
                    listItem.style.fontWeight = 'bold';
                    listItem.textContent = `Path ${pathIndex + 1}: ${getMeasurementText(path.totalDistance)}`;
                    mobilelist.appendChild(listItem);
                    
                    // Add segment measurements for completed paths if needed
                    if (path.showSegments) {
                        for (let i = 1; i < path.points.length; i++) {
                            const segmentDistance = path.points[i-1].distanceTo(path.points[i]);
                            const segmentItem = document.createElement('div');
                            segmentItem.style.margin = '3px 0 3px 15px';
                            segmentItem.style.padding = '4px 8px';
                            segmentItem.style.borderLeft = '2px solid #FFA500';
                            segmentItem.style.fontSize = '0.9em';
                            segmentItem.style.backgroundColor = 'rgba(255, 165, 0, 0.05)';
                            segmentItem.style.borderRadius = '3px';
                            segmentItem.textContent = `Segment ${i}: ${getMeasurementText(segmentDistance)}`;
                            mobilelist.appendChild(segmentItem);
                        }
                    }
                }
            });
            
            // Add current active path measurement
            if (pathMeasurementPoints.length > 1) {
                measurementsCount++;
                // For regular list
                if (list) {
                const listItem = document.createElement('li');
                listItem.className = 'path-measurement';
                listItem.textContent = `Current Path: ${getMeasurementText(pathTotalDistance)}`;
                list.appendChild(listItem);
                
                // Add segment measurements
                for (let i = 1; i < pathMeasurementPoints.length; i++) {
                    const segmentDistance = pathMeasurementPoints[i-1].distanceTo(pathMeasurementPoints[i]);
                    const segmentItem = document.createElement('li');
                    segmentItem.className = 'path-segment';
                    segmentItem.textContent = `Segment ${i}: ${getMeasurementText(segmentDistance)}`;
                    list.appendChild(segmentItem);
                    }
                }
                
                // For mobile list
                if (mobilelist) {
                    const listItem = document.createElement('div');
                    listItem.style.margin = '10px 0';
                    listItem.style.padding = '8px 10px';
                    listItem.style.borderLeft = '3px solid #FF6600';
                    listItem.style.backgroundColor = 'rgba(255, 102, 0, 0.1)';
                    listItem.style.borderRadius = '4px';
                    listItem.style.fontWeight = 'bold';
                    listItem.textContent = `Current Path: ${getMeasurementText(pathTotalDistance)}`;
                    mobilelist.appendChild(listItem);
                    
                    // Add segment measurements
                    for (let i = 1; i < pathMeasurementPoints.length; i++) {
                        const segmentDistance = pathMeasurementPoints[i-1].distanceTo(pathMeasurementPoints[i]);
                        const segmentItem = document.createElement('div');
                        segmentItem.style.margin = '3px 0 3px 15px';
                        segmentItem.style.padding = '4px 8px';
                        segmentItem.style.borderLeft = '2px solid #FFA500';
                        segmentItem.style.fontSize = '0.9em';
                        segmentItem.style.backgroundColor = 'rgba(255, 165, 0, 0.05)';
                        segmentItem.style.borderRadius = '3px';
                        segmentItem.textContent = `Segment ${i}: ${getMeasurementText(segmentDistance)}`;
                        mobilelist.appendChild(segmentItem);
                    }
                }
            }
            
            // Update the mobile measurement badge
            if (isMobile) {
                const badge = document.getElementById('mobileMeasureBadge');
                
                if (badge) {
                    badge.textContent = measurementsCount;
                    badge.classList.toggle('active', measurementsCount > 0);
                }
                
                // Update mobile model info in case it's changed
                updateMobileModelInfo();
                
                // Show measurements briefly if a new one was added
                if (measurementsCount > 0) {
                    showMobileMeasurements(true, true);
                }
            }
        }
        
        function clearMeasurements() {
            // Remove all measurement objects
            while (measurementGroup.children.length > 0) {
                const object = measurementGroup.children[0];
                measurementGroup.remove(object);
            }
            
            // Clear arrays
            measurements = [];
            measurementPoints = [];
            measurementLabels = [];
            
            // Clear path measurement arrays
            pathMeasurementPoints = [];
            pathMeasurementLines = [];
            pathMeasurementLabels = [];
            pathTotalDistance = 0;
            pathTotalLabel = null;
            
            // Clear completed paths
            completedPaths = [];
            currentPathId = 0;
            
            // Clear preview variables
            previewLine = null;
            previewBackgroundLine = null;
            previewLabel = null;
            
            // Reset path measurement mode if active
            if (isPathMeasureMode) {
                // Start fresh path measurements
                console.log("Cleared existing path measurements, ready for new path");
            }
            
            // Update UI
            updateMeasurementsList();
        }
        
        function cancelCurrentMeasurement() {
            // Only operate if in measure mode and there's an unfinished measurement
            // (i.e., exactly one point placed waiting for the second point)
            if (isMeasureMode && measurementPoints.length === 1) {
                // Remove just the first placed point (the unfinished endpoint)
                // Find the most recently added marker in the measurementGroup
                let markerIndex = -1;
                
                // Find the marker object - it should be the most recently added non-preview object
                for (let i = measurementGroup.children.length - 1; i >= 0; i--) {
                    const obj = measurementGroup.children[i];
                    if (obj !== previewLine && obj !== previewLabel) {
                        markerIndex = i;
                        break;
                    }
                }
                
                // If we found the marker, remove it
                if (markerIndex >= 0) {
                    measurementGroup.remove(measurementGroup.children[markerIndex]);
                }
                
                // Clear any preview elements
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                
                if (previewBackgroundLine) {
                    measurementGroup.remove(previewBackgroundLine);
                    previewBackgroundLine = null;
                }
                
                if (previewLabel) {
                    measurementGroup.remove(previewLabel);
                    previewLabel = null;
                }
                
                // Reset measurement points
                measurementPoints = [];
                
                console.log("Unfinished measurement cancelled");
            }
        }
        
        function toggleMeasureMode() {
            // If path measure mode is active, turn it off
            if (isPathMeasureMode) {
                togglePathMeasureMode();
            }

            isMeasureMode = !isMeasureMode;
            const measureButton = document.getElementById('measureMode');
            measureButton.classList.toggle('active', isMeasureMode);
            
            // Update mobile floating action button if on mobile
            if (isMobile) {
                document.getElementById('mobileMeasure').classList.toggle('measure-mobile-active', isMeasureMode);
                document.body.classList.toggle('measure-mobile-active', isMeasureMode);
                // Always show annotations in measure mode on mobile
                document.getElementById('annotations').style.display = isMeasureMode ? 'block' : 'none';
                
                // Show tooltip with instructions when entering measure mode
                if (isMeasureMode) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'mobile-tooltip';
                    tooltip.textContent = 'Double-tap to clear measurements';
                    tooltip.style.position = 'fixed';
                    tooltip.style.bottom = '85px';
                    tooltip.style.right = '20px';
                    tooltip.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    tooltip.style.color = 'white';
                    tooltip.style.padding = '8px 12px';
                    tooltip.style.borderRadius = '4px';
                    tooltip.style.fontSize = '14px';
                    tooltip.style.zIndex = '1000';
                    document.body.appendChild(tooltip);
                    
                    // Remove after 3 seconds
                    setTimeout(() => {
                        if (tooltip.parentNode) {
                            document.body.removeChild(tooltip);
                        }
                    }, 3000);
                }
            }
            
            if (isMeasureMode) {
                controls.enableRotate = false;
                measureButton.textContent = `Exit`;
            } else {
                controls.enableRotate = true;
                // Fix: Set proper text instead of empty string
                measureButton.textContent = `Measure`;
                
                // Clean up any in-progress measurements
                measurementPoints = [];
                
                // Clean up preview line if it exists
                if (previewLine) {
                    measurementGroup.remove(previewLine);
                    previewLine = null;
                }
                
                if (previewLabel) {
                    measurementGroup.remove(previewLabel);
                    previewLabel = null;
                }
            }
        }
        
        function getMeasurementText(distance) {
            // Convert to both inches and centimeters
            const inches = (distance / 0.0254).toFixed(2);
            const cm = (distance / 0.01).toFixed(2);
            
            // On mobile, make the text more concise
            if (isMobile) {
                return `${inches}"/${cm}cm`;
            }
            
            return `${inches} in / ${cm} cm`;
        }
        
        function resetCamera() {
            if (currentMesh) {
                const boundingBox = currentMesh.geometry.boundingBox;
                const maxDim = Math.max(
                    boundingBox.max.x - boundingBox.min.x,
                    boundingBox.max.y - boundingBox.min.y,
                    boundingBox.max.z - boundingBox.min.z
                );
                const distance = maxDim * 0.8;
                
                // Reset camera position with smooth transition
                const targetPosition = new THREE.Vector3(distance, -distance * 0.7, distance * 0.5);
                const targetLookAt = new THREE.Vector3(0, 0, 0);
                
                // Animate camera movement
                const duration = 1000; // 1 second
                const startTime = Date.now();
                const startPosition = camera.position.clone();
                const startLookAt = controls.target.clone();
                
                function animateCamera() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease in-out function
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                    
                    camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    controls.target.lerpVectors(startLookAt, targetLookAt, easeProgress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    }
                    
                    camera.up.set(0, 0, 1);
                    controls.update();
                }
                
                animateCamera();
            }
        }

        function toggleViewMode() {
            if (!currentMesh) return;
            
            // Cycle through view modes: 0: solid, 1: transparent, 2: wireframe
            viewMode = (viewMode + 1) % 3;
            
            const modeButton = document.getElementById('toggleViewMode');
            
            switch(viewMode) {
                case 0: // Solid
                    currentMesh.material.wireframe = false;
                    currentMesh.material.transparent = true;
                    currentMesh.material.opacity = 0.95;
                    modeButton.textContent = "Solid";
                    break;
                    
                case 1: // Transparent
                    currentMesh.material.wireframe = false;
                    currentMesh.material.transparent = true;
                    currentMesh.material.opacity = 0.5;
                    modeButton.textContent = "Transparent";
                    break;
                    
                case 2: // Wireframe
                    currentMesh.material.wireframe = true;
                    currentMesh.material.transparent = true;
                    currentMesh.material.opacity = 0.7;
                    modeButton.textContent = "Wireframe";
                    break;
            }
        }

        function toggleAxes() {
            isAxesVisible = !isAxesVisible;
            axesHelper.visible = isAxesVisible;
        }

        // Loading timeout
        const loadingTimeout = setTimeout(() => {
            if (document.getElementById('loading').style.display !== 'none') {
                document.getElementById('loading').textContent = 'Loading is taking longer than expected. Please try refreshing the page.';
            }
        }, 30000);

        // STL model caching using IndexedDB
        const DB_NAME = 'stl_model_cache';
        const STORE_NAME = 'models';
        const MODEL_KEY = 'navagunjara-reborn-gometric-analysis';
        const MODEL_URL = "{% static 'models/stl/navagunjara-reborn-gometric-analysis.stl' %}";
        
        // Function to load model from IndexedDB or network
        async function loadModelWithCache() {
            document.getElementById('loading').textContent = 'Checking cache...';
            
            try {
                // Try to load from cache first
                const cachedModel = await getModelFromCache();
                
                if (cachedModel) {
                    document.getElementById('loading').textContent = 'Loading from cache...';
                    console.log('Loading model from cache');
                    processSTLData(cachedModel);
                    return;
                }
                
                // If not in cache, load from network
                document.getElementById('loading').textContent = 'Downloading model...';
                console.log('Model not in cache, downloading...');
                
                const response = await fetch(MODEL_URL);
                if (!response.ok) {
                    throw new Error(`Failed to fetch model: ${response.status} ${response.statusText}`);
                }
                
                const modelData = await response.arrayBuffer();
                
                // Store in cache for future use
                await storeModelInCache(modelData);
                
                // Process the downloaded model
                processSTLData(modelData);
                
            } catch (error) {
                console.error('Error loading model:', error);
                clearTimeout(loadingTimeout);
                document.getElementById('loading').textContent = 'Error loading model. Please try refreshing the page.';
            }
        }
        
        // Open/initialize the IndexedDB database
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                
                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.error);
                    reject(event.target.error);
                };
                
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }
        
        // Get model from cache
        async function getModelFromCache() {
            try {
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(STORE_NAME, 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(MODEL_KEY);
                    
                    request.onerror = (event) => {
                        console.error('Error reading from cache:', event.target.error);
                        resolve(null); // Resolve with null to try network fetch
                    };
                    
                    request.onsuccess = (event) => {
                        resolve(request.result);
                    };
                });
            } catch (error) {
                console.error('Error accessing cache:', error);
                return null;
            }
        }
        
        // Store model in cache
        async function storeModelInCache(modelData) {
            try {
                const db = await openDatabase();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction(STORE_NAME, 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put(modelData, MODEL_KEY);
                    
                    request.onerror = (event) => {
                        console.error('Error writing to cache:', event.target.error);
                        resolve(false);
                    };
                    
                    request.onsuccess = () => {
                        console.log('Model cached successfully');
                        resolve(true);
                    };
                });
            } catch (error) {
                console.error('Error storing in cache:', error);
                return false;
            }
        }
        
        // Process STL data with the STLLoader
        function processSTLData(buffer) {
            const loader = new STLLoader();
            try {
                const geometry = loader.parse(buffer);
                onModelLoaded(geometry);
            } catch (error) {
                console.error('Error parsing STL:', error);
                clearTimeout(loadingTimeout);
                document.getElementById('loading').textContent = 'Error parsing 3D model. Please try refreshing the page.';
            }
        }
        
        // Handler for when model is loaded - contains the same logic as the original loader callback
        function onModelLoaded(geometry) {
            clearTimeout(loadingTimeout);
            document.getElementById('loading').style.display = 'none';
            
            // Compute vertex normals if they don't exist
            if (!geometry.hasAttribute('normal')) {
                geometry.computeVertexNormals();
            }
            
            // Ensure we have a bounding box
            geometry.computeBoundingBox();
            
            const material = new THREE.MeshPhongMaterial({ 
                color: 0xdddddd, // Lighter color for the model
                specular: 0x444444, // More moderate specular highlights
                shininess: 40, // Less shiny for more diffuse appearance
                wireframe: false, // Default to solid mode instead of wireframe
                flatShading: false, // Enable smooth shading
                transparent: true, // Keep transparency
                opacity: 0.5, // Set to 50% transparent by default
                side: THREE.DoubleSide // Render both sides of faces
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = "MainModel"; // Name the mesh for debugging
            currentMesh = mesh;
            
            // Add edge highlighting for better visibility
            const edges = new THREE.EdgesGeometry(geometry, 30); // 30-degree threshold
            const edgeMaterial = new THREE.LineBasicMaterial({ 
                color: 0x222222, 
                linewidth: 1 
            });
            const wireframe = new THREE.LineSegments(edges, edgeMaterial);
            wireframe.name = "ModelEdges"; // Name for debugging
            mesh.add(wireframe);
            
            // Make sure the mesh is set up for raycasting
            mesh.geometry.computeBoundingSphere();
            mesh.geometry.computeVertexNormals();
            
            // Only compute tangents if we have all required attributes
            if (geometry.hasAttribute('position') && 
                geometry.hasAttribute('normal') && 
                geometry.hasAttribute('uv') && 
                geometry.index !== null) {
                mesh.geometry.computeTangents();
            }
            
            // Ensure matrix updates are always performed
            mesh.matrixAutoUpdate = true;
            mesh.updateMatrix();
            mesh.updateMatrixWorld(true);
            
            // Center the model
            geometry.computeBoundingBox();
            const boundingBox = geometry.boundingBox;
            
            // In Y-up world, we need to transform the model
            // Rotate the model 90 degrees around X-axis to convert from Z-up to Y-up
            mesh.rotation.x = -Math.PI / 2;
            
            // Apply rotation to bounding box to get correct extents
            const rotatedHeight = boundingBox.max.y - boundingBox.min.y;
            const rotatedWidth = boundingBox.max.x - boundingBox.min.x;
            const rotatedDepth = boundingBox.max.z - boundingBox.min.z;
            
            // Force the mesh to update its world matrix to apply the rotation
            mesh.updateMatrixWorld(true);
            
            // Calculate the bounding box of the rotated model
            const rotatedBox = new THREE.Box3().setFromObject(mesh);
            
            // Get the center of the rotated bounding box
            const rotatedCenter = new THREE.Vector3();
            rotatedBox.getCenter(rotatedCenter);
            
            // Calculate the size of the rotated bounding box
            const rotatedSize = new THREE.Vector3();
            rotatedBox.getSize(rotatedSize);
            
            // Position the model so that:
            // 1. Its bottom is at y=0 (on the XZ plane)
            // 2. It's centered on the X and Z axes
            mesh.position.set(
                -rotatedCenter.x, 
                -rotatedBox.min.y,  // This places the bottom at y=0
                -rotatedCenter.z
            );
            
            // Force another update after repositioning
            mesh.updateMatrixWorld(true);
            
            // Calculate the final bounding box for verification
            const finalBox = new THREE.Box3().setFromObject(mesh);
            const finalCenter = new THREE.Vector3();
            finalBox.getCenter(finalCenter);
            
            // Store the model center for orbit controls
            modelCenter = new THREE.Vector3(0, finalBox.getSize(new THREE.Vector3()).y/2, 0);
            
            console.log("Initial bounding box:", boundingBox);
            console.log("Rotated bounding box:", rotatedBox);
            console.log("Final bounding box:", finalBox);
            console.log("Model centered at:", modelCenter);
            
            // Get the actual height of the model for scaling
            const modelHeight = rotatedSize.y;
            const targetHeight = 4.28; // Target height in meters
            const scaleFactor = targetHeight / modelHeight;
            
            // Apply scaling to the model to make it the correct height
            mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            
            // Store model size for orthographic camera (Y-up world, so Y is height)
            modelSize = new THREE.Vector3(
                (boundingBox.max.x - boundingBox.min.x) * scaleFactor,
                (boundingBox.max.y - boundingBox.min.y) * scaleFactor,
                (boundingBox.max.z - boundingBox.min.z) * scaleFactor
            );
            
            // Set unit to inches by default (we're calibrated to real-world meters)
            currentUnit = 0.0254; // Default to inches
            
            scene.add(mesh);
            
            // Update model information with scaled dimensions
            const dimensions = {
                x: ((boundingBox.max.x - boundingBox.min.x) * scaleFactor).toFixed(2),
                y: ((boundingBox.max.y - boundingBox.min.y) * scaleFactor).toFixed(2),
                z: ((boundingBox.max.z - boundingBox.min.z) * scaleFactor).toFixed(2)
            };
            
            document.getElementById('modelName').textContent = 'Navagunjara Reborn';
            
            // More concise text for mobile
            if (isMobile) {
                document.getElementById('modelDimensions').textContent = 
                    `Size: ${dimensions.x}√ó${dimensions.y}√ó${dimensions.z}m`;
                document.getElementById('modelCalibration').textContent = 
                    `Height: 4.28m (√ó${scaleFactor.toFixed(2)})`;
            } else {
                document.getElementById('modelDimensions').textContent = 
                    `Dimensions: ${dimensions.x} √ó ${dimensions.y} √ó ${dimensions.z} meters`;
                document.getElementById('modelCalibration').textContent = 
                    `Calibrated height: 4.28 meters (scale factor: ${scaleFactor.toFixed(4)})`;
            }
            
            // Adjust camera to fit the model (centered and fully visible)
            const size = new THREE.Vector3(
                (boundingBox.max.x - boundingBox.min.x) * scaleFactor,
                (boundingBox.max.y - boundingBox.min.y) * scaleFactor,
                (boundingBox.max.z - boundingBox.min.z) * scaleFactor
            );
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 0.5; // Reduced from 0.7 to 0.5 for extreme close-up
            
            // Camera position: standard position for Y-up world
            perspectiveCamera.position.set(distance, distance, distance);
            perspectiveCamera.up.set(0, 1, 0); // Standard Y-up
            perspectiveCamera.lookAt(modelCenter);
            
            updateOrthographicCamera();
            
            controls.target.copy(modelCenter);
            controls.update();
            
            // Initialize to left view (showing front of the object)
            setTimeout(() => {
                setViewLeft();
            }, 100); // Small delay to ensure everything is initialized
        }

        // Initialize model loading with caching
        loadModelWithCache();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Ensure label renderer stays in sync with objects
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();

        // Handle window resize with better support for mobile devices
        window.addEventListener('resize', function() {
            const aspect = window.innerWidth / window.innerHeight;
            
            // Check if the device has switched between mobile and desktop view
            const nowMobile = window.innerWidth < 768;
            if (nowMobile !== isMobile) {
                location.reload(); // Reload the page to apply all mobile optimizations
                return;
            }
            
            // Update perspective camera
            perspectiveCamera.aspect = aspect;
            perspectiveCamera.updateProjectionMatrix();
            
            // Update orthographic camera
            updateOrthographicCamera();
            
            // Update renderers
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // View control functions
        function toggleCameraMode() {
            isOrthographic = !isOrthographic;
            
            if (isOrthographic) {
                // Switch to orthographic
                updateOrthographicCamera();
                camera = orthographicCamera;
                document.getElementById('toggleCameraMode').textContent = 'Orthographic';
            } else {
                // Switch to perspective
                camera = perspectiveCamera;
                document.getElementById('toggleCameraMode').textContent = 'Perspective';
            }
            
            // Update orbit controls
            controls.object = camera;
            controls.update();
        }
        
        function updateOrthographicCamera() {
            // Adjust orthographic camera based on model size and current view
            const aspect = window.innerWidth / window.innerHeight;
            const zoom = 0.5; // Reduced zoom from 0.7 to 0.5 for extreme close-up
            const largestDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
            
            orthographicCamera.left = -largestDim * zoom * aspect;
            orthographicCamera.right = largestDim * zoom * aspect;
            orthographicCamera.top = largestDim * zoom;
            orthographicCamera.bottom = -largestDim * zoom;
            orthographicCamera.near = -1000;
            orthographicCamera.far = 1000;
            orthographicCamera.position.copy(perspectiveCamera.position);
            orthographicCamera.quaternion.copy(perspectiveCamera.quaternion);
            orthographicCamera.updateProjectionMatrix();
        }
        
        // Orthographic view functions - updated for object's actual orientation
        function setViewFront() {
            // Front view shows object's left side (from -X)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.z, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(-distance, modelCenter.y, 0);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewBack() {
            // Back view shows object's right side (from +X)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.z, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(distance, modelCenter.y, 0);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewLeft() {
            // Left view shows object's front (from +Z)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, modelCenter.y, distance);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewRight() {
            // Right view shows object's back (from -Z)
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.y);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, modelCenter.y, -distance);
            const targetUp = new THREE.Vector3(0, 1, 0);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewTop() {
            // Top view looks at the model from +Y
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.z);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, distance, 0);
            const targetUp = new THREE.Vector3(0, 0, -1);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        function setViewBottom() {
            // Bottom view looks at the model from -Y
            const extents = getModelExtents();
            const maxDim = Math.max(extents.x, extents.z);
            const distance = maxDim * 0.6; // Reduced from 0.8 to 0.6 for extreme close-up
            
            const targetPosition = new THREE.Vector3(0, -distance, 0);
            const targetUp = new THREE.Vector3(0, 0, 1);
            
            setCameraView(targetPosition, modelCenter, targetUp);
        }
        
        // Helper function to get consistent model extents
        function getModelExtents() {
            if (!currentMesh) {
                return { x: 10, y: 10, z: 10 };
            }
            
            // Get the bounding box of the model
            currentMesh.geometry.computeBoundingBox();
            const boundingBox = currentMesh.geometry.boundingBox;
            
            // Account for the scaling and rotation
            const sx = currentMesh.scale.x;
            const sy = currentMesh.scale.y;
            const sz = currentMesh.scale.z;
            
            // Since we rotated 90 degrees around X-axis, the dimensions are transformed
            return {
                x: (boundingBox.max.x - boundingBox.min.x) * sx,
                y: (boundingBox.max.y - boundingBox.min.y) * sy,
                z: (boundingBox.max.z - boundingBox.min.z) * sz
            };
        }
        
        // Shared camera view setting function
        function setCameraView(position, target, up) {
            // Apply to both cameras
            perspectiveCamera.position.copy(position);
            perspectiveCamera.up.copy(up);
            perspectiveCamera.lookAt(target);
            
            orthographicCamera.position.copy(position);
            orthographicCamera.up.copy(up);
            orthographicCamera.lookAt(target);
            updateOrthographicCamera();
            
            // Update controls
            controls.target.copy(target);
            
            // Switch to orthographic mode for predefined views
            if (!isOrthographic) {
                toggleCameraMode(); // This will switch to orthographic
            }
            
            // Mark that we're in a predefined view
            inPredefinedView = true;
            
            controls.update();
        }

        // Add view button event listeners
        document.getElementById('viewFront').addEventListener('click', setViewFront);
        document.getElementById('viewBack').addEventListener('click', setViewBack);
        document.getElementById('viewLeft').addEventListener('click', setViewLeft);
        document.getElementById('viewRight').addEventListener('click', setViewRight);
        document.getElementById('viewTop').addEventListener('click', setViewTop);
        document.getElementById('viewBottom').addEventListener('click', setViewBottom);
        document.getElementById('toggleCameraMode').addEventListener('click', toggleCameraMode);

        // Mobile-specific event handlers
        if (isMobile) {
            // Show the mobile controls
            const mobileControls = document.getElementById('mobileControls');
            if (mobileControls) {
                mobileControls.style.display = 'block';
            }
            
            // Create a debug log function for mobile testing
            function mobileDebug(msg) {
                console.log('[Mobile] ' + msg);
            }
            
            // Store original functions before extending them
            const originalFunctions = {
                toggleMeasureMode: toggleMeasureMode,
                togglePathMeasureMode: togglePathMeasureMode,
                toggleViewMode: toggleViewMode,
                toggleCameraMode: toggleCameraMode,
                completeCurrentPath: completeCurrentPath,
                clearMeasurements: clearMeasurements
            };
            
            // Set up mobile model info
            const mobileModelName = document.getElementById('mobileModelName');
            const mobileModelDimensions = document.getElementById('mobileModelDimensions');
            
            // Update mobile model info from desktop display
            function updateMobileModelInfo() {
                const desktopModelName = document.getElementById('modelName');
                const desktopModelDimensions = document.getElementById('modelDimensions');
                
                if (desktopModelName && mobileModelName) {
                    mobileModelName.textContent = desktopModelName.textContent;
                }
                
                if (desktopModelDimensions && mobileModelDimensions) {
                    mobileModelDimensions.textContent = desktopModelDimensions.textContent;
            }
            }
        
            // Update initial model info
            updateMobileModelInfo();
            
            // Create safe wrappers for button event handlers
            function safeAddEventListener(id, event, handler) {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener(event, handler);
                    return true;
                }
                return false;
            }
            
            // Override measurement functions with extended versions
            toggleMeasureMode = function() {
                // Call original function
                originalFunctions.toggleMeasureMode();
                // Update mobile UI
                updateMobileMeasureUI();
                // Show measurements if in measure mode
                if (isMeasureMode) {
                    showMobileMeasurements(true);
                }
                mobileDebug('Measure mode toggled: ' + isMeasureMode);
            };
            
            togglePathMeasureMode = function() {
                // Call original function
                originalFunctions.togglePathMeasureMode();
                // Update mobile UI
                updateMobileMeasureUI();
                // Show measurements if in path measure mode
                if (isPathMeasureMode) {
                    showMobileMeasurements(true);
                }
                mobileDebug('Path measure mode toggled: ' + isPathMeasureMode);
            };
            
            clearMeasurements = function() {
                // Call original function
                originalFunctions.clearMeasurements();
                // Update mobile UI
                updateMobileMeasureUI();
                // Update the badge and hide measurements display
                const badge = document.getElementById('mobileMeasureBadge');
                const panel = document.getElementById('mobileMeasurementsDisplay');
                if (badge) badge.classList.remove('active');
                if (panel) panel.classList.remove('active');
                mobileDebug('Measurements cleared');
            };
            
            // Hook up mobile controls to their functions with error handling
            safeAddEventListener('mobileMeasureMode', 'click', function(e) {
                // Prevent handling badge clicks as button clicks
                if (e.target.id === 'mobileMeasureBadge') return;
                toggleMeasureMode();
            });
            
            safeAddEventListener('mobilePathMeasureMode', 'click', togglePathMeasureMode);
            safeAddEventListener('mobileCompletePath', 'click', completeCurrentPath);
            safeAddEventListener('mobileClearMeasurements', 'click', clearMeasurements);
            
            // View mode toggle with visual feedback
            safeAddEventListener('mobileToggleViewMode', 'click', function() {
                originalFunctions.toggleViewMode();
                // Update button appearance based on view mode
                const viewModeBtn = document.getElementById('mobileToggleViewMode');
                if (viewModeBtn) {
                    // viewMode is 0: solid, 1: transparent, 2: wireframe
                    viewModeBtn.innerHTML = [
                        'üëÅÔ∏è', // Solid
                        'üëì', // Transparent
                        'üîç'  // Wireframe
                    ][viewMode];
                }
            });
            
            // Camera mode toggle with visual feedback
            safeAddEventListener('mobileToggleCameraMode', 'click', function() {
                originalFunctions.toggleCameraMode();
                // Update button appearance based on camera mode
                const cameraModeBtn = document.getElementById('mobileToggleCameraMode');
                if (cameraModeBtn) {
                    cameraModeBtn.innerHTML = isOrthographic ? 'üìè' : 'üîç';
                    cameraModeBtn.classList.toggle('active', isOrthographic);
                }
            });
                
            // Set up the mobile view cube
            safeAddEventListener('mobileFront', 'click', setViewFront);
            safeAddEventListener('mobileBack', 'click', setViewBack);
            safeAddEventListener('mobileLeft', 'click', setViewLeft);
            safeAddEventListener('mobileRight', 'click', setViewRight);
            safeAddEventListener('mobileTop', 'click', setViewTop);
            safeAddEventListener('mobileBottom', 'click', setViewBottom);
            
            // Function to show/hide mobile measurements panel
            function showMobileMeasurements(show, autoHide = false) {
                const panel = document.getElementById('mobileMeasurementsDisplay');
                if (panel) {
                    if (show) {
                        panel.classList.add('active');
                        if (autoHide) {
                            setTimeout(() => {
                                panel.classList.remove('active');
                            }, 3000);
                        }
                    } else {
                        panel.classList.remove('active');
                    }
                }
            }
            
            // Update mobile UI when measurement modes change
            function updateMobileMeasureUI() {
                const measureBtn = document.getElementById('mobileMeasureMode');
                const pathBtn = document.getElementById('mobilePathMeasureMode');
                const completeBtn = document.getElementById('mobileCompletePath');
                
                // Update active states
                if (measureBtn) measureBtn.classList.toggle('active', isMeasureMode);
                if (pathBtn) pathBtn.classList.toggle('active', isPathMeasureMode);
                
                // Show/hide complete path button based on path mode
                if (completeBtn) {
                    completeBtn.style.display = isPathMeasureMode ? 'flex' : 'none';
                }
            }
            
            // Set initial display states
            updateMobileMeasureUI();
            
            // Set up measurement badge clicks
            const badge = document.getElementById('mobileMeasureBadge');
            const panel = document.getElementById('mobileMeasurementsDisplay');
            
            if (badge && panel) {
                badge.addEventListener('click', function(e) {
                    e.stopPropagation(); // Stop event from reaching the parent button
                    e.preventDefault();  // Prevent default action
                    showMobileMeasurements(true, false);
                    mobileDebug('Badge clicked - showing measurements');
                });
                
                // Add a close behavior to the measurements panel
                panel.addEventListener('click', function(e) {
                    // Check if they clicked the close button (::before pseudo-element)
                    const rect = panel.getBoundingClientRect();
                    const isCloseButton = (
                        e.clientX > rect.right - 40 && 
                        e.clientX < rect.right - 10 && 
                        e.clientY > rect.top + 10 && 
                        e.clientY < rect.top + 40
                    );
                    
                    if (isCloseButton) {
                        showMobileMeasurements(false);
                        e.stopPropagation();
                        mobileDebug('Close button clicked - hiding measurements');
            }
                });
            
                // Click elsewhere to close panel
            document.addEventListener('click', function(e) {
                    if (!panel.contains(e.target) && 
                        e.target.id !== 'mobileMeasureBadge' && 
                        e.target.id !== 'mobileMeasureMode') {
                        showMobileMeasurements(false);
                }
            });
            }
        }

        // Path measurement functions
        function togglePathMeasureMode() {
            // If regular measure mode is active, turn it off
            if (isMeasureMode) {
                toggleMeasureMode();
            }

            isPathMeasureMode = !isPathMeasureMode;
            const pathMeasureButton = document.getElementById('pathMeasureMode');
            pathMeasureButton.classList.toggle('active', isPathMeasureMode);
            
            // Remove any preview marker when toggling mode
            removePathPreviewMarker();
            
            // Update mobile floating action button if on mobile
            if (isMobile) {
                document.getElementById('mobilePathMeasure').classList.toggle('path-measure-mobile-active', isPathMeasureMode);
                document.body.classList.toggle('path-measure-mobile-active', isPathMeasureMode);
                // Always show annotations in path measure mode on mobile
                document.getElementById('annotations').style.display = isPathMeasureMode ? 'block' : 'none';
                
                // Show/hide the complete path button based on path mode
                document.getElementById('mobileCompletePath').style.display = isPathMeasureMode ? 'flex' : 'none';
            }
            
            if (isPathMeasureMode) {
                controls.enableRotate = true; // Allow rotation in path measure mode
                pathMeasureButton.textContent = `Exit`;
                
                // Create a small notification to instruct the user
                const notification = document.createElement('div');
                notification.style.position = 'fixed';
                notification.style.top = '50%';
                notification.style.left = '50%';
                notification.style.transform = 'translate(-50%, -50%)';
                notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                notification.style.color = 'white';
                notification.style.padding = '10px 15px';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                notification.style.fontFamily = 'Arial, sans-serif';
                notification.style.fontSize = '16px';
                notification.textContent = isMobile ? 
                    'Path Measure: Tap to add points, complete path with button, double-tap to clear' : 
                    'Path Measure Mode: Click to place points. Press F to complete current path. Hold Space to rotate.';
                document.body.appendChild(notification);
                
                // Remove the notification after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 3000);
            } else {
                pathMeasureButton.textContent = 'Path';
                
                // When exiting path mode, auto-complete the current path if it has points
                if (pathMeasurementPoints.length >= 2) {
                    completeCurrentPath();
                }
            }
        }

        function addPathMeasurementPoint(point) {
            if (!isPathMeasureMode) return;
            
            // Add a marker at the clicked point
            const pointIndex = pathMeasurementPoints.length + 1;
            
            // Create the label div which will be our visible marker
            const labelDiv = document.createElement('div');
            labelDiv.className = 'path-marker-label';
            labelDiv.textContent = pointIndex;
            const markerLabel = new CSS2DObject(labelDiv);
            
            // Position directly at the point location and force update
            markerLabel.position.copy(point);
            markerLabel.updateMatrix();
            markerLabel.updateMatrixWorld(true);
            
            // Add directly to scene instead of using a mesh sphere
            measurementGroup.add(markerLabel);
            pathMeasurementLabels.push(markerLabel);
            
            // Add the point to our array
            pathMeasurementPoints.push(point);
            
            // If this is not the first point, create a line to the previous point
            if (pathMeasurementPoints.length > 1) {
                const prevPoint = pathMeasurementPoints[pathMeasurementPoints.length - 2];
                const currentPoint = point;
                
                // Create a white line between the points
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xFFFFFF, // White
                    linewidth: 4, 
                    transparent: false // No transparency
                });
                const geometry = new THREE.BufferGeometry().setFromPoints([prevPoint, currentPoint]);
                const line = new THREE.Line(geometry, lineMaterial);
                
                // Create a green dotted line for contrast
                const dottedLineMaterial = new THREE.LineDashedMaterial({ 
                    color: 0x00CC00, // Bright green
                    linewidth: 3, 
                    transparent: true,
                    opacity: 0.95, // Very little transparency
                    dashSize: 0.05, // Small dashes for a dotted effect
                    gapSize: 0.05
                });
                const dottedGeometry = new THREE.BufferGeometry().setFromPoints([prevPoint, currentPoint]);
                const dottedLine = new THREE.Line(dottedGeometry, dottedLineMaterial);
                dottedLine.computeLineDistances(); // Required for dashed lines
                
                // Add the green dotted line first (below) for proper layering
                measurementGroup.add(dottedLine);
                pathMeasurementLines.push(dottedLine);
                
                // Add the white line on top
                measurementGroup.add(line);
                pathMeasurementLines.push(line);
                
                // Calculate the distance between these two points
                const segmentDistance = prevPoint.distanceTo(currentPoint);
                pathTotalDistance += segmentDistance;
                
                // Create or update the total distance label
                updatePathTotalLabel();
                
                // Update the measurements list
                updateMeasurementsList();
                
                // Force label renderer update to ensure correct positioning
                labelRenderer.render(scene, camera);
            }
        }

        function updatePathTotalLabel() {
            // Remove existing total label if it exists
            if (pathTotalLabel) {
                measurementGroup.remove(pathTotalLabel);
            }
            
            // Only create a label if we have at least one line
            if (pathMeasurementPoints.length > 1) {
                // Create a label at the last point
                const lastPoint = pathMeasurementPoints[pathMeasurementPoints.length - 1];
                
                const labelDiv = document.createElement('div');
                labelDiv.className = 'path-total-label';
                labelDiv.textContent = `Total: ${getMeasurementText(pathTotalDistance)}`;
                pathTotalLabel = new CSS2DObject(labelDiv);
                
                // Position the label above the last point
                pathTotalLabel.position.copy(lastPoint);
                pathTotalLabel.position.y += 0.25; // Place it slightly above the point
                
                measurementGroup.add(pathTotalLabel);
            }
        }

        function cancelPathMeasurement() {
            // Clean up any path measurement visuals
            for (let i = measurementGroup.children.length - 1; i >= 0; i--) {
                const child = measurementGroup.children[i];
                
                // Check if this object is part of our path measurement
                let isPathObject = false;
                
                // Check if the object is a pathMeasurementLine
                for (let j = 0; j < pathMeasurementLines.length; j++) {
                    if (child === pathMeasurementLines[j]) {
                        isPathObject = true;
                        break;
                    }
                }
                
                // Check if the object contains a pathMeasurementLabel
                if (!isPathObject) {
                    for (let j = 0; j < pathMeasurementLabels.length; j++) {
                        if (child.children && child.children.includes(pathMeasurementLabels[j])) {
                            isPathObject = true;
                            break;
                        }
                    }
                }
                
                // Check if it's the total label
                if (!isPathObject && child === pathTotalLabel) {
                    isPathObject = true;
                }
                
                // Remove path measurement objects
                if (isPathObject) {
                    measurementGroup.remove(child);
                }
            }

            // Clear arrays
            pathMeasurementPoints = [];
            pathMeasurementLines = [];
            pathMeasurementLabels = [];
            
            // Remove the total label
            if (pathTotalLabel) {
                measurementGroup.remove(pathTotalLabel);
                pathTotalLabel = null;
            }
            
            // Reset total distance
            pathTotalDistance = 0;
            
            // Update the measurements list
            updateMeasurementsList();
        }

        // New function to cancel only the in-progress path measurement
        function cancelInProgressPathMeasurement() {
            // If we haven't started a new path or only have one point, completely cancel
            if (pathMeasurementPoints.length <= 1) {
                // This is effectively a new path, so cancel everything
                cancelPathMeasurement();
                return;
            }
            
            // Get the current measurement list state before removing the last point
            const currentPathTotal = pathTotalDistance;
            
            // If we have multiple points, just remove the last one (in-progress point)
            if (pathMeasurementPoints.length > 0) {
                // Remove the last point
                const lastPoint = pathMeasurementPoints.pop();
                
                // Remove the corresponding label
                if (pathMeasurementLabels.length > 0) {
                    const lastLabel = pathMeasurementLabels.pop();
                    // Find and remove the label from the scene
                    for (let i = 0; i < measurementGroup.children.length; i++) {
                        if (measurementGroup.children[i] === lastLabel) {
                            measurementGroup.remove(lastLabel);
                            break;
                        }
                    }
                }
                
                // If we have at least one point left, we need to remove the last line segment too
                if (pathMeasurementPoints.length > 0) {
                    // Remove the last two line segments (white line and green dotted line)
                    if (pathMeasurementLines.length >= 2) {
                        const lastLine1 = pathMeasurementLines.pop();
                        const lastLine2 = pathMeasurementLines.pop();
                        measurementGroup.remove(lastLine1);
                        measurementGroup.remove(lastLine2);
                        
                        // Recalculate the total distance by removing the last segment
                        if (pathMeasurementPoints.length > 1) {
                            // Get the previous point
                            const prevPoint = pathMeasurementPoints[pathMeasurementPoints.length - 1];
                            const distance = prevPoint.distanceTo(lastPoint);
                            pathTotalDistance -= distance;
                            
                            // Update the total label
                            updatePathTotalLabel();
                        }
                    }
                } else {
                    // If we removed the last point, reset total distance
                    pathTotalDistance = 0;
                    
                    // Remove the total label
                    if (pathTotalLabel) {
                        measurementGroup.remove(pathTotalLabel);
                        pathTotalLabel = null;
                    }
                }
                
                // Remove the preview marker
                removePathPreviewMarker();
                
                // Update the measurements list
                updateMeasurementsList();
                
                console.log("Cancelled in-progress path point. Remaining points:", pathMeasurementPoints.length);
            }
        }

        // Function to update the preview marker for path measurement
        function updatePathPreviewMarker(position, screenX, screenY) {
            // Remove existing preview marker if it exists
            removePathPreviewMarker();
            
            // Create a new preview marker
            const labelDiv = document.createElement('div');
            labelDiv.className = 'path-preview-marker';
            labelDiv.textContent = '‚Ä¢';
            
            // Create the CSS2D object
            pathPreviewMarker = new CSS2DObject(labelDiv);
            
            // Position it at the intersection point in 3D space
            pathPreviewMarker.position.copy(position);
            
            // Add to the measurement group
            measurementGroup.add(pathPreviewMarker);
            
            // Force an update of the label renderer to ensure correct positioning
            labelRenderer.render(scene, camera);
        }
        
        // Function to remove the preview marker
        function removePathPreviewMarker() {
            if (pathPreviewMarker) {
                measurementGroup.remove(pathPreviewMarker);
                pathPreviewMarker = null;
            }
        }

        // Debug function to visualize the ray being cast
        function visualizeRay(ray) {
            // Remove existing visualization
            if (rayVisualization) {
                scene.remove(rayVisualization);
                rayVisualization = null;
            }
            
            // Create line from ray origin extending in ray direction
            const rayLength = 200; // Extend the ray farther
            const endPoint = new THREE.Vector3().copy(ray.origin).addScaledVector(ray.direction, rayLength);
            const geometry = new THREE.BufferGeometry().setFromPoints([ray.origin, endPoint]);
            
            const material = new THREE.LineBasicMaterial({ 
                color: 0xff00ff, 
                linewidth: 2,
                transparent: true,
                opacity: 0.6
            });
            
            rayVisualization = new THREE.Line(geometry, material);
            scene.add(rayVisualization);
            
            // Auto-remove after a short delay
            setTimeout(() => {
                if (rayVisualization) {
                    scene.remove(rayVisualization);
                    rayVisualization = null;
                }
            }, 1000);
        }

        // Function to complete the current path and start a new one
        function completeCurrentPath() {
            // Only do something if we're in path measure mode and have at least 2 points
            if (pathMeasurementPoints.length >= 2) {
                // Create a complete path object
                const completedPath = {
                    id: currentPathId,
                    points: [...pathMeasurementPoints], // Clone the points array
                    totalDistance: pathTotalDistance,
                    showSegments: false, // Default to not showing segments
                    // Store references to visual elements for potential cleanup later
                    lines: [...pathMeasurementLines],
                    labels: [...pathMeasurementLabels],
                    totalLabel: pathTotalLabel
                };
                
                // Add to completed paths
                completedPaths.push(completedPath);
                
                // Increment the path ID
                currentPathId++;
                
                // Prepare for a new path
                pathMeasurementPoints = [];
                pathMeasurementLines = [];
                pathMeasurementLabels = [];
                pathTotalDistance = 0;
                pathTotalLabel = null;
                
                // Update the UI with a notification
                const notification = document.createElement('div');
                notification.style.position = 'fixed';
                notification.style.top = '50%';
                notification.style.left = '50%';
                notification.style.transform = 'translate(-50%, -50%)';
                notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                notification.style.color = 'white';
                notification.style.padding = '10px 15px';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1000';
                notification.style.fontFamily = 'Arial, sans-serif';
                notification.style.fontSize = '16px';
                notification.textContent = `Path completed! Ready for new path.`;
                document.body.appendChild(notification);
                
                // Remove notification after 2 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 2000);
                
                // Update the measurements list
                updateMeasurementsList();
            }
        }
    </script>
</body>
</html>
